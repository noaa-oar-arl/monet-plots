{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MONET Plots","text":"<p>A comprehensive plotting library for scientific visualization, spun off from the main MONET repository. MONET Plots provides a modular, extensible framework for creating high-quality scientific plots with a focus on meteorological and climate data visualization.</p>"},{"location":"#overview","title":"Overview","text":"<p>MONET Plots is designed to make scientific plotting easier, more consistent, and publication-ready. It leverages the power of matplotlib, seaborn, and cartopy while providing a simplified API and consistent styling.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Modular Plot Classes: Extensible plot classes for common scientific visualization needs</li> <li>Publication-Ready Styling: Built-in Wiley-compliant styling for professional appearance</li> <li>Cartopy Integration: Seamless integration with cartopy for geospatial plotting</li> <li>Multiple Plot Types: Spatial, time series, scatter, Taylor diagrams, KDE plots, and more</li> <li>Flexible Configuration: Easy customization of colors, styles, and plot parameters</li> <li>Performance Optimized: Designed for efficient plotting with large datasets</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7 or higher</li> <li>pip package manager</li> </ul>"},{"location":"#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install monet_plots\n</code></pre>"},{"location":"#install-from-source","title":"Install from Source","text":"<pre><code>git clone https://github.com/your-repo/monet-plots.git\ncd monet-plots\npip install -e .\n</code></pre>"},{"location":"#install-optional-dependencies","title":"Install Optional Dependencies","text":"<p>For full functionality, install additional optional dependencies:</p> <pre><code># For geospatial plotting\npip install cartopy\n\n# For statistical plotting\npip install seaborn pandas\n\n# For advanced Taylor diagrams\npip install numpy matplotlib\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import numpy as np\nimport pandas as pd\nfrom monet_plots import SpatialPlot, TimeSeriesPlot, ScatterPlot\n\n# Create sample data\nlat = np.linspace(30, 50, 20)\nlon = np.linspace(-120, -70, 30)\ndata = np.random.random((20, 30))\n\n# Create a spatial plot\nspatial_plot = SpatialPlot()\nspatial_plot.plot(data, title=\"Sample Spatial Plot\")\nspatial_plot.save(\"spatial_plot.png\")\n\n# Create time series data\ndates = pd.date_range('2023-01-01', periods=100, freq='D')\ntime_series_data = pd.DataFrame({\n    'time': dates,\n    'obs': np.random.normal(0, 1, 100) + np.sin(np.arange(100) * 0.1)\n})\n\n# Create a time series plot\nts_plot = TimeSeriesPlot()\nts_plot.plot(time_series_data, x='time', y='obs', title=\"Time Series Example\")\nts_plot.save(\"timeseries_plot.png\")\n</code></pre>"},{"location":"#core-components","title":"Core Components","text":""},{"location":"#plot-classes","title":"Plot Classes","text":"Plot Type Class Description Spatial <code>SpatialPlot</code> Geospatial plots with cartopy support Time Series <code>TimeSeriesPlot</code> Time series with statistical bands Scatter <code>ScatterPlot</code> Scatter plots with regression lines Taylor Diagram <code>TaylorDiagramPlot</code> Model evaluation diagrams KDE <code>KDEPlot</code> Kernel density estimation plots Wind <code>WindQuiverPlot</code> Wind vector plots Facet Grid <code>FacetGridPlot</code> Multi-panel figure layouts"},{"location":"#utility-modules","title":"Utility Modules","text":"<ul> <li><code>style</code>: Publication-ready styling configuration</li> <li><code>colorbars</code>: Custom colorbar creation utilities</li> <li><code>taylordiagram</code>: Taylor diagram functionality</li> <li><code>plot_utils</code>: Common plotting utilities</li> </ul>"},{"location":"#basic-usage-patterns","title":"Basic Usage Patterns","text":""},{"location":"#creating-plots","title":"Creating Plots","text":"<pre><code># Initialize a plot\nplot = SpatialPlot(figsize=(10, 6))\n\n# Plot data\nplot.plot(data, cmap='viridis', title=\"My Plot\")\n\n# Save and close\nplot.save(\"output.png\")\nplot.close()\n</code></pre>"},{"location":"#customization","title":"Customization","text":"<pre><code># Custom styling\nfrom monet_plots import wiley_style\nimport matplotlib.pyplot as plt\n\nplt.style.use(wiley_style)\n\n# Custom colorbars\nfrom monet_plots import colorbar_index\ncolorbar, cmap = colorbar_index(10, 'viridis', minval=0, maxval=100)\n</code></pre>"},{"location":"#documentation-structure","title":"Documentation Structure","text":""},{"location":"#core-documentation","title":"Core Documentation","text":"<ul> <li>Getting Started: Comprehensive installation and setup guide with detailed troubleshooting</li> <li>API Reference: Complete API documentation for all modules, classes, and functions</li> <li>Plot Types: Detailed documentation for all plot types with examples and best practices</li> </ul>"},{"location":"#learning-resources","title":"Learning Resources","text":"<ul> <li>Examples and Tutorials: Practical examples, workflows, and real-world use cases</li> <li>Configuration and Customization: Advanced styling, theming, and customization guides</li> <li>Performance Optimization: Techniques for handling large datasets and improving speed</li> </ul>"},{"location":"#support-and-troubleshooting","title":"Support and Troubleshooting","text":"<ul> <li>Troubleshooting and FAQ: Common issues, solutions, and expert guidance</li> <li>Contributing Guidelines: How to contribute to the project</li> <li>License: Project licensing information</li> </ul>"},{"location":"#documentation-categories","title":"Documentation Categories","text":"Category Description Level Beginner Getting Started, Basic Examples New users Intermediate API Reference, Plot Types, Configuration Regular users Advanced Performance, Advanced Examples, Troubleshooting Power users Expert Contributing, Development Developers"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our contributing guidelines for details.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#support","title":"Support","text":"<ul> <li>Documentation: https://monet-plots.readthedocs.io</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"getting-started/","title":"Getting Started Guide","text":"<p>Welcome to MONET Plots! This comprehensive guide will help you get up and running quickly with our scientific plotting library, from installation to creating your first professional plots.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: 3.7 or higher (recommended 3.8+)</li> <li>pip: Python package manager (comes with Python)</li> <li>Optional: conda (for managing complex dependencies)</li> <li>Memory: Minimum 512MB RAM (1GB+ recommended for large datasets)</li> <li>Disk: 50MB free space for installation</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before installing MONET Plots, ensure you have the following:</p> <pre><code># Check Python version\npython --version  # Should be 3.7 or higher\n\n# Check pip is installed and working\npip --version\n\n# Update pip to latest version\npython -m pip install --upgrade pip\n</code></pre>"},{"location":"getting-started/#step-by-step-installation","title":"Step-by-Step Installation","text":""},{"location":"getting-started/#1-install-monet-plots","title":"1. Install MONET Plots","text":"<pre><code># Install the latest stable release from PyPI\npip install monet_plots\n\n# For the latest development version\npip install git+https://github.com/your-repo/monet-plots.git\n\n# Install specific version (if needed)\npip install monet_plots==1.0.0\n</code></pre>"},{"location":"getting-started/#2-install-optional-dependencies","title":"2. Install Optional Dependencies","text":"<p>MONET Plots has a modular design with optional dependencies for enhanced functionality. Install these based on your needs:</p> <p>Core Dependencies (Recommended for most users): <pre><code># Essential data processing and visualization\npip install pandas seaborn matplotlib\n\n# Statistical computing\npip install numpy scipy\n</code></pre></p> <p>Geospatial and Climate Data: <pre><code># For geographical maps and projections\npip install cartopy\n\n# For NetCDF file handling\npip install xarray netcdf4\n\n# For advanced geospatial operations\npip install shapely pyproj\n</code></pre></p> <p>Advanced Statistical Features: <pre><code># For machine learning integration\npip install scikit-learn\n\n# For advanced statistical analysis\npip install statsmodels\n</code></pre></p> <p>Development and Testing: <pre><code># For development\npip install pytest black isort mypy\n\n# Documentation generation\npip install mkdocs mkdocs-material\n</code></pre></p>"},{"location":"getting-started/#3-verify-installation","title":"3. Verify Installation","text":"<p>Test your installation with these verification steps:</p> <pre><code># Basic import test\nimport monet_plots\nprint(f\"MONET Plots version: {monet_plots.__version__}\")\n\n# Test all major components\ntry:\n    from monet_plots import (\n        SpatialPlot, TimeSeriesPlot, ScatterPlot,\n        TaylorDiagramPlot, KDEPlot, WindQuiverPlot, WindBarbsPlot,\n        FacetGridPlot\n    )\n    print(\"All plot classes imported successfully!\")\nexcept ImportError as e:\n    print(f\"Import error: {e}\")\n\n# Test optional dependencies\ntry:\n    import cartopy\n    print(\"Cartopy available for geospatial plotting\")\nexcept ImportError:\n    print(\"Cartopy not available - install for geospatial features\")\n\ntry:\n    import xarray\n    print(\"xarray available for NetCDF support\")\nexcept ImportError:\n    print(\"xarray not available - install for NetCDF support\")\n</code></pre> <p>You should see success messages for all components without any errors.</p>"},{"location":"getting-started/#4-environment-setup","title":"4. Environment Setup","text":"<p>Virtual Environment (Recommended): <pre><code># Create virtual environment\npython -m venv monet_plots_env\n\n# Activate virtual environment\n# On Windows\nmonet_plots_env\\Scripts\\activate\n# On macOS/Linux\nsource monet_plots_env/bin/activate\n\n# Install in virtual environment\npip install monet_plots\n</code></pre></p> <p>Conda Environment: <pre><code># Create conda environment\nconda create -n monet_plots python=3.8\nconda activate monet_plots\n\n# Install with conda\nconda install -c conda-forge monet_plots\n</code></pre></p>"},{"location":"getting-started/#5-common-installation-issues","title":"5. Common Installation Issues","text":"<p>Permission Errors: <pre><code># Use user install (no sudo)\npip install --user monet_plots\n\n# Or use virtual environment\npython -m venv venv\nsource venv/bin/activate\npip install monet_plots\n</code></pre></p> <p>Network Issues: <pre><code># Use pip with timeout\npip install --timeout=60 monet_plots\n\n# Or use conda\nconda install -c conda-forge monet_plots\n</code></pre></p> <p>Missing Dependencies: <pre><code># Install specific versions\npip install matplotlib&gt;=3.3.0\npip install pandas&gt;=1.0.0\npip install numpy&gt;=1.18.0\npip install monet_plots\n</code></pre></p>"},{"location":"getting-started/#quick-setup","title":"Quick Setup","text":""},{"location":"getting-started/#basic-configuration","title":"Basic Configuration","text":"<pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import style\n\n# Apply the default Wiley-compliant style\nplt.style.use(style.wiley_style)\n\n# Your plotting code here\n</code></pre>"},{"location":"getting-started/#environment-setup","title":"Environment Setup","text":"<p>For consistency across projects, consider adding this to your environment setup:</p> <pre><code># setup_plotting.py\nimport matplotlib.pyplot as plt\nfrom monet_plots import style\n\n# Set up plotting style and defaults\nplt.style.use(style.wiley_style)\nplt.rcParams['figure.figsize'] = (8, 6)\nplt.rcParams['savefig.dpi'] = 300\nplt.rcParams['savefig.format'] = 'png'\n</code></pre>"},{"location":"getting-started/#your-first-plot","title":"Your First Plot","text":"<p>Let's create a simple time series plot to demonstrate the basic workflow:</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom monet_plots import TimeSeriesPlot\n\n# Create sample data\ndates = pd.date_range('2023-01-01', periods=100, freq='D')\ndata = pd.DataFrame({\n    'time': dates,\n    'temperature': 20 + 10 * np.sin(np.arange(100) * 0.1) + np.random.normal(0, 2, 100)\n})\n\n# Create and plot\nplot = TimeSeriesPlot()\nplot.plot(data, x='time', y='temperature', title='Daily Temperature', ylabel='Temperature (\u00b0C)')\nplot.save('temperature_plot.png')\nplot.close()\n</code></pre>"},{"location":"getting-started/#understanding-the-architecture","title":"Understanding the Architecture","text":""},{"location":"getting-started/#plot-classes","title":"Plot Classes","text":"<p>MONET Plots follows a class-based architecture where each plot type has its own class:</p> <pre><code>BasePlot (abstract base class)\n\u251c\u2500\u2500 SpatialPlot\n\u251c\u2500\u2500 TimeSeriesPlot\n\u251c\u2500\u2500 TimeSeriesPlot\n\u251c\u2500\u2500 ScatterPlot\n\u251c\u2500\u2500 TaylorDiagramPlot\n\u251c\u2500\u2500 KDEPlot\n\u251c\u2500\u2500 WindQuiverPlot\n\u2514\u2500\u2500 WindBarbsPlot\n</code></pre>"},{"location":"getting-started/#common-workflow","title":"Common Workflow","text":"<ol> <li>Initialize: Create a plot instance with desired parameters</li> <li>Plot: Call the plot method with your data</li> <li>Customize: Add labels, titles, and other customizations</li> <li>Save: Export the plot to file</li> <li>Close: Close the plot to free memory</li> </ol> <pre><code># General workflow pattern\nplot = SpatialPlot(figsize=(10, 6))         # 1. Initialize\nplot.plot(data, cmap='viridis')             # 2. Plot data\nplot.title(\"My Plot\").xlabel(\"X Axis\")      # 3. Customize\nplot.save(\"output.png\")                    # 4. Save\nplot.close()                               # 5. Close\n</code></pre>"},{"location":"getting-started/#data-requirements","title":"Data Requirements","text":""},{"location":"getting-started/#supported-data-types","title":"Supported Data Types","text":""},{"location":"getting-started/#pandas-dataframe","title":"Pandas DataFrame","text":"<p>Most plots expect pandas DataFrames with specific column names:</p> <pre><code>df = pd.DataFrame({\n    'time': pd.date_range('2023-01-01', periods=100),\n    'observed': np.random.normal(0, 1, 100),\n    'modeled': np.random.normal(0.1, 1.1, 100)\n})\n</code></pre>"},{"location":"getting-started/#numpy-arrays","title":"NumPy Arrays","text":"<p>For some plots, raw numpy arrays are sufficient:</p> <pre><code>import numpy as np\ndata = np.random.random((50, 100))  # 2D array for spatial plots\n</code></pre>"},{"location":"getting-started/#xarray-dataarrays","title":"xarray DataArrays","text":"<p>For geospatial data:</p> <pre><code>import xarray as xr\ndata = xr.DataArray(\n    np.random.random((10, 20)),\n    dims=['lat', 'lon'],\n    coords={'lat': range(10), 'lon': range(20)}\n)\n</code></pre>"},{"location":"getting-started/#data-format-guidelines","title":"Data Format Guidelines","text":"<ul> <li>Time data: Use pandas datetime objects for time series</li> <li>Spatial data: Follow standard coordinate conventions (lat/lon, x/y)</li> <li>Missing values: Handle NaN values appropriately</li> <li>Units: Include units in column names or documentation</li> </ul>"},{"location":"getting-started/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/#style-customization","title":"Style Customization","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Create custom style\ncustom_style = {\n    'font.size': 12,\n    'axes.labelsize': 10,\n    'axes.titlesize': 14,\n    'lines.linewidth': 2,\n    'figure.figsize': (10, 6)\n}\n\nplt.style.use(custom_style)\n</code></pre>"},{"location":"getting-started/#default-parameters","title":"Default Parameters","text":"<p>Set up default parameters for your project:</p> <pre><code>from monet_plots import style\n\n# Modify the default style\nmodified_style = style.wiley_style.copy()\nmodified_style['font.size'] = 11\nmodified_style['figure.figsize'] = (12, 8)\n\nplt.style.use(modified_style)\n</code></pre>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#import-errors","title":"Import Errors","text":"<pre><code># If you get import errors, try reinstalling\npip uninstall monet_plots\npip install monet_plots\n</code></pre>"},{"location":"getting-started/#missing-dependencies","title":"Missing Dependencies","text":"<pre><code># Install missing cartopy dependency\npip install cartopy\n</code></pre>"},{"location":"getting-started/#plot-display-issues","title":"Plot Display Issues","text":"<pre><code># Ensure interactive plotting is enabled\n%matplotlib inline  # For Jupyter notebooks\nplt.ion()           # For interactive scripts\n</code></pre>"},{"location":"getting-started/#performance-tips","title":"Performance Tips","text":"<ol> <li>Close plots when done: <code>plot.close()</code></li> <li>Use appropriate data types: Pandas DataFrames for tabular data</li> <li>Limit data size: Downsample large datasets for interactive plotting</li> <li>Use efficient file formats: PNG for web, TIFF for publications</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>After completing this guide, explore:</p> <ol> <li>Plot Types: Learn about specific plot types and their usage</li> <li>API Reference: Detailed documentation for all modules</li> <li>Examples: Practical examples and tutorials</li> <li>Configuration: Advanced customization options</li> </ol>"},{"location":"getting-started/#need-help","title":"Need Help?","text":"<ul> <li>Check the API Reference for detailed documentation</li> <li>Browse Examples for use cases similar to yours</li> <li>Visit our GitHub Issues for support</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This is the API reference for MONET Plots.</p>"},{"location":"api/#modules","title":"Modules","text":"<p>Cartopy-based plotting utilities for MONET.</p> <p>Colorbar helper functions</p> <p>Taylor diagram (Taylor, 2001) implementation.</p> <p>A Taylor diagram is a graphical representation of how well a model simulates an observed pattern. It provides a way to summarize multiple aspects of model performance, including: - Correlation coefficient - Root-mean-square (RMS) difference - The standard deviation ratio</p> <p>Reference: Taylor, K.E., 2001. Summarizing multiple aspects of model performance in a single diagram. Journal of Geophysical Research, 106(D7), 7183-7192.</p>"},{"location":"api/#monet_plots.cartopy_utils.facet_time_map","title":"<code>facet_time_map(da, time_dim='time', ncols=3, map_kws=None, projection=None, colorbar=True, figsize=None, cmap=None, vmin=None, vmax=None, norm=None, dpi=150, xlabel=None, ylabel=None, suptitle=None, cbar_label=None, xticks=None, yticks=None, annotations=None, export_path=None, export_formats=None, **kwargs)</code>","text":"<p>Create a facet grid of map plots for each time slice in a DataArray using Cartopy.</p>"},{"location":"api/#monet_plots.cartopy_utils.facet_time_map--parameters","title":"Parameters","text":"<p>da : xarray.DataArray     The data to plot (must have a time dimension). time_dim : str, default: \"time\"     Name of the time dimension. ncols : int, default: 3     Number of columns in the facet grid. map_kws : dict, optional     Dictionary of keyword arguments for map features. projection : cartopy.crs.Projection, optional     Cartopy projection to use. Defaults to PlateCarree. colorbar : bool, default: True     Whether to add a colorbar (shared). figsize : tuple, optional     Figure size. cmap : str or Colormap, optional     Colormap to use. vmin, vmax : float, optional     Color limits. norm : Normalize, optional     Matplotlib normalization. dpi : int, optional     Dots per inch for export. xlabel, ylabel, suptitle : str, optional     Axis labels and super title. cbar_label : str, optional     Label for the colorbar. xticks, yticks : list, optional     Custom tick locations. annotations : list of dict, optional     List of annotation dicts for each subplot. export_path : str, optional     Path to export the figure (without extension). export_formats : list, optional     List of formats to export (e.g., [\"png\", \"pdf\"]). **kwargs : dict     Additional keyword arguments for plotting.</p>"},{"location":"api/#monet_plots.cartopy_utils.facet_time_map--returns","title":"Returns","text":"<p>fig : matplotlib.figure.Figure     The matplotlib figure object. axes : ndarray of matplotlib.axes.Axes     The matplotlib axes objects.</p> Source code in <code>src/monet_plots/cartopy_utils.py</code> <pre><code>def facet_time_map(\n    da,\n    time_dim=\"time\",\n    ncols=3,\n    map_kws=None,\n    projection=None,\n    colorbar=True,\n    figsize=None,\n    cmap=None,\n    vmin=None,\n    vmax=None,\n    norm=None,\n    dpi=150,\n    xlabel=None,\n    ylabel=None,\n    suptitle=None,\n    cbar_label=None,\n    xticks=None,\n    yticks=None,\n    annotations=None,\n    export_path=None,\n    export_formats=None,\n    **kwargs,\n):\n    \"\"\"\n    Create a facet grid of map plots for each time slice in a DataArray using Cartopy.\n\n    Parameters\n    ----------\n    da : xarray.DataArray\n        The data to plot (must have a time dimension).\n    time_dim : str, default: \"time\"\n        Name of the time dimension.\n    ncols : int, default: 3\n        Number of columns in the facet grid.\n    map_kws : dict, optional\n        Dictionary of keyword arguments for map features.\n    projection : cartopy.crs.Projection, optional\n        Cartopy projection to use. Defaults to PlateCarree.\n    colorbar : bool, default: True\n        Whether to add a colorbar (shared).\n    figsize : tuple, optional\n        Figure size.\n    cmap : str or Colormap, optional\n        Colormap to use.\n    vmin, vmax : float, optional\n        Color limits.\n    norm : Normalize, optional\n        Matplotlib normalization.\n    dpi : int, optional\n        Dots per inch for export.\n    xlabel, ylabel, suptitle : str, optional\n        Axis labels and super title.\n    cbar_label : str, optional\n        Label for the colorbar.\n    xticks, yticks : list, optional\n        Custom tick locations.\n    annotations : list of dict, optional\n        List of annotation dicts for each subplot.\n    export_path : str, optional\n        Path to export the figure (without extension).\n    export_formats : list, optional\n        List of formats to export (e.g., [\"png\", \"pdf\"]).\n    **kwargs : dict\n        Additional keyword arguments for plotting.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The matplotlib figure object.\n    axes : ndarray of matplotlib.axes.Axes\n        The matplotlib axes objects.\n    \"\"\"\n    # Setup\n    projection = _setup_map_projection(projection)\n    map_kws = map_kws or {}\n    times = da[time_dim].values\n    nt = len(times)\n\n    # Create facet grid\n    fig, axes, nrows, ncols = _setup_facet_grid(nt, ncols, projection, figsize, dpi)\n\n    # Prepare plot arguments\n    plot_args = dict(cmap=cmap, vmin=vmin, vmax=vmax, norm=norm, add_colorbar=False)\n    plot_args.update(kwargs)\n\n    # Plot each time slice\n    mesh = None\n    for i, t in enumerate(times):\n        ax = axes[i]\n        dat = da.sel({time_dim: t})\n        mesh = dat.plot(ax=ax, transform=ccrs.PlateCarree(), **plot_args)\n\n        # Setup individual facet axis\n        title = str(np.datetime_as_string(t))\n        _setup_single_facet_axis(ax, map_kws, xlabel, ylabel, xticks, yticks, title)\n\n        # Add annotations if provided\n        if annotations and i &lt; len(annotations):\n            ax.annotate(**annotations[i])\n\n    # Clean up unused axes\n    for j in range(nt, len(axes)):\n        fig.delaxes(axes[j])\n\n    # Add shared colorbar\n    _add_shared_colorbar(fig, axes, mesh, colorbar, cbar_label)\n\n    # Set super title\n    if suptitle:\n        fig.suptitle(suptitle, fontsize=14, fontweight=\"bold\")\n\n    # Export figure\n    _export_figure(fig, export_path, export_formats, dpi)\n\n    return fig, axes\n</code></pre>"},{"location":"api/#monet_plots.cartopy_utils.plot_lines_map","title":"<code>plot_lines_map(df, lon_col='longitude', lat_col='latitude', group_col=None, projection=None, color='C0', linewidth=2, alpha=0.8, map_kws=None, figsize=(8, 6), dpi=150, title=None, export_path=None, export_formats=None, **kwargs)</code>","text":"<p>Plot lines from a DataFrame on a Cartopy map. Optionally group by a column.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_lines_map--parameters","title":"Parameters","text":"<p>df : pandas.DataFrame     DataFrame with longitude and latitude columns. lon_col, lat_col : str     Column names for longitude and latitude. group_col : str, optional     Column to group lines (e.g., for trajectories). projection : cartopy.crs.Projection, optional     Cartopy projection to use. Defaults to PlateCarree. color : str or array-like, optional     Line color. linewidth : float, optional     Line width. alpha : float, optional     Line transparency. map_kws : dict, optional     Map feature keyword arguments. figsize : tuple, optional     Figure size. dpi : int, optional     Dots per inch for export. title : str, optional     Plot title. export_path : str, optional     Path to export the figure (without extension). export_formats : list, optional     List of formats to export (e.g., [\"png\", \"pdf\"]). **kwargs : dict     Additional keyword arguments for plt.plot.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_lines_map--returns","title":"Returns","text":"<p>fig, ax : matplotlib Figure and Axes</p> Source code in <code>src/monet_plots/cartopy_utils.py</code> <pre><code>def plot_lines_map(\n    df,\n    lon_col=\"longitude\",\n    lat_col=\"latitude\",\n    group_col=None,\n    projection=None,\n    color=\"C0\",\n    linewidth=2,\n    alpha=0.8,\n    map_kws=None,\n    figsize=(8, 6),\n    dpi=150,\n    title=None,\n    export_path=None,\n    export_formats=None,\n    **kwargs,\n):\n    \"\"\"\n    Plot lines from a DataFrame on a Cartopy map. Optionally group by a column.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        DataFrame with longitude and latitude columns.\n    lon_col, lat_col : str\n        Column names for longitude and latitude.\n    group_col : str, optional\n        Column to group lines (e.g., for trajectories).\n    projection : cartopy.crs.Projection, optional\n        Cartopy projection to use. Defaults to PlateCarree.\n    color : str or array-like, optional\n        Line color.\n    linewidth : float, optional\n        Line width.\n    alpha : float, optional\n        Line transparency.\n    map_kws : dict, optional\n        Map feature keyword arguments.\n    figsize : tuple, optional\n        Figure size.\n    dpi : int, optional\n        Dots per inch for export.\n    title : str, optional\n        Plot title.\n    export_path : str, optional\n        Path to export the figure (without extension).\n    export_formats : list, optional\n        List of formats to export (e.g., [\"png\", \"pdf\"]).\n    **kwargs : dict\n        Additional keyword arguments for plt.plot.\n\n    Returns\n    -------\n    fig, ax : matplotlib Figure and Axes\n    \"\"\"\n    # Setup\n    projection = _setup_map_projection(projection)\n    map_kws = map_kws or {}\n    fig, ax = plt.subplots(\n        subplot_kw={\"projection\": projection}, figsize=figsize, dpi=dpi\n    )\n\n    # Add map features\n    _add_map_features(ax, map_kws)\n\n    # Plot lines\n    if group_col:\n        for _, group in df.groupby(group_col):\n            ax.plot(\n                group[lon_col],\n                group[lat_col],\n                color=color,\n                linewidth=linewidth,\n                alpha=alpha,\n                transform=ccrs.PlateCarree(),\n                **kwargs,\n            )\n    else:\n        ax.plot(\n            df[lon_col],\n            df[lat_col],\n            color=color,\n            linewidth=linewidth,\n            alpha=alpha,\n            transform=ccrs.PlateCarree(),\n            **kwargs,\n        )\n\n    # Set title\n    if title:\n        ax.set_title(title, fontsize=14, fontweight=\"bold\")\n\n    # Finalize\n    fig.tight_layout()\n    _export_figure(fig, export_path, export_formats, dpi)\n\n    return fig, ax\n</code></pre>"},{"location":"api/#monet_plots.cartopy_utils.plot_points_map","title":"<code>plot_points_map(df, lon_col='longitude', lat_col='latitude', projection=None, color='C0', marker='o', size=40, edgecolor='k', alpha=0.8, map_kws=None, figsize=(8, 6), dpi=150, title=None, export_path=None, export_formats=None, **kwargs)</code>","text":"<p>Plot points from a DataFrame on a Cartopy map.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_points_map--parameters","title":"Parameters","text":"<p>df : pandas.DataFrame     DataFrame with longitude and latitude columns. lon_col, lat_col : str     Column names for longitude and latitude. projection : cartopy.crs.Projection, optional     Cartopy projection to use. Defaults to PlateCarree. color : str or array-like, optional     Color for points. marker : str, optional     Marker style. size : float or array-like, optional     Marker size. edgecolor : str, optional     Marker edge color. alpha : float, optional     Marker transparency. map_kws : dict, optional     Map feature keyword arguments. figsize : tuple, optional     Figure size. dpi : int, optional     Dots per inch for export. title : str, optional     Plot title. export_path : str, optional     Path to export the figure (without extension). export_formats : list, optional     List of formats to export (e.g., [\"png\", \"pdf\"]). **kwargs : dict     Additional keyword arguments for plt.scatter.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_points_map--returns","title":"Returns","text":"<p>fig, ax : matplotlib Figure and Axes</p> Source code in <code>src/monet_plots/cartopy_utils.py</code> <pre><code>def plot_points_map(\n    df,\n    lon_col=\"longitude\",\n    lat_col=\"latitude\",\n    projection=None,\n    color=\"C0\",\n    marker=\"o\",\n    size=40,\n    edgecolor=\"k\",\n    alpha=0.8,\n    map_kws=None,\n    figsize=(8, 6),\n    dpi=150,\n    title=None,\n    export_path=None,\n    export_formats=None,\n    **kwargs,\n):\n    \"\"\"\n    Plot points from a DataFrame on a Cartopy map.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        DataFrame with longitude and latitude columns.\n    lon_col, lat_col : str\n        Column names for longitude and latitude.\n    projection : cartopy.crs.Projection, optional\n        Cartopy projection to use. Defaults to PlateCarree.\n    color : str or array-like, optional\n        Color for points.\n    marker : str, optional\n        Marker style.\n    size : float or array-like, optional\n        Marker size.\n    edgecolor : str, optional\n        Marker edge color.\n    alpha : float, optional\n        Marker transparency.\n    map_kws : dict, optional\n        Map feature keyword arguments.\n    figsize : tuple, optional\n        Figure size.\n    dpi : int, optional\n        Dots per inch for export.\n    title : str, optional\n        Plot title.\n    export_path : str, optional\n        Path to export the figure (without extension).\n    export_formats : list, optional\n        List of formats to export (e.g., [\"png\", \"pdf\"]).\n    **kwargs : dict\n        Additional keyword arguments for plt.scatter.\n\n    Returns\n    -------\n    fig, ax : matplotlib Figure and Axes\n    \"\"\"\n    # Setup\n    projection = _setup_map_projection(projection)\n    map_kws = map_kws or {}\n    fig, ax = plt.subplots(\n        subplot_kw={\"projection\": projection}, figsize=figsize, dpi=dpi\n    )\n\n    # Add map features\n    _add_map_features(ax, map_kws)\n\n    # Plot points\n    ax.scatter(\n        df[lon_col],\n        df[lat_col],\n        color=color,\n        marker=marker,\n        s=size,\n        edgecolor=edgecolor,\n        alpha=alpha,\n        transform=ccrs.PlateCarree(),\n        **kwargs,\n    )\n\n    # Set title\n    if title:\n        ax.set_title(title, fontsize=14, fontweight=\"bold\")\n\n    # Finalize\n    fig.tight_layout()\n    _export_figure(fig, export_path, export_formats, dpi)\n\n    return fig, ax\n</code></pre>"},{"location":"api/#monet_plots.cartopy_utils.plot_quick_contourf","title":"<code>plot_quick_contourf(da, map_kws=None, projection=None, colorbar=True, figsize=None, cmap=None, vmin=None, vmax=None, norm=None, dpi=150, xlabel=None, ylabel=None, title=None, cbar_label=None, cbar_inset=False, xticks=None, yticks=None, annotations=None, export_path=None, export_formats=None, **kwargs)</code>","text":"<p>Create a publication-quality filled contour plot of the data on a map using Cartopy.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_quick_contourf--parameters","title":"Parameters","text":"<p>da : xarray.DataArray     The data to plot. map_kws : dict, optional     Dictionary of keyword arguments for map features (e.g., coastlines, gridlines, features, borders, land, ocean). projection : cartopy.crs.Projection, optional     Cartopy projection to use. Defaults to PlateCarree. colorbar : bool, default: True     Whether to add a colorbar. figsize : tuple, optional     Figure size. cmap : str or Colormap, optional     Colormap to use (supports colorblind-friendly options). vmin, vmax : float, optional     Color limits. norm : Normalize, optional     Matplotlib normalization (e.g., LogNorm). dpi : int, optional     Dots per inch for export. xlabel, ylabel, title : str, optional     Axis labels and plot title. cbar_label : str, optional     Label for the colorbar. cbar_inset : bool, default: False     Place colorbar as an inset (right) if True. xticks, yticks : list, optional     Custom tick locations. annotations : list of dict, optional     List of annotation dicts (e.g., {\"text\": \"A\", \"xy\": (lon, lat)}). export_path : str, optional     Path to export the figure (without extension). export_formats : list, optional     List of formats to export (e.g., [\"png\", \"pdf\"]). **kwargs : dict     Additional keyword arguments for contourf.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_quick_contourf--returns","title":"Returns","text":"<p>fig : matplotlib.figure.Figure     The matplotlib figure object. ax : matplotlib.axes.Axes     The matplotlib axes object.</p> Source code in <code>src/monet_plots/cartopy_utils.py</code> <pre><code>def plot_quick_contourf(\n    da,\n    map_kws=None,\n    projection=None,\n    colorbar=True,\n    figsize=None,\n    cmap=None,\n    vmin=None,\n    vmax=None,\n    norm=None,\n    dpi=150,\n    xlabel=None,\n    ylabel=None,\n    title=None,\n    cbar_label=None,\n    cbar_inset=False,\n    xticks=None,\n    yticks=None,\n    annotations=None,\n    export_path=None,\n    export_formats=None,\n    **kwargs,\n):\n    \"\"\"\n    Create a publication-quality filled contour plot of the data on a map using Cartopy.\n\n    Parameters\n    ----------\n    da : xarray.DataArray\n        The data to plot.\n    map_kws : dict, optional\n        Dictionary of keyword arguments for map features (e.g., coastlines, gridlines, features, borders, land, ocean).\n    projection : cartopy.crs.Projection, optional\n        Cartopy projection to use. Defaults to PlateCarree.\n    colorbar : bool, default: True\n        Whether to add a colorbar.\n    figsize : tuple, optional\n        Figure size.\n    cmap : str or Colormap, optional\n        Colormap to use (supports colorblind-friendly options).\n    vmin, vmax : float, optional\n        Color limits.\n    norm : Normalize, optional\n        Matplotlib normalization (e.g., LogNorm).\n    dpi : int, optional\n        Dots per inch for export.\n    xlabel, ylabel, title : str, optional\n        Axis labels and plot title.\n    cbar_label : str, optional\n        Label for the colorbar.\n    cbar_inset : bool, default: False\n        Place colorbar as an inset (right) if True.\n    xticks, yticks : list, optional\n        Custom tick locations.\n    annotations : list of dict, optional\n        List of annotation dicts (e.g., {\"text\": \"A\", \"xy\": (lon, lat)}).\n    export_path : str, optional\n        Path to export the figure (without extension).\n    export_formats : list, optional\n        List of formats to export (e.g., [\"png\", \"pdf\"]).\n    **kwargs : dict\n        Additional keyword arguments for contourf.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The matplotlib figure object.\n    ax : matplotlib.axes.Axes\n        The matplotlib axes object.\n    \"\"\"\n    # Setup\n    projection = _setup_map_projection(projection)\n    map_kws = map_kws or {}\n    fig, ax = plt.subplots(\n        subplot_kw={\"projection\": projection}, figsize=figsize, dpi=dpi\n    )\n\n    # Prepare plot arguments\n    plot_args = dict(cmap=cmap, vmin=vmin, vmax=vmax, norm=norm)\n    plot_args.update({k: v for k, v in kwargs.items() if k not in [\"ax\", \"transform\"]})\n\n    # Create the plot\n    mesh = da.plot.contourf(ax=ax, transform=ccrs.PlateCarree(), **plot_args)\n\n    # Add map features\n    _add_map_features(ax, map_kws)\n\n    # Set labels and title\n    _set_axis_labels_and_title(ax, xlabel, ylabel, title)\n\n    # Set custom ticks\n    _set_custom_ticks(ax, xticks, yticks)\n\n    # Add annotations\n    _add_annotations(ax, annotations)\n\n    # Add colorbar\n    _add_colorbar(fig, ax, mesh, colorbar, cbar_label, cbar_inset)\n\n    # Finalize\n    fig.tight_layout()\n    _export_figure(fig, export_path, export_formats, dpi)\n\n    return fig, ax\n</code></pre>"},{"location":"api/#monet_plots.cartopy_utils.plot_quick_imshow","title":"<code>plot_quick_imshow(da, map_kws=None, projection=None, colorbar=True, figsize=None, cmap=None, vmin=None, vmax=None, norm=None, dpi=150, xlabel=None, ylabel=None, title=None, cbar_label=None, cbar_inset=False, xticks=None, yticks=None, annotations=None, export_path=None, export_formats=None, **kwargs)</code>","text":"<p>Create a imshow plot of the data on a map using Cartopy.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_quick_imshow--parameters","title":"Parameters","text":"<p>da : xarray.DataArray     The data to plot. map_kws : dict, optional     Dictionary of keyword arguments for map features (e.g., coastlines, gridlines, features, borders, land, ocean). projection : cartopy.crs.Projection, optional     Cartopy projection to use. Defaults to PlateCarree. colorbar : bool, default: True     Whether to add a colorbar. figsize : tuple, optional     Figure size. cmap : str or Colormap, optional     Colormap to use (supports colorblind-friendly options). vmin, vmax : float, optional     Color limits. norm : Normalize, optional     Matplotlib normalization (e.g., LogNorm). dpi : int, optional     Dots per inch for export. xlabel, ylabel, title : str, optional     Axis labels and plot title. cbar_label : str, optional     Label for the colorbar. cbar_inset : bool, default: False     Place colorbar as an inset (right) if True. xticks, yticks : list, optional     Custom tick locations. annotations : list of dict, optional     List of annotation dicts (e.g., {\"text\": \"A\", \"xy\": (lon, lat)}). export_path : str, optional     Path to export the figure (without extension). export_formats : list, optional     List of formats to export (e.g., [\"png\", \"pdf\"]). **kwargs : dict     Additional keyword arguments for imshow.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_quick_imshow--returns","title":"Returns","text":"<p>fig : matplotlib.figure.Figure     The matplotlib figure object. ax : matplotlib.axes.Axes     The matplotlib axes object.</p> Source code in <code>src/monet_plots/cartopy_utils.py</code> <pre><code>def plot_quick_imshow(\n    da,\n    map_kws=None,\n    projection=None,\n    colorbar=True,\n    figsize=None,\n    cmap=None,\n    vmin=None,\n    vmax=None,\n    norm=None,\n    dpi=150,\n    xlabel=None,\n    ylabel=None,\n    title=None,\n    cbar_label=None,\n    cbar_inset=False,\n    xticks=None,\n    yticks=None,\n    annotations=None,\n    export_path=None,\n    export_formats=None,\n    **kwargs,\n):\n    \"\"\"\n    Create a imshow plot of the data on a map using Cartopy.\n\n    Parameters\n    ----------\n    da : xarray.DataArray\n        The data to plot.\n    map_kws : dict, optional\n        Dictionary of keyword arguments for map features (e.g., coastlines, gridlines, features, borders, land, ocean).\n    projection : cartopy.crs.Projection, optional\n        Cartopy projection to use. Defaults to PlateCarree.\n    colorbar : bool, default: True\n        Whether to add a colorbar.\n    figsize : tuple, optional\n        Figure size.\n    cmap : str or Colormap, optional\n        Colormap to use (supports colorblind-friendly options).\n    vmin, vmax : float, optional\n        Color limits.\n    norm : Normalize, optional\n        Matplotlib normalization (e.g., LogNorm).\n    dpi : int, optional\n        Dots per inch for export.\n    xlabel, ylabel, title : str, optional\n        Axis labels and plot title.\n    cbar_label : str, optional\n        Label for the colorbar.\n    cbar_inset : bool, default: False\n        Place colorbar as an inset (right) if True.\n    xticks, yticks : list, optional\n        Custom tick locations.\n    annotations : list of dict, optional\n        List of annotation dicts (e.g., {\"text\": \"A\", \"xy\": (lon, lat)}).\n    export_path : str, optional\n        Path to export the figure (without extension).\n    export_formats : list, optional\n        List of formats to export (e.g., [\"png\", \"pdf\"]).\n    **kwargs : dict\n        Additional keyword arguments for imshow.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The matplotlib figure object.\n    ax : matplotlib.axes.Axes\n        The matplotlib axes object.\n    \"\"\"\n    # Setup\n    projection = _setup_map_projection(projection)\n    map_kws = map_kws or {}\n    fig, ax = plt.subplots(\n        subplot_kw={\"projection\": projection}, figsize=figsize, dpi=dpi\n    )\n\n    # Prepare plot arguments\n    plot_args = dict(cmap=cmap, vmin=vmin, vmax=vmax, norm=norm)\n    plot_args.update({k: v for k, v in kwargs.items() if k not in [\"ax\", \"transform\"]})\n\n    # Create the plot\n    mesh = da.plot.imshow(ax=ax, transform=ccrs.PlateCarree(), **plot_args)\n\n    # Add map features\n    _add_map_features(ax, map_kws)\n\n    # Set labels and title\n    _set_axis_labels_and_title(ax, xlabel, ylabel, title)\n\n    # Set custom ticks\n    _set_custom_ticks(ax, xticks, yticks)\n\n    # Add annotations\n    _add_annotations(ax, annotations)\n\n    # Add colorbar\n    _add_colorbar(fig, ax, mesh, colorbar, cbar_label, cbar_inset)\n\n    # Finalize\n    fig.tight_layout()\n    _export_figure(fig, export_path, export_formats, dpi)\n\n    return fig, ax\n</code></pre>"},{"location":"api/#monet_plots.cartopy_utils.plot_quick_map","title":"<code>plot_quick_map(da, map_kws=None, projection=None, colorbar=True, figsize=None, cmap=None, vmin=None, vmax=None, norm=None, dpi=150, xlabel=None, ylabel=None, title=None, cbar_label=None, cbar_inset=False, xticks=None, yticks=None, annotations=None, export_path=None, export_formats=None, **kwargs)</code>","text":"<p>Create a publication-quality map plot of the data using Cartopy and xarray's default plot method.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_quick_map--parameters","title":"Parameters","text":"<p>da : xarray.DataArray     The data to plot. map_kws : dict, optional     Dictionary of keyword arguments for map features (e.g., coastlines, gridlines, features, borders, land, ocean). projection : cartopy.crs.Projection, optional     Cartopy projection to use. Defaults to PlateCarree. colorbar : bool, default: True     Whether to add a colorbar. figsize : tuple, optional     Figure size. cmap : str or Colormap, optional     Colormap to use (supports colorblind-friendly options). vmin, vmax : float, optional     Color limits. norm : Normalize, optional     Matplotlib normalization (e.g., LogNorm). dpi : int, optional     Dots per inch for export. xlabel, ylabel, title : str, optional     Axis labels and plot title. cbar_label : str, optional     Label for the colorbar. cbar_inset : bool, default: False     Place colorbar as an inset (right) if True. xticks, yticks : list, optional     Custom tick locations. annotations : list of dict, optional     List of annotation dicts (e.g., {\"text\": \"A\", \"xy\": (lon, lat)}). export_path : str, optional     Path to export the figure (without extension). export_formats : list, optional     List of formats to export (e.g., [\"png\", \"pdf\"]). **kwargs : dict     Additional keyword arguments for xarray's plot method.</p>"},{"location":"api/#monet_plots.cartopy_utils.plot_quick_map--returns","title":"Returns","text":"<p>fig : matplotlib.figure.Figure     The matplotlib figure object. ax : matplotlib.axes.Axes     The matplotlib axes object.</p> Source code in <code>src/monet_plots/cartopy_utils.py</code> <pre><code>def plot_quick_map(\n    da,\n    map_kws=None,\n    projection=None,\n    colorbar=True,\n    figsize=None,\n    cmap=None,\n    vmin=None,\n    vmax=None,\n    norm=None,\n    dpi=150,\n    xlabel=None,\n    ylabel=None,\n    title=None,\n    cbar_label=None,\n    cbar_inset=False,\n    xticks=None,\n    yticks=None,\n    annotations=None,\n    export_path=None,\n    export_formats=None,\n    **kwargs,\n):\n    \"\"\"\n    Create a publication-quality map plot of the data using Cartopy and xarray's\n    default plot method.\n\n    Parameters\n    ----------\n    da : xarray.DataArray\n        The data to plot.\n    map_kws : dict, optional\n        Dictionary of keyword arguments for map features (e.g., coastlines, gridlines, features, borders, land, ocean).\n    projection : cartopy.crs.Projection, optional\n        Cartopy projection to use. Defaults to PlateCarree.\n    colorbar : bool, default: True\n        Whether to add a colorbar.\n    figsize : tuple, optional\n        Figure size.\n    cmap : str or Colormap, optional\n        Colormap to use (supports colorblind-friendly options).\n    vmin, vmax : float, optional\n        Color limits.\n    norm : Normalize, optional\n        Matplotlib normalization (e.g., LogNorm).\n    dpi : int, optional\n        Dots per inch for export.\n    xlabel, ylabel, title : str, optional\n        Axis labels and plot title.\n    cbar_label : str, optional\n        Label for the colorbar.\n    cbar_inset : bool, default: False\n        Place colorbar as an inset (right) if True.\n    xticks, yticks : list, optional\n        Custom tick locations.\n    annotations : list of dict, optional\n        List of annotation dicts (e.g., {\"text\": \"A\", \"xy\": (lon, lat)}).\n    export_path : str, optional\n        Path to export the figure (without extension).\n    export_formats : list, optional\n        List of formats to export (e.g., [\"png\", \"pdf\"]).\n    **kwargs : dict\n        Additional keyword arguments for xarray's plot method.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The matplotlib figure object.\n    ax : matplotlib.axes.Axes\n        The matplotlib axes object.\n    \"\"\"\n    # Setup\n    projection = _setup_map_projection(projection)\n    map_kws = map_kws or {}\n    fig, ax = plt.subplots(\n        subplot_kw={\"projection\": projection}, figsize=figsize, dpi=dpi\n    )\n\n    # Prepare plot arguments\n    plot_args = dict(cmap=cmap, vmin=vmin, vmax=vmax, norm=norm)\n    plot_args.update({k: v for k, v in kwargs.items() if k not in [\"ax\", \"transform\"]})\n\n    # Create the plot\n    mesh = da.plot(ax=ax, transform=ccrs.PlateCarree(), **plot_args)\n\n    # Add map features\n    _add_map_features(ax, map_kws)\n\n    # Set labels and title\n    _set_axis_labels_and_title(ax, xlabel, ylabel, title)\n\n    # Set custom ticks\n    _set_custom_ticks(ax, xticks, yticks)\n\n    # Add annotations\n    _add_annotations(ax, annotations)\n\n    # Add colorbar\n    _add_colorbar(fig, ax, mesh, colorbar, cbar_label, cbar_inset)\n\n    # Finalize\n    fig.tight_layout()\n    _export_figure(fig, export_path, export_formats, dpi)\n\n    return fig, ax\n</code></pre>"},{"location":"api/#monet_plots.colorbars.cmap_discretize","title":"<code>cmap_discretize(cmap, N)</code>","text":"<p>Return a discrete colormap from a continuous colormap.</p> <p>Creates a new colormap by discretizing an existing continuous colormap into N distinct colors while preserving the color transitions.</p>"},{"location":"api/#monet_plots.colorbars.cmap_discretize--parameters","title":"Parameters","text":"<p>cmap : str or matplotlib.colors.Colormap     Colormap instance or registered colormap name to discretize.     Example: cm.jet, 'viridis', etc. N : int     Number of discrete colors to use in the new colormap.</p>"},{"location":"api/#monet_plots.colorbars.cmap_discretize--returns","title":"Returns","text":"<p>matplotlib.colors.LinearSegmentedColormap     A new colormap object with N discrete colors based on the input colormap.     The name will be the original colormap name with \"_N\" appended.</p> Source code in <code>src/monet_plots/colorbars.py</code> <pre><code>def cmap_discretize(cmap, N):\n    \"\"\"Return a discrete colormap from a continuous colormap.\n\n    Creates a new colormap by discretizing an existing continuous colormap\n    into N distinct colors while preserving the color transitions.\n\n    Parameters\n    ----------\n    cmap : str or matplotlib.colors.Colormap\n        Colormap instance or registered colormap name to discretize.\n        Example: cm.jet, 'viridis', etc.\n    N : int\n        Number of discrete colors to use in the new colormap.\n\n    Returns\n    -------\n    matplotlib.colors.LinearSegmentedColormap\n        A new colormap object with N discrete colors based on the input colormap.\n        The name will be the original colormap name with \"_N\" appended.\n    \"\"\"\n    if isinstance(cmap, str):\n        cmap = plt.get_cmap(cmap)\n    colors_i = np.concatenate((np.linspace(0, 1.0, N), (0.0, 0.0, 0.0, 0.0)))\n    colors_rgba = cmap(colors_i)\n    indices = np.linspace(0, 1.0, N + 1)\n    cdict = {}\n    for ki, key in enumerate((\"red\", \"green\", \"blue\")):\n        cdict[key] = [\n            (indices[i], colors_rgba[i - 1, ki], colors_rgba[i, ki])\n            for i in range(N + 1)\n        ]\n    # Return colormap object.\n    return mcolors.LinearSegmentedColormap(cmap.name + \"_%d\" % N, cdict, 1024)\n</code></pre>"},{"location":"api/#monet_plots.colorbars.colorbar_index","title":"<code>colorbar_index(ncolors, cmap, minval=None, maxval=None, dtype='int', basemap=None, ax=None, **kwargs)</code>","text":"<p>Create a colorbar with discrete colors and custom tick labels.</p>"},{"location":"api/#monet_plots.colorbars.colorbar_index--parameters","title":"Parameters","text":"<p>ncolors : int     Number of discrete colors to use in the colorbar. cmap : str or matplotlib.colors.Colormap     Colormap to discretize and use for the colorbar. minval : float, optional     Minimum value for the colorbar tick labels. If None and maxval is None,     tick labels will range from 0 to ncolors. If None and maxval is provided,     tick labels will range from 0 to maxval. maxval : float, optional     Maximum value for the colorbar tick labels. If None, tick labels     will range from 0 or minval to ncolors. dtype : str or type, default \"int\"     Data type for tick label values (e.g., \"int\", \"float\"). basemap : matplotlib.mpl_toolkits.basemap.Basemap, optional     Basemap instance to attach the colorbar to. If None, uses plt.colorbar. ax : matplotlib.axes.Axes, optional     Axes to attach the colorbar to. If None, uses plt.gca(). **kwargs : Any     Additional keyword arguments for plt.colorbar.</p>"},{"location":"api/#monet_plots.colorbars.colorbar_index--returns","title":"Returns","text":"<p>tuple     (colorbar, discretized_cmap) where:     - colorbar is the matplotlib.colorbar.Colorbar instance     - discretized_cmap is the discretized colormap</p> Source code in <code>src/monet_plots/colorbars.py</code> <pre><code>def colorbar_index(\n    ncolors,\n    cmap,\n    minval=None,\n    maxval=None,\n    dtype=\"int\",\n    basemap=None,\n    ax=None,\n    **kwargs,\n):\n    \"\"\"Create a colorbar with discrete colors and custom tick labels.\n\n    Parameters\n    ----------\n    ncolors : int\n        Number of discrete colors to use in the colorbar.\n    cmap : str or matplotlib.colors.Colormap\n        Colormap to discretize and use for the colorbar.\n    minval : float, optional\n        Minimum value for the colorbar tick labels. If None and maxval is None,\n        tick labels will range from 0 to ncolors. If None and maxval is provided,\n        tick labels will range from 0 to maxval.\n    maxval : float, optional\n        Maximum value for the colorbar tick labels. If None, tick labels\n        will range from 0 or minval to ncolors.\n    dtype : str or type, default \"int\"\n        Data type for tick label values (e.g., \"int\", \"float\").\n    basemap : matplotlib.mpl_toolkits.basemap.Basemap, optional\n        Basemap instance to attach the colorbar to. If None, uses plt.colorbar.\n    ax : matplotlib.axes.Axes, optional\n        Axes to attach the colorbar to. If None, uses plt.gca().\n    **kwargs : Any\n        Additional keyword arguments for plt.colorbar.\n\n    Returns\n    -------\n    tuple\n        (colorbar, discretized_cmap) where:\n        - colorbar is the matplotlib.colorbar.Colorbar instance\n        - discretized_cmap is the discretized colormap\n    \"\"\"\n    import matplotlib.cm as cm\n\n    cmap = cmap_discretize(cmap, ncolors)\n    mappable = cm.ScalarMappable(cmap=cmap)\n    mappable.set_array([])\n    mappable.set_clim(-0.5, ncolors + 0.5)\n\n    if basemap is not None:\n        colorbar = basemap.colorbar(mappable, format=\"%1.2g\")\n    elif ax is not None:\n        from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\n        # Use inset_axes to ensure the colorbar height matches the axes perfectly\n        # regardless of aspect ratio or projection.\n        cax = inset_axes(\n            ax,\n            width=\"5%\",\n            height=\"100%\",\n            loc=\"lower left\",\n            bbox_to_anchor=(1.05, 0.0, 1.0, 1.0),\n            bbox_transform=ax.transAxes,\n            borderpad=0,\n        )\n        cbar_kwargs = {\"format\": \"%1.2g\", \"cax\": cax}\n        cbar_kwargs.update(kwargs)\n        colorbar = plt.colorbar(mappable, **cbar_kwargs)\n    else:\n        # Fallback for case where no axes is provided\n        cbar_kwargs = {\"format\": \"%1.2g\", \"fraction\": 0.046, \"pad\": 0.04}\n        cbar_kwargs.update(kwargs)\n        colorbar = plt.colorbar(mappable, **cbar_kwargs)\n\n    colorbar.set_ticks(np.linspace(0, ncolors, ncolors))\n    if (minval is None) &amp; (maxval is not None):\n        colorbar.set_ticklabels(\n            np.around(np.linspace(0, maxval, ncolors).astype(dtype), 2)\n        )\n    elif (minval is None) &amp; (maxval is None):\n        colorbar.set_ticklabels(\n            np.around(np.linspace(0, ncolors, ncolors).astype(dtype), 2)\n        )\n    else:\n        colorbar.set_ticklabels(\n            np.around(np.linspace(minval, maxval, ncolors).astype(dtype), 2)\n        )\n\n    return colorbar, cmap\n</code></pre>"},{"location":"api/#monet_plots.colorbars.get_discrete_scale","title":"<code>get_discrete_scale(data, cmap='viridis', n_levels=10, vmin=None, vmax=None, extend='both')</code>","text":"<p>Get a discrete colormap and BoundaryNorm with 'nice' numbers.</p>"},{"location":"api/#monet_plots.colorbars.get_discrete_scale--parameters","title":"Parameters","text":"<p>data : array-like     The data to scale. cmap : str or matplotlib.colors.Colormap, optional     The colormap to use, by default \"viridis\". n_levels : int, optional     Target number of discrete levels, by default 10. vmin : float, optional     Minimum value for the scale. vmax : float, optional     Maximum value for the scale. extend : str, optional     Whether to extend the scale ('neither', 'both', 'min', 'max'),     by default \"both\".</p>"},{"location":"api/#monet_plots.colorbars.get_discrete_scale--returns","title":"Returns","text":"<p>tuple     (colormap, BoundaryNorm)</p> Source code in <code>src/monet_plots/colorbars.py</code> <pre><code>def get_discrete_scale(\n    data, cmap=\"viridis\", n_levels=10, vmin=None, vmax=None, extend=\"both\"\n):\n    \"\"\"\n    Get a discrete colormap and BoundaryNorm with 'nice' numbers.\n\n    Parameters\n    ----------\n    data : array-like\n        The data to scale.\n    cmap : str or matplotlib.colors.Colormap, optional\n        The colormap to use, by default \"viridis\".\n    n_levels : int, optional\n        Target number of discrete levels, by default 10.\n    vmin : float, optional\n        Minimum value for the scale.\n    vmax : float, optional\n        Maximum value for the scale.\n    extend : str, optional\n        Whether to extend the scale ('neither', 'both', 'min', 'max'),\n        by default \"both\".\n\n    Returns\n    -------\n    tuple\n        (colormap, BoundaryNorm)\n    \"\"\"\n    if vmin is None:\n        vmin = np.nanmin(data)\n    if vmax is None:\n        vmax = np.nanmax(data)\n\n    locator = MaxNLocator(nbins=n_levels, steps=[1, 2, 2.5, 5, 10])\n    levels = locator.tick_values(vmin, vmax)\n\n    if isinstance(cmap, str):\n        cmap_obj = plt.get_cmap(cmap)\n    else:\n        cmap_obj = cmap\n\n    n_colors = len(levels) - 1\n    discrete_cmap = cmap_discretize(cmap_obj, n_colors)\n\n    norm = mcolors.BoundaryNorm(levels, ncolors=discrete_cmap.N, extend=extend)\n\n    return discrete_cmap, norm\n</code></pre>"},{"location":"api/#monet_plots.colorbars.get_diverging_scale","title":"<code>get_diverging_scale(data, cmap='RdBu_r', center=0, span=None, p_span=None)</code>","text":"<p>Get a diverging colormap and normalization object centered at a value.</p>"},{"location":"api/#monet_plots.colorbars.get_diverging_scale--parameters","title":"Parameters","text":"<p>data : array-like     The data to scale. cmap : str or matplotlib.colors.Colormap, optional     The colormap to use, by default \"RdBu_r\". center : float, optional     The value to center the scale at, by default 0. span : float, optional     The absolute range from the center (center +/- span). p_span : float, optional     The percentile of absolute differences from center to use as span.</p>"},{"location":"api/#monet_plots.colorbars.get_diverging_scale--returns","title":"Returns","text":"<p>tuple     (colormap, Normalize)</p> Source code in <code>src/monet_plots/colorbars.py</code> <pre><code>def get_diverging_scale(data, cmap=\"RdBu_r\", center=0, span=None, p_span=None):\n    \"\"\"\n    Get a diverging colormap and normalization object centered at a value.\n\n    Parameters\n    ----------\n    data : array-like\n        The data to scale.\n    cmap : str or matplotlib.colors.Colormap, optional\n        The colormap to use, by default \"RdBu_r\".\n    center : float, optional\n        The value to center the scale at, by default 0.\n    span : float, optional\n        The absolute range from the center (center +/- span).\n    p_span : float, optional\n        The percentile of absolute differences from center to use as span.\n\n    Returns\n    -------\n    tuple\n        (colormap, Normalize)\n    \"\"\"\n    if span is not None:\n        pass\n    elif p_span is not None:\n        diff = np.abs(data - center)\n        span = np.nanpercentile(diff, p_span)\n    else:\n        span = np.nanmax(np.abs(data - center))\n\n    vmin = center - span\n    vmax = center + span\n\n    norm = mcolors.Normalize(vmin=vmin, vmax=vmax)\n    if isinstance(cmap, str):\n        cmap = plt.get_cmap(cmap)\n\n    return cmap, norm\n</code></pre>"},{"location":"api/#monet_plots.colorbars.get_linear_scale","title":"<code>get_linear_scale(data, cmap='viridis', vmin=None, vmax=None, p_min=None, p_max=None)</code>","text":"<p>Get a linear colormap and normalization object.</p>"},{"location":"api/#monet_plots.colorbars.get_linear_scale--parameters","title":"Parameters","text":"<p>data : array-like     The data to scale. cmap : str or matplotlib.colors.Colormap, optional     The colormap to use, by default \"viridis\". vmin : float, optional     Minimum value for the scale. If None, uses min(data) or p_min. vmax : float, optional     Maximum value for the scale. If None, uses max(data) or p_max. p_min : float, optional     Percentile for minimum value (0-100). p_max : float, optional     Percentile for maximum value (0-100).</p>"},{"location":"api/#monet_plots.colorbars.get_linear_scale--returns","title":"Returns","text":"<p>tuple     (colormap, Normalize)</p> Source code in <code>src/monet_plots/colorbars.py</code> <pre><code>def get_linear_scale(\n    data, cmap=\"viridis\", vmin=None, vmax=None, p_min=None, p_max=None\n):\n    \"\"\"\n    Get a linear colormap and normalization object.\n\n    Parameters\n    ----------\n    data : array-like\n        The data to scale.\n    cmap : str or matplotlib.colors.Colormap, optional\n        The colormap to use, by default \"viridis\".\n    vmin : float, optional\n        Minimum value for the scale. If None, uses min(data) or p_min.\n    vmax : float, optional\n        Maximum value for the scale. If None, uses max(data) or p_max.\n    p_min : float, optional\n        Percentile for minimum value (0-100).\n    p_max : float, optional\n        Percentile for maximum value (0-100).\n\n    Returns\n    -------\n    tuple\n        (colormap, Normalize)\n    \"\"\"\n    if p_min is not None:\n        vmin = np.nanpercentile(data, p_min)\n    if p_max is not None:\n        vmax = np.nanpercentile(data, p_max)\n\n    if vmin is None:\n        vmin = np.nanmin(data)\n    if vmax is None:\n        vmax = np.nanmax(data)\n\n    norm = mcolors.Normalize(vmin=vmin, vmax=vmax)\n    if isinstance(cmap, str):\n        cmap = plt.get_cmap(cmap)\n\n    return cmap, norm\n</code></pre>"},{"location":"api/#monet_plots.colorbars.get_log_scale","title":"<code>get_log_scale(data, cmap='viridis', vmin=None, vmax=None)</code>","text":"<p>Get a logarithmic colormap and normalization object.</p>"},{"location":"api/#monet_plots.colorbars.get_log_scale--parameters","title":"Parameters","text":"<p>data : array-like     The data to scale. cmap : str or matplotlib.colors.Colormap, optional     The colormap to use, by default \"viridis\". vmin : float, optional     Minimum value for the scale (&gt;0). vmax : float, optional     Maximum value for the scale.</p>"},{"location":"api/#monet_plots.colorbars.get_log_scale--returns","title":"Returns","text":"<p>tuple     (colormap, LogNorm)</p> Source code in <code>src/monet_plots/colorbars.py</code> <pre><code>def get_log_scale(data, cmap=\"viridis\", vmin=None, vmax=None):\n    \"\"\"\n    Get a logarithmic colormap and normalization object.\n\n    Parameters\n    ----------\n    data : array-like\n        The data to scale.\n    cmap : str or matplotlib.colors.Colormap, optional\n        The colormap to use, by default \"viridis\".\n    vmin : float, optional\n        Minimum value for the scale (&gt;0).\n    vmax : float, optional\n        Maximum value for the scale.\n\n    Returns\n    -------\n    tuple\n        (colormap, LogNorm)\n    \"\"\"\n    data_positive = data[data &gt; 0]\n    if vmin is None:\n        vmin = np.nanmin(data_positive) if data_positive.size &gt; 0 else 1e-1\n    if vmax is None:\n        vmax = np.nanmax(data)\n\n    norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)\n    if isinstance(cmap, str):\n        cmap = plt.get_cmap(cmap)\n\n    return cmap, norm\n</code></pre>"},{"location":"api/#monet_plots.plot_utils.get_logo_path","title":"<code>get_logo_path(name='monet_plots.png')</code>","text":"<p>Get the path to a bundled logo asset.</p>"},{"location":"api/#monet_plots.plot_utils.get_logo_path--parameters","title":"Parameters","text":"<p>name : str, optional     The name of the logo file, by default \"monet_plots.png\".</p>"},{"location":"api/#monet_plots.plot_utils.get_logo_path--returns","title":"Returns","text":"<p>str     The full path to the logo file.</p> Source code in <code>src/monet_plots/plot_utils.py</code> <pre><code>def get_logo_path(name: str = \"monet_plots.png\") -&gt; str:\n    \"\"\"\n    Get the path to a bundled logo asset.\n\n    Parameters\n    ----------\n    name : str, optional\n        The name of the logo file, by default \"monet_plots.png\".\n\n    Returns\n    -------\n    str\n        The full path to the logo file.\n    \"\"\"\n    import os\n\n    return os.path.join(os.path.dirname(__file__), \"assets\", name)\n</code></pre>"},{"location":"api/#monet_plots.plot_utils.get_plot_kwargs","title":"<code>get_plot_kwargs(cmap=None, norm=None, **kwargs)</code>","text":"<p>Helper to prepare keyword arguments for plotting functions.</p> <p>This function handles cases where <code>cmap</code> might be a tuple of (colormap, norm) returned by the scaling tools in <code>colorbars.py</code>.</p>"},{"location":"api/#monet_plots.plot_utils.get_plot_kwargs--parameters","title":"Parameters","text":"<p>cmap : Any, optional     Colormap name, object, or (colormap, norm) tuple. norm : Any, optional     Normalization object. **kwargs : Any     Additional keyword arguments.</p>"},{"location":"api/#monet_plots.plot_utils.get_plot_kwargs--returns","title":"Returns","text":"<p>dict     A dictionary of keyword arguments suitable for matplotlib plotting functions.</p> Source code in <code>src/monet_plots/plot_utils.py</code> <pre><code>def get_plot_kwargs(cmap: Any = None, norm: Any = None, **kwargs: Any) -&gt; dict:\n    \"\"\"\n    Helper to prepare keyword arguments for plotting functions.\n\n    This function handles cases where `cmap` might be a tuple of\n    (colormap, norm) returned by the scaling tools in `colorbars.py`.\n\n    Parameters\n    ----------\n    cmap : Any, optional\n        Colormap name, object, or (colormap, norm) tuple.\n    norm : Any, optional\n        Normalization object.\n    **kwargs : Any\n        Additional keyword arguments.\n\n    Returns\n    -------\n    dict\n        A dictionary of keyword arguments suitable for matplotlib plotting functions.\n    \"\"\"\n    if isinstance(cmap, tuple) and len(cmap) == 2:\n        kwargs[\"cmap\"] = cmap[0]\n        kwargs[\"norm\"] = cmap[1]\n    elif cmap is not None:\n        kwargs[\"cmap\"] = cmap\n\n    if norm is not None:\n        kwargs[\"norm\"] = norm\n\n    return kwargs\n</code></pre>"},{"location":"api/#monet_plots.plot_utils.normalize_data","title":"<code>normalize_data(data)</code>","text":"<p>Public API for normalizing data, preferring xarray objects when possible.</p> <p>This is the same as _normalize_data but exposed as a public API.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data of various types</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Either an xarray DataArray, xarray Dataset, or pandas DataFrame</p> Source code in <code>src/monet_plots/plot_utils.py</code> <pre><code>def normalize_data(data: Any) -&gt; Any:\n    \"\"\"\n    Public API for normalizing data, preferring xarray objects when possible.\n\n    This is the same as _normalize_data but exposed as a public API.\n\n    Args:\n        data: Input data of various types\n\n    Returns:\n        Either an xarray DataArray, xarray Dataset, or pandas DataFrame\n    \"\"\"\n    return _normalize_data(data)\n</code></pre>"},{"location":"api/#monet_plots.plot_utils.to_dataframe","title":"<code>to_dataframe(data)</code>","text":"<p>Convert input data to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data. Can be a pandas DataFrame, xarray DataArray,   xarray Dataset, or numpy ndarray.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas DataFrame.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input data type is not supported.</p> Source code in <code>src/monet_plots/plot_utils.py</code> <pre><code>def to_dataframe(data: Any) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert input data to a pandas DataFrame.\n\n    Args:\n        data: Input data. Can be a pandas DataFrame, xarray DataArray,\n              xarray Dataset, or numpy ndarray.\n\n    Returns:\n        A pandas DataFrame.\n\n    Raises:\n        TypeError: If the input data type is not supported.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        return data\n\n    # Using hasattr to avoid direct dependency on xarray for users who don't have it\n    # installed.\n    if hasattr(data, \"to_dataframe\"):  # Works for both xarray DataArray and Dataset\n        return data.to_dataframe()\n\n    if isinstance(data, np.ndarray):\n        if data.ndim == 1:\n            return pd.DataFrame(data, columns=[\"col_0\"])\n        elif data.ndim == 2:\n            return pd.DataFrame(\n                data, columns=[f\"col_{i}\" for i in range(data.shape[1])]\n            )\n        else:\n            raise ValueError(f\"numpy array with {data.ndim} dimensions not supported\")\n\n    raise TypeError(f\"Unsupported data type: {type(data).__name__}\")\n</code></pre>"},{"location":"api/#monet_plots.plot_utils.validate_data_array","title":"<code>validate_data_array(data, required_dims=None)</code>","text":"<p>Validate data array parameters.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to validate</p> required <code>required_dims</code> <code>Optional[list]</code> <p>List of required dimension names</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If data type is invalid</p> <code>ValueError</code> <p>If data dimensions are invalid</p> Source code in <code>src/monet_plots/plot_utils.py</code> <pre><code>def validate_data_array(data: Any, required_dims: Optional[list] = None) -&gt; None:\n    \"\"\"\n    Validate data array parameters.\n\n    Args:\n        data: Data to validate\n        required_dims: List of required dimension names\n\n    Raises:\n        TypeError: If data type is invalid\n        ValueError: If data dimensions are invalid\n    \"\"\"\n    if data is None:\n        raise ValueError(\"data cannot be None\")\n\n    # Check if data has required attributes\n    if not hasattr(data, \"shape\"):\n        raise TypeError(\"data must have a shape attribute\")\n\n    if required_dims:\n        if not hasattr(data, \"dims\"):\n            raise TypeError(\"data must have dims attribute for dimension validation\")\n\n        for dim in required_dims:\n            if dim not in data.dims:\n                raise ValueError(\n                    f\"required dimension '{dim}' not found in data dimensions {data.dims}\"\n                )\n</code></pre>"},{"location":"api/#monet_plots.plot_utils.validate_dataframe","title":"<code>validate_dataframe(df, required_columns=None)</code>","text":"<p>Validate DataFrame parameters.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>Any</code> <p>DataFrame to validate</p> required <code>required_columns</code> <code>Optional[list]</code> <p>List of required column names</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If DataFrame type is invalid</p> <code>ValueError</code> <p>If DataFrame structure is invalid</p> Source code in <code>src/monet_plots/plot_utils.py</code> <pre><code>def validate_dataframe(df: Any, required_columns: Optional[list] = None) -&gt; None:\n    \"\"\"\n    Validate DataFrame parameters.\n\n    Args:\n        df: DataFrame to validate\n        required_columns: List of required column names\n\n    Raises:\n        TypeError: If DataFrame type is invalid\n        ValueError: If DataFrame structure is invalid\n    \"\"\"\n    if df is None:\n        raise ValueError(\"DataFrame cannot be None\")\n\n    if not hasattr(df, \"columns\"):\n        raise TypeError(\"object must have columns attribute\")\n\n    if required_columns:\n        missing_columns = [col for col in required_columns if col not in df.columns]\n        if missing_columns:\n            raise ValueError(f\"missing required columns: {missing_columns}\")\n\n    if len(df) == 0:\n        raise ValueError(\"DataFrame cannot be empty\")\n</code></pre>"},{"location":"api/#monet_plots.plot_utils.validate_plot_parameters","title":"<code>validate_plot_parameters(plot_class, method, **kwargs)</code>","text":"<p>Validate parameters for plot methods.</p> <p>Parameters:</p> Name Type Description Default <code>plot_class</code> <code>str</code> <p>The plot class name</p> required <code>method</code> <code>str</code> <p>The method name</p> required <code>**kwargs</code> <p>Parameters to validate</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If parameter types are invalid</p> <code>ValueError</code> <p>If parameter values are invalid</p> Source code in <code>src/monet_plots/plot_utils.py</code> <pre><code>def validate_plot_parameters(plot_class: str, method: str, **kwargs) -&gt; None:\n    \"\"\"\n    Validate parameters for plot methods.\n\n    Args:\n        plot_class: The plot class name\n        method: The method name\n        **kwargs: Parameters to validate\n\n    Raises:\n        TypeError: If parameter types are invalid\n        ValueError: If parameter values are invalid\n    \"\"\"\n    if plot_class == \"SpatialPlot\" and method == \"plot\":\n        _validate_spatial_plot_params(kwargs)\n    elif plot_class == \"TimeSeriesPlot\" and method == \"plot\":\n        _validate_timeseries_plot_params(kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.BasePlot","title":"<code>BasePlot</code>","text":"<p>Base class for all plots.</p> <p>Handles figure and axis creation, applies a consistent style, and provides a common interface for saving and closing plots.</p> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>class BasePlot:\n    \"\"\"Base class for all plots.\n\n    Handles figure and axis creation, applies a consistent style,\n    and provides a common interface for saving and closing plots.\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, style: str | None = \"wiley\", **kwargs):\n        \"\"\"Initializes the plot with a consistent style.\n\n        If `fig` and `ax` are not provided, a new figure and axes\n        are created.\n\n        Args:\n            fig (matplotlib.figure.Figure, optional): Figure to plot on.\n            ax (matplotlib.axes.Axes, optional): Axes to plot on.\n            style (str, optional): Style name to apply (e.g., 'wiley', 'paper').\n                If None, no style is applied. Defaults to 'wiley'.\n            **kwargs: Additional keyword arguments for `plt.subplots`.\n        \"\"\"\n        if style:\n            set_style(style)\n\n        if ax is not None:\n            self.ax = ax\n            if fig is not None:\n                self.fig = fig\n            else:\n                self.fig = ax.figure\n        elif fig is not None:\n            self.fig = fig\n            self.ax = None\n        else:\n            self.fig, self.ax = plt.subplots(**kwargs)\n\n    def save(self, filename, **kwargs):\n        \"\"\"Saves the plot to a file.\n\n        Args:\n            filename (str): The name of the file to save the plot to.\n            **kwargs: Additional keyword arguments for `savefig`.\n        \"\"\"\n        self.fig.savefig(filename, **kwargs)\n\n    def close(self):\n        \"\"\"Closes the plot figure.\"\"\"\n        plt.close(self.fig)\n\n    def add_logo(\n        self,\n        logo: str | Any | None = None,\n        *,\n        ax: matplotlib.axes.Axes | None = None,\n        loc: str = \"upper right\",\n        scale: float = 0.1,\n        pad: float = 0.05,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Adds a logo to the plot.\n\n        Parameters\n        ----------\n        logo : str or array-like, optional\n            Path to the logo image, a URL, or a numpy array.\n            If None, the default MONET logo is used.\n        ax : matplotlib.axes.Axes, optional\n            The axes to add the logo to. Defaults to `self.ax`.\n        loc : str, optional\n            Location of the logo ('upper right', 'upper left', 'lower right',\n            'lower left', 'center'). Defaults to \"upper right\".\n        scale : float, optional\n            Scaling factor for the logo, by default 0.1.\n        pad : float, optional\n            Padding from the edge of the axes, by default 0.05.\n        **kwargs : Any\n            Additional keyword arguments passed to `AnnotationBbox`.\n\n        Returns\n        -------\n        matplotlib.offsetbox.AnnotationBbox\n            The added logo object.\n        \"\"\"\n        import matplotlib.image as mpimg\n        from matplotlib.offsetbox import OffsetImage, AnnotationBbox\n        from ..plot_utils import get_logo_path\n\n        if ax is None:\n            ax = self.ax\n\n        if logo is None:\n            logo = get_logo_path()\n\n        if isinstance(logo, str):\n            if logo.startswith(\"http\"):\n                import urllib.request\n                import io\n\n                with urllib.request.urlopen(logo) as url:\n                    f = io.BytesIO(url.read())\n                img = mpimg.imread(f)\n            else:\n                img = mpimg.imread(logo)\n        else:\n            img = logo\n\n        imagebox = OffsetImage(img, zoom=scale)\n        imagebox.image.axes = ax\n\n        # Mapping of location strings to axes fraction coordinates and box alignment\n        loc_map = {\n            \"upper right\": ((1 - pad, 1 - pad), (1, 1)),\n            \"upper left\": ((pad, 1 - pad), (0, 1)),\n            \"lower right\": ((1 - pad, pad), (1, 0)),\n            \"lower left\": ((pad, pad), (0, 0)),\n            \"center\": ((0.5, 0.5), (0.5, 0.5)),\n        }\n\n        if loc in loc_map:\n            xy, box_alignment = loc_map[loc]\n        else:\n            # If loc is not a string in loc_map, assume it might be a coordinate\n            # tuple, but for simplicity we default to upper right if it's invalid\n            if isinstance(loc, tuple) and len(loc) == 2:\n                xy = loc\n                box_alignment = (0.5, 0.5)\n            else:\n                xy, box_alignment = loc_map[\"upper right\"]\n\n        ab = AnnotationBbox(\n            imagebox,\n            xy,\n            xycoords=\"axes fraction\",\n            box_alignment=box_alignment,\n            pad=0,\n            frameon=False,\n            **kwargs,\n        )\n\n        ax.add_artist(ab)\n        return ab\n\n    def add_colorbar(\n        self,\n        mappable: matplotlib.cm.ScalarMappable,\n        *,\n        ax: matplotlib.axes.Axes | None = None,\n        label: str | None = None,\n        loc: str = \"right\",\n        size: str = \"5%\",\n        pad: float = 0.05,\n        **kwargs: Any,\n    ) -&gt; matplotlib.colorbar.Colorbar:\n        \"\"\"Add a colorbar that matches the axes size.\n\n        This method uses `inset_axes` to ensure the colorbar height (or width)\n        matches the axes dimensions exactly, which is particularly useful for\n        geospatial plots with fixed aspects.\n\n        Parameters\n        ----------\n        mappable : matplotlib.cm.ScalarMappable\n            The mappable object (e.g., from imshow, scatter, contourf).\n        ax : matplotlib.axes.Axes, optional\n            The axes to attach the colorbar to. Defaults to `self.ax`.\n        label : str, optional\n            Label for the colorbar, by default None.\n        loc : str, optional\n            Location of the colorbar ('right', 'left', 'top', 'bottom'),\n            by default \"right\".\n        size : str, optional\n            Width (if vertical) or height (if horizontal) of the colorbar,\n            as a percentage of the axes, by default \"5%\".\n        pad : float, optional\n            Padding between the axes and the colorbar, by default 0.05.\n        **kwargs : Any\n            Additional keyword arguments passed to `fig.colorbar`.\n\n        Returns\n        -------\n        matplotlib.colorbar.Colorbar\n            The created colorbar object.\n        \"\"\"\n        from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\n        if ax is None:\n            ax = self.ax\n\n        orientation = \"vertical\" if loc in [\"right\", \"left\"] else \"horizontal\"\n\n        # Determine anchor and position based on location\n        if loc == \"right\":\n            bbox_to_anchor = (1.0 + pad, 0.0, 1.0, 1.0)\n            width, height = size, \"100%\"\n        elif loc == \"left\":\n            bbox_to_anchor = (-(float(size.strip(\"%\")) / 100.0 + pad), 0.0, 1.0, 1.0)\n            width, height = size, \"100%\"\n        elif loc == \"top\":\n            bbox_to_anchor = (0.0, 1.0 + pad, 1.0, 1.0)\n            width, height = \"100%\", size\n        else:  # bottom\n            bbox_to_anchor = (0.0, -(float(size.strip(\"%\")) / 100.0 + pad), 1.0, 1.0)\n            width, height = \"100%\", size\n\n        cax = inset_axes(\n            ax,\n            width=width,\n            height=height,\n            loc=\"lower left\",\n            bbox_to_anchor=bbox_to_anchor,\n            bbox_transform=ax.transAxes,\n            borderpad=0,\n        )\n\n        cb = self.fig.colorbar(mappable, cax=cax, orientation=orientation, **kwargs)\n\n        if label:\n            cb.set_label(label)\n\n        return cb\n</code></pre>"},{"location":"api/#monet_plots.plots.BasePlot.__init__","title":"<code>__init__(fig=None, ax=None, style='wiley', **kwargs)</code>","text":"<p>Initializes the plot with a consistent style.</p> <p>If <code>fig</code> and <code>ax</code> are not provided, a new figure and axes are created.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figure to plot on.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes to plot on.</p> <code>None</code> <code>style</code> <code>str</code> <p>Style name to apply (e.g., 'wiley', 'paper'). If None, no style is applied. Defaults to 'wiley'.</p> <code>'wiley'</code> <code>**kwargs</code> <p>Additional keyword arguments for <code>plt.subplots</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def __init__(self, fig=None, ax=None, style: str | None = \"wiley\", **kwargs):\n    \"\"\"Initializes the plot with a consistent style.\n\n    If `fig` and `ax` are not provided, a new figure and axes\n    are created.\n\n    Args:\n        fig (matplotlib.figure.Figure, optional): Figure to plot on.\n        ax (matplotlib.axes.Axes, optional): Axes to plot on.\n        style (str, optional): Style name to apply (e.g., 'wiley', 'paper').\n            If None, no style is applied. Defaults to 'wiley'.\n        **kwargs: Additional keyword arguments for `plt.subplots`.\n    \"\"\"\n    if style:\n        set_style(style)\n\n    if ax is not None:\n        self.ax = ax\n        if fig is not None:\n            self.fig = fig\n        else:\n            self.fig = ax.figure\n    elif fig is not None:\n        self.fig = fig\n        self.ax = None\n    else:\n        self.fig, self.ax = plt.subplots(**kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.BasePlot.add_colorbar","title":"<code>add_colorbar(mappable, *, ax=None, label=None, loc='right', size='5%', pad=0.05, **kwargs)</code>","text":"<p>Add a colorbar that matches the axes size.</p> <p>This method uses <code>inset_axes</code> to ensure the colorbar height (or width) matches the axes dimensions exactly, which is particularly useful for geospatial plots with fixed aspects.</p>"},{"location":"api/#monet_plots.plots.BasePlot.add_colorbar--parameters","title":"Parameters","text":"<p>mappable : matplotlib.cm.ScalarMappable     The mappable object (e.g., from imshow, scatter, contourf). ax : matplotlib.axes.Axes, optional     The axes to attach the colorbar to. Defaults to <code>self.ax</code>. label : str, optional     Label for the colorbar, by default None. loc : str, optional     Location of the colorbar ('right', 'left', 'top', 'bottom'),     by default \"right\". size : str, optional     Width (if vertical) or height (if horizontal) of the colorbar,     as a percentage of the axes, by default \"5%\". pad : float, optional     Padding between the axes and the colorbar, by default 0.05. **kwargs : Any     Additional keyword arguments passed to <code>fig.colorbar</code>.</p>"},{"location":"api/#monet_plots.plots.BasePlot.add_colorbar--returns","title":"Returns","text":"<p>matplotlib.colorbar.Colorbar     The created colorbar object.</p> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def add_colorbar(\n    self,\n    mappable: matplotlib.cm.ScalarMappable,\n    *,\n    ax: matplotlib.axes.Axes | None = None,\n    label: str | None = None,\n    loc: str = \"right\",\n    size: str = \"5%\",\n    pad: float = 0.05,\n    **kwargs: Any,\n) -&gt; matplotlib.colorbar.Colorbar:\n    \"\"\"Add a colorbar that matches the axes size.\n\n    This method uses `inset_axes` to ensure the colorbar height (or width)\n    matches the axes dimensions exactly, which is particularly useful for\n    geospatial plots with fixed aspects.\n\n    Parameters\n    ----------\n    mappable : matplotlib.cm.ScalarMappable\n        The mappable object (e.g., from imshow, scatter, contourf).\n    ax : matplotlib.axes.Axes, optional\n        The axes to attach the colorbar to. Defaults to `self.ax`.\n    label : str, optional\n        Label for the colorbar, by default None.\n    loc : str, optional\n        Location of the colorbar ('right', 'left', 'top', 'bottom'),\n        by default \"right\".\n    size : str, optional\n        Width (if vertical) or height (if horizontal) of the colorbar,\n        as a percentage of the axes, by default \"5%\".\n    pad : float, optional\n        Padding between the axes and the colorbar, by default 0.05.\n    **kwargs : Any\n        Additional keyword arguments passed to `fig.colorbar`.\n\n    Returns\n    -------\n    matplotlib.colorbar.Colorbar\n        The created colorbar object.\n    \"\"\"\n    from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\n    if ax is None:\n        ax = self.ax\n\n    orientation = \"vertical\" if loc in [\"right\", \"left\"] else \"horizontal\"\n\n    # Determine anchor and position based on location\n    if loc == \"right\":\n        bbox_to_anchor = (1.0 + pad, 0.0, 1.0, 1.0)\n        width, height = size, \"100%\"\n    elif loc == \"left\":\n        bbox_to_anchor = (-(float(size.strip(\"%\")) / 100.0 + pad), 0.0, 1.0, 1.0)\n        width, height = size, \"100%\"\n    elif loc == \"top\":\n        bbox_to_anchor = (0.0, 1.0 + pad, 1.0, 1.0)\n        width, height = \"100%\", size\n    else:  # bottom\n        bbox_to_anchor = (0.0, -(float(size.strip(\"%\")) / 100.0 + pad), 1.0, 1.0)\n        width, height = \"100%\", size\n\n    cax = inset_axes(\n        ax,\n        width=width,\n        height=height,\n        loc=\"lower left\",\n        bbox_to_anchor=bbox_to_anchor,\n        bbox_transform=ax.transAxes,\n        borderpad=0,\n    )\n\n    cb = self.fig.colorbar(mappable, cax=cax, orientation=orientation, **kwargs)\n\n    if label:\n        cb.set_label(label)\n\n    return cb\n</code></pre>"},{"location":"api/#monet_plots.plots.BasePlot.add_logo","title":"<code>add_logo(logo=None, *, ax=None, loc='upper right', scale=0.1, pad=0.05, **kwargs)</code>","text":"<p>Adds a logo to the plot.</p>"},{"location":"api/#monet_plots.plots.BasePlot.add_logo--parameters","title":"Parameters","text":"<p>logo : str or array-like, optional     Path to the logo image, a URL, or a numpy array.     If None, the default MONET logo is used. ax : matplotlib.axes.Axes, optional     The axes to add the logo to. Defaults to <code>self.ax</code>. loc : str, optional     Location of the logo ('upper right', 'upper left', 'lower right',     'lower left', 'center'). Defaults to \"upper right\". scale : float, optional     Scaling factor for the logo, by default 0.1. pad : float, optional     Padding from the edge of the axes, by default 0.05. **kwargs : Any     Additional keyword arguments passed to <code>AnnotationBbox</code>.</p>"},{"location":"api/#monet_plots.plots.BasePlot.add_logo--returns","title":"Returns","text":"<p>matplotlib.offsetbox.AnnotationBbox     The added logo object.</p> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def add_logo(\n    self,\n    logo: str | Any | None = None,\n    *,\n    ax: matplotlib.axes.Axes | None = None,\n    loc: str = \"upper right\",\n    scale: float = 0.1,\n    pad: float = 0.05,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Adds a logo to the plot.\n\n    Parameters\n    ----------\n    logo : str or array-like, optional\n        Path to the logo image, a URL, or a numpy array.\n        If None, the default MONET logo is used.\n    ax : matplotlib.axes.Axes, optional\n        The axes to add the logo to. Defaults to `self.ax`.\n    loc : str, optional\n        Location of the logo ('upper right', 'upper left', 'lower right',\n        'lower left', 'center'). Defaults to \"upper right\".\n    scale : float, optional\n        Scaling factor for the logo, by default 0.1.\n    pad : float, optional\n        Padding from the edge of the axes, by default 0.05.\n    **kwargs : Any\n        Additional keyword arguments passed to `AnnotationBbox`.\n\n    Returns\n    -------\n    matplotlib.offsetbox.AnnotationBbox\n        The added logo object.\n    \"\"\"\n    import matplotlib.image as mpimg\n    from matplotlib.offsetbox import OffsetImage, AnnotationBbox\n    from ..plot_utils import get_logo_path\n\n    if ax is None:\n        ax = self.ax\n\n    if logo is None:\n        logo = get_logo_path()\n\n    if isinstance(logo, str):\n        if logo.startswith(\"http\"):\n            import urllib.request\n            import io\n\n            with urllib.request.urlopen(logo) as url:\n                f = io.BytesIO(url.read())\n            img = mpimg.imread(f)\n        else:\n            img = mpimg.imread(logo)\n    else:\n        img = logo\n\n    imagebox = OffsetImage(img, zoom=scale)\n    imagebox.image.axes = ax\n\n    # Mapping of location strings to axes fraction coordinates and box alignment\n    loc_map = {\n        \"upper right\": ((1 - pad, 1 - pad), (1, 1)),\n        \"upper left\": ((pad, 1 - pad), (0, 1)),\n        \"lower right\": ((1 - pad, pad), (1, 0)),\n        \"lower left\": ((pad, pad), (0, 0)),\n        \"center\": ((0.5, 0.5), (0.5, 0.5)),\n    }\n\n    if loc in loc_map:\n        xy, box_alignment = loc_map[loc]\n    else:\n        # If loc is not a string in loc_map, assume it might be a coordinate\n        # tuple, but for simplicity we default to upper right if it's invalid\n        if isinstance(loc, tuple) and len(loc) == 2:\n            xy = loc\n            box_alignment = (0.5, 0.5)\n        else:\n            xy, box_alignment = loc_map[\"upper right\"]\n\n    ab = AnnotationBbox(\n        imagebox,\n        xy,\n        xycoords=\"axes fraction\",\n        box_alignment=box_alignment,\n        pad=0,\n        frameon=False,\n        **kwargs,\n    )\n\n    ax.add_artist(ab)\n    return ab\n</code></pre>"},{"location":"api/#monet_plots.plots.BasePlot.close","title":"<code>close()</code>","text":"<p>Closes the plot figure.</p> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def close(self):\n    \"\"\"Closes the plot figure.\"\"\"\n    plt.close(self.fig)\n</code></pre>"},{"location":"api/#monet_plots.plots.BasePlot.save","title":"<code>save(filename, **kwargs)</code>","text":"<p>Saves the plot to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save the plot to.</p> required <code>**kwargs</code> <p>Additional keyword arguments for <code>savefig</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def save(self, filename, **kwargs):\n    \"\"\"Saves the plot to a file.\n\n    Args:\n        filename (str): The name of the file to save the plot to.\n        **kwargs: Additional keyword arguments for `savefig`.\n    \"\"\"\n    self.fig.savefig(filename, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.BivariatePolarPlot","title":"<code>BivariatePolarPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Bivariate polar plot.</p> <p>Shows how a variable varies with wind speed and wind direction. Uses polar coordinates where the angle represents wind direction and the radius represents wind speed.</p> Source code in <code>src/monet_plots/plots/polar.py</code> <pre><code>class BivariatePolarPlot(BasePlot):\n    \"\"\"Bivariate polar plot.\n\n    Shows how a variable varies with wind speed and wind direction.\n    Uses polar coordinates where the angle represents wind direction\n    and the radius represents wind speed.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        ws_col: str,\n        wd_col: str,\n        val_col: str,\n        *,\n        ws_max: Optional[float] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize Bivariate Polar Plot.\n\n        Args:\n            data: Input data (DataFrame, DataArray, etc.).\n            ws_col: Column name for wind speed.\n            wd_col: Column name for wind direction (degrees).\n            val_col: Column name for the value to plot.\n            ws_max: Maximum wind speed to show.\n            **kwargs: Arguments passed to BasePlot. Note: 'subplot_kw={\"projection\": \"polar\"}'\n                      is added automatically if not provided.\n        \"\"\"\n        if \"subplot_kw\" not in kwargs:\n            kwargs[\"subplot_kw\"] = {\"projection\": \"polar\"}\n        elif \"projection\" not in kwargs[\"subplot_kw\"]:\n            kwargs[\"subplot_kw\"][\"projection\"] = \"polar\"\n\n        super().__init__(**kwargs)\n        self.df = to_dataframe(data).dropna(subset=[ws_col, wd_col, val_col])\n        self.ws_col = ws_col\n        self.wd_col = wd_col\n        self.val_col = val_col\n        self.ws_max = ws_max or self.df[ws_col].max()\n\n    def plot(\n        self, n_bins_ws: int = 10, n_bins_wd: int = 36, cmap: str = \"viridis\", **kwargs\n    ):\n        \"\"\"\n        Generate the bivariate polar plot.\n\n        Uses binning to aggregate data before plotting.\n        \"\"\"\n        # Convert wind direction to radians and adjust for polar plot (0 is North/Up)\n        # Matplotlib polar 0 is East (right). We want 0 at North.\n        # Wind direction is usually 0=North, 90=East.\n        # theta = (90 - wd) * pi / 180\n        theta_rad = np.radians(self.df[self.wd_col])\n        # Matplotlib's polar axis by default has 0 at East.\n        # To make 0 North, we can use:\n        self.ax.set_theta_zero_location(\"N\")\n        self.ax.set_theta_direction(-1)  # Clockwise\n\n        # Binning\n        ws_bins = np.linspace(0, self.ws_max, n_bins_ws + 1)\n        wd_bins = np.radians(np.linspace(0, 360, n_bins_wd + 1))\n\n        # We can use np.histogram2d\n        # Note: wd_bins is in radians\n        H, xedges, yedges = np.histogram2d(\n            theta_rad,\n            self.df[self.ws_col],\n            bins=[wd_bins, ws_bins],\n            weights=self.df[self.val_col],\n        )\n        Counts, _, _ = np.histogram2d(\n            theta_rad, self.df[self.ws_col], bins=[wd_bins, ws_bins]\n        )\n\n        # Calculate mean\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            Z = H / Counts\n\n        # Meshgrid for plotting\n        # np.histogram2d edges are for pcolormesh\n        Theta, R = np.meshgrid(wd_bins, ws_bins)\n\n        # Plotting\n        mappable = self.ax.pcolormesh(Theta, R, Z.T, cmap=cmap, **kwargs)\n        self.add_colorbar(mappable, label=self.val_col)\n\n        self.ax.set_ylim(0, self.ws_max)\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.BivariatePolarPlot.__init__","title":"<code>__init__(data, ws_col, wd_col, val_col, *, ws_max=None, **kwargs)</code>","text":"<p>Initialize Bivariate Polar Plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data (DataFrame, DataArray, etc.).</p> required <code>ws_col</code> <code>str</code> <p>Column name for wind speed.</p> required <code>wd_col</code> <code>str</code> <p>Column name for wind direction (degrees).</p> required <code>val_col</code> <code>str</code> <p>Column name for the value to plot.</p> required <code>ws_max</code> <code>Optional[float]</code> <p>Maximum wind speed to show.</p> <code>None</code> <code>**kwargs</code> <p>Arguments passed to BasePlot. Note: 'subplot_kw={\"projection\": \"polar\"}'       is added automatically if not provided.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/polar.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    ws_col: str,\n    wd_col: str,\n    val_col: str,\n    *,\n    ws_max: Optional[float] = None,\n    **kwargs,\n):\n    \"\"\"\n    Initialize Bivariate Polar Plot.\n\n    Args:\n        data: Input data (DataFrame, DataArray, etc.).\n        ws_col: Column name for wind speed.\n        wd_col: Column name for wind direction (degrees).\n        val_col: Column name for the value to plot.\n        ws_max: Maximum wind speed to show.\n        **kwargs: Arguments passed to BasePlot. Note: 'subplot_kw={\"projection\": \"polar\"}'\n                  is added automatically if not provided.\n    \"\"\"\n    if \"subplot_kw\" not in kwargs:\n        kwargs[\"subplot_kw\"] = {\"projection\": \"polar\"}\n    elif \"projection\" not in kwargs[\"subplot_kw\"]:\n        kwargs[\"subplot_kw\"][\"projection\"] = \"polar\"\n\n    super().__init__(**kwargs)\n    self.df = to_dataframe(data).dropna(subset=[ws_col, wd_col, val_col])\n    self.ws_col = ws_col\n    self.wd_col = wd_col\n    self.val_col = val_col\n    self.ws_max = ws_max or self.df[ws_col].max()\n</code></pre>"},{"location":"api/#monet_plots.plots.BivariatePolarPlot.plot","title":"<code>plot(n_bins_ws=10, n_bins_wd=36, cmap='viridis', **kwargs)</code>","text":"<p>Generate the bivariate polar plot.</p> <p>Uses binning to aggregate data before plotting.</p> Source code in <code>src/monet_plots/plots/polar.py</code> <pre><code>def plot(\n    self, n_bins_ws: int = 10, n_bins_wd: int = 36, cmap: str = \"viridis\", **kwargs\n):\n    \"\"\"\n    Generate the bivariate polar plot.\n\n    Uses binning to aggregate data before plotting.\n    \"\"\"\n    # Convert wind direction to radians and adjust for polar plot (0 is North/Up)\n    # Matplotlib polar 0 is East (right). We want 0 at North.\n    # Wind direction is usually 0=North, 90=East.\n    # theta = (90 - wd) * pi / 180\n    theta_rad = np.radians(self.df[self.wd_col])\n    # Matplotlib's polar axis by default has 0 at East.\n    # To make 0 North, we can use:\n    self.ax.set_theta_zero_location(\"N\")\n    self.ax.set_theta_direction(-1)  # Clockwise\n\n    # Binning\n    ws_bins = np.linspace(0, self.ws_max, n_bins_ws + 1)\n    wd_bins = np.radians(np.linspace(0, 360, n_bins_wd + 1))\n\n    # We can use np.histogram2d\n    # Note: wd_bins is in radians\n    H, xedges, yedges = np.histogram2d(\n        theta_rad,\n        self.df[self.ws_col],\n        bins=[wd_bins, ws_bins],\n        weights=self.df[self.val_col],\n    )\n    Counts, _, _ = np.histogram2d(\n        theta_rad, self.df[self.ws_col], bins=[wd_bins, ws_bins]\n    )\n\n    # Calculate mean\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        Z = H / Counts\n\n    # Meshgrid for plotting\n    # np.histogram2d edges are for pcolormesh\n    Theta, R = np.meshgrid(wd_bins, ws_bins)\n\n    # Plotting\n    mappable = self.ax.pcolormesh(Theta, R, Z.T, cmap=cmap, **kwargs)\n    self.add_colorbar(mappable, label=self.val_col)\n\n    self.ax.set_ylim(0, self.ws_max)\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.BrierScoreDecompositionPlot","title":"<code>BrierScoreDecompositionPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Brier Score Decomposition Plot.</p> <p>Visualizes the components of the Brier Score: Reliability, Resolution, and Uncertainty. BS = Reliability - Resolution + Uncertainty</p> Source code in <code>src/monet_plots/plots/brier_decomposition.py</code> <pre><code>class BrierScoreDecompositionPlot(BasePlot):\n    \"\"\"\n    Brier Score Decomposition Plot.\n\n    Visualizes the components of the Brier Score: Reliability,\n    Resolution, and Uncertainty.\n    BS = Reliability - Resolution + Uncertainty\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        reliability_col: str = \"reliability\",\n        resolution_col: str = \"resolution\",\n        uncertainty_col: str = \"uncertainty\",\n        forecasts_col: Optional[str] = None,\n        observations_col: Optional[str] = None,\n        n_bins: int = 10,\n        label_col: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data: Input data.\n            reliability_col/resolution_col/uncertainty_col (str):\n                Pre-computed component columns.\n            forecasts_col/observations_col (str, optional):\n                Raw forecast probabilities and binary observations.\n            n_bins (int): Bins for decomposition if raw data.\n            label_col (str, optional): Grouping column.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        title = kwargs.pop(\"title\", \"Brier Score Decomposition\")\n        df = to_dataframe(data)\n        # Compute components if raw data provided\n        if forecasts_col and observations_col:\n            components_list = []\n            if label_col:\n                for name, group in df.groupby(label_col):\n                    comps = compute_brier_score_components(\n                        np.asarray(group[forecasts_col]),\n                        np.asarray(group[observations_col]),\n                        n_bins,\n                    )\n                    row = pd.Series(comps)\n                    row[\"model\"] = str(name)\n                    components_list.append(row)\n            else:\n                comps = compute_brier_score_components(\n                    np.asarray(df[forecasts_col]),\n                    np.asarray(df[observations_col]),\n                    n_bins,\n                )\n                row = pd.Series(comps)\n                row[\"model\"] = \"Model\"\n                components_list.append(row)\n\n            df_plot = pd.DataFrame(components_list)\n            plot_label_col = \"model\"\n        else:\n            required_cols = [reliability_col, resolution_col, uncertainty_col]\n            validate_dataframe(df, required_columns=required_cols)\n            df_plot = df\n            plot_label_col = label_col\n\n        # Prepare for plotting: make resolution negative for visualization\n        df_plot = df_plot.copy()\n        df_plot[\"resolution_plot\"] = -df_plot[resolution_col]\n\n        # Grouped bar plot\n        if plot_label_col:\n            labels = df_plot[plot_label_col].astype(str)\n        else:\n            labels = df_plot.index.astype(str)\n\n        x = np.arange(len(labels))\n        width = 0.25\n\n        self.ax.bar(\n            x - width,\n            df_plot[reliability_col],\n            width,\n            label=\"Reliability\",\n            color=\"red\",\n            alpha=0.8,\n            **kwargs,\n        )\n        self.ax.bar(\n            x,\n            df_plot[\"resolution_plot\"],\n            width,\n            label=\"Resolution (-)\",\n            color=\"green\",\n            alpha=0.8,\n            **kwargs,\n        )\n        self.ax.bar(\n            x + width,\n            df_plot[uncertainty_col],\n            width,\n            label=\"Uncertainty\",\n            color=\"blue\",\n            alpha=0.8,\n            **kwargs,\n        )\n\n        # Total Brier Score as line on top if available\n        if \"brier_score\" in df_plot.columns:\n            self.ax.plot(\n                x,\n                df_plot[\"brier_score\"],\n                \"ko-\",\n                linewidth=2,\n                markersize=6,\n                label=\"Brier Score\",\n            )\n\n        self.ax.set_xticks(x)\n        self.ax.set_xticklabels(labels, rotation=45, ha=\"right\")\n        self.ax.legend(loc=\"best\")\n        self.ax.set_ylabel(\"Brier Score Components\")\n        self.ax.set_title(title)\n        self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"api/#monet_plots.plots.BrierScoreDecompositionPlot.plot","title":"<code>plot(data, reliability_col='reliability', resolution_col='resolution', uncertainty_col='uncertainty', forecasts_col=None, observations_col=None, n_bins=10, label_col=None, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data.</p> required <code>reliability_col/resolution_col/uncertainty_col</code> <code>str</code> <p>Pre-computed component columns.</p> required <code>forecasts_col/observations_col</code> <code>str</code> <p>Raw forecast probabilities and binary observations.</p> required <code>n_bins</code> <code>int</code> <p>Bins for decomposition if raw data.</p> <code>10</code> <code>label_col</code> <code>str</code> <p>Grouping column.</p> <code>None</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/brier_decomposition.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    reliability_col: str = \"reliability\",\n    resolution_col: str = \"resolution\",\n    uncertainty_col: str = \"uncertainty\",\n    forecasts_col: Optional[str] = None,\n    observations_col: Optional[str] = None,\n    n_bins: int = 10,\n    label_col: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data: Input data.\n        reliability_col/resolution_col/uncertainty_col (str):\n            Pre-computed component columns.\n        forecasts_col/observations_col (str, optional):\n            Raw forecast probabilities and binary observations.\n        n_bins (int): Bins for decomposition if raw data.\n        label_col (str, optional): Grouping column.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    title = kwargs.pop(\"title\", \"Brier Score Decomposition\")\n    df = to_dataframe(data)\n    # Compute components if raw data provided\n    if forecasts_col and observations_col:\n        components_list = []\n        if label_col:\n            for name, group in df.groupby(label_col):\n                comps = compute_brier_score_components(\n                    np.asarray(group[forecasts_col]),\n                    np.asarray(group[observations_col]),\n                    n_bins,\n                )\n                row = pd.Series(comps)\n                row[\"model\"] = str(name)\n                components_list.append(row)\n        else:\n            comps = compute_brier_score_components(\n                np.asarray(df[forecasts_col]),\n                np.asarray(df[observations_col]),\n                n_bins,\n            )\n            row = pd.Series(comps)\n            row[\"model\"] = \"Model\"\n            components_list.append(row)\n\n        df_plot = pd.DataFrame(components_list)\n        plot_label_col = \"model\"\n    else:\n        required_cols = [reliability_col, resolution_col, uncertainty_col]\n        validate_dataframe(df, required_columns=required_cols)\n        df_plot = df\n        plot_label_col = label_col\n\n    # Prepare for plotting: make resolution negative for visualization\n    df_plot = df_plot.copy()\n    df_plot[\"resolution_plot\"] = -df_plot[resolution_col]\n\n    # Grouped bar plot\n    if plot_label_col:\n        labels = df_plot[plot_label_col].astype(str)\n    else:\n        labels = df_plot.index.astype(str)\n\n    x = np.arange(len(labels))\n    width = 0.25\n\n    self.ax.bar(\n        x - width,\n        df_plot[reliability_col],\n        width,\n        label=\"Reliability\",\n        color=\"red\",\n        alpha=0.8,\n        **kwargs,\n    )\n    self.ax.bar(\n        x,\n        df_plot[\"resolution_plot\"],\n        width,\n        label=\"Resolution (-)\",\n        color=\"green\",\n        alpha=0.8,\n        **kwargs,\n    )\n    self.ax.bar(\n        x + width,\n        df_plot[uncertainty_col],\n        width,\n        label=\"Uncertainty\",\n        color=\"blue\",\n        alpha=0.8,\n        **kwargs,\n    )\n\n    # Total Brier Score as line on top if available\n    if \"brier_score\" in df_plot.columns:\n        self.ax.plot(\n            x,\n            df_plot[\"brier_score\"],\n            \"ko-\",\n            linewidth=2,\n            markersize=6,\n            label=\"Brier Score\",\n        )\n\n    self.ax.set_xticks(x)\n    self.ax.set_xticklabels(labels, rotation=45, ha=\"right\")\n    self.ax.legend(loc=\"best\")\n    self.ax.set_ylabel(\"Brier Score Components\")\n    self.ax.set_title(title)\n    self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"api/#monet_plots.plots.ConditionalBiasPlot","title":"<code>ConditionalBiasPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Conditional Bias Plot.</p> <p>Visualizes the Bias (Forecast - Observation) as a function of the Observed Value. Supports native Xarray/Dask objects and interactive visualization.</p> Source code in <code>src/monet_plots/plots/conditional_bias.py</code> <pre><code>class ConditionalBiasPlot(BasePlot):\n    \"\"\"\n    Conditional Bias Plot.\n\n    Visualizes the Bias (Forecast - Observation) as a function of the Observed Value.\n    Supports native Xarray/Dask objects and interactive visualization.\n    \"\"\"\n\n    def __init__(self, data: Optional[Any] = None, fig=None, ax=None, **kwargs):\n        \"\"\"\n        Initializes the plot.\n\n        Parameters\n        ----------\n        data : Any, optional\n            The input data (Dataset, DataArray, DataFrame, or ndarray).\n        fig : matplotlib.figure.Figure, optional\n            Figure to plot on.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on.\n        **kwargs : Any\n            Additional keyword arguments for the figure.\n        \"\"\"\n        super().__init__(fig=fig, ax=ax, **kwargs)\n        self.data = normalize_data(data) if data is not None else None\n\n    def plot(\n        self,\n        data: Optional[Any] = None,\n        obs_col: Optional[str] = None,\n        fcst_col: Optional[str] = None,\n        n_bins: int = 10,\n        label: str = \"Model\",\n        label_col: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Generates the static Matplotlib plot.\n\n        Parameters\n        ----------\n        data : Any, optional\n            Input data, overrides self.data if provided.\n        obs_col : str, optional\n            Name of the observation variable. Required for Dataset/DataFrame.\n        fcst_col : str, optional\n            Name of the forecast variable. Required for Dataset/DataFrame.\n        n_bins : int, optional\n            Number of bins for observed values, by default 10.\n        label : str, optional\n            Label for the model data, by default \"Model\".\n        label_col : str, optional\n            Column name to group by for plotting multiple lines.\n        **kwargs : Any\n            Additional Matplotlib plotting arguments passed to `errorbar`.\n\n        Returns\n        -------\n        matplotlib.axes.Axes\n            The axes object containing the plot.\n        \"\"\"\n        plot_data = normalize_data(data) if data is not None else self.data\n        if plot_data is None:\n            raise ValueError(\"No data provided.\")\n\n        try:\n            if label_col:\n                # Handle grouping for multiple models/categories\n                for name, group in plot_data.groupby(label_col):\n                    obs = group[obs_col]\n                    mod = group[fcst_col]\n                    self._plot_single(obs, mod, n_bins, label=str(name), **kwargs)\n            else:\n                # Single model plot\n                if isinstance(plot_data, xr.Dataset):\n                    obs = plot_data[obs_col]\n                    mod = plot_data[fcst_col]\n                elif isinstance(plot_data, xr.DataArray):\n                    mod = plot_data\n                    obs = kwargs.pop(\"obs\", None)\n                    if obs is None:\n                        raise ValueError(\"obs must be provided if data is a DataArray.\")\n                elif isinstance(plot_data, pd.DataFrame):\n                    obs = plot_data[obs_col]\n                    mod = plot_data[fcst_col]\n                else:\n                    # Should have been normalized\n                    raise TypeError(f\"Unsupported data type: {type(plot_data)}\")\n\n                self._plot_single(obs, mod, n_bins, label=label, **kwargs)\n        except KeyError as e:\n            raise ValueError(f\"Required column not found: {e}\") from e\n\n        self.ax.axhline(0, color=\"k\", linestyle=\"--\", linewidth=1.5, alpha=0.7)\n        xlabel = (\n            plot_data[obs_col].attrs.get(\"long_name\", obs_col)\n            if obs_col\n            else \"Observed Value\"\n        )\n        self.ax.set_xlabel(xlabel)\n        self.ax.set_ylabel(\"Mean Bias (Forecast - Observation)\")\n        self.ax.legend()\n        return self.ax\n\n    def _plot_single(self, obs, mod, n_bins, label, **kwargs):\n        \"\"\"Helper to plot a single binned bias line.\"\"\"\n        stats = compute_binned_bias(obs, mod, n_bins=n_bins)\n        pdf = stats.compute().dropna(dim=\"bin_center\")\n\n        # Filter for count &gt; 1 to avoid showing bins with only one sample (no std dev)\n        pdf = pdf.where(pdf.bias_count &gt; 1, drop=True)\n\n        if pdf.bin_center.size &gt; 0:\n            self.ax.errorbar(\n                pdf.bin_center,\n                pdf.bias_mean,\n                yerr=pdf.bias_std,\n                fmt=\"o-\",\n                capsize=5,\n                label=label,\n                **kwargs,\n            )\n\n    def hvplot(\n        self,\n        data: Optional[Any] = None,\n        obs_col: Optional[str] = None,\n        fcst_col: Optional[str] = None,\n        n_bins: int = 10,\n        label_col: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Generates an interactive plot using hvPlot.\n\n        Parameters\n        ----------\n        data : Any, optional\n            Input data, overrides self.data if provided.\n        obs_col : str, optional\n            Name of the observation variable.\n        fcst_col : str, optional\n            Name of the forecast variable.\n        n_bins : int, optional\n            Number of bins, by default 10.\n        label_col : str, optional\n            Column name to group by.\n        **kwargs : Any\n            Additional hvPlot arguments.\n\n        Returns\n        -------\n        holoviews.core.Element\n            The interactive plot.\n        \"\"\"\n        import holoviews as hv\n        import hvplot.xarray  # noqa: F401\n\n        plot_data = normalize_data(data) if data is not None else self.data\n        if plot_data is None:\n            raise ValueError(\"No data provided.\")\n\n        if label_col:\n\n            def get_stats(group):\n                return compute_binned_bias(\n                    group[obs_col], group[fcst_col], n_bins=n_bins\n                ).compute()\n\n            # We compute per group for the visualization summary\n            stats_list = []\n            for name, group in plot_data.groupby(label_col):\n                s = get_stats(group)\n                s = s.assign_coords({label_col: name}).expand_dims(label_col)\n                stats_list.append(s)\n            pdf = xr.concat(stats_list, dim=label_col).dropna(dim=\"bin_center\")\n            by = label_col\n        else:\n            if isinstance(plot_data, xr.Dataset):\n                obs = plot_data[obs_col]\n                mod = plot_data[fcst_col]\n            elif isinstance(plot_data, pd.DataFrame):\n                obs = plot_data[obs_col]\n                mod = plot_data[fcst_col]\n            else:\n                mod = plot_data\n                obs = kwargs.pop(\"obs\")\n            pdf = compute_binned_bias(obs, mod, n_bins=n_bins).compute()\n            pdf = pdf.dropna(dim=\"bin_center\")\n            by = None\n\n        xlabel = (\n            plot_data[obs_col].attrs.get(\"long_name\", obs_col)\n            if obs_col\n            else \"Observed Value\"\n        )\n\n        plot = pdf.hvplot.scatter(\n            x=\"bin_center\",\n            y=\"bias_mean\",\n            by=by,\n            xlabel=xlabel,\n            ylabel=\"Mean Bias\",\n            **kwargs,\n        ) * pdf.hvplot.errorbars(x=\"bin_center\", y=\"bias_mean\", yerr1=\"bias_std\", by=by)\n\n        # Add zero line\n        plot *= hv.HLine(0).opts(color=\"black\", line_dash=\"dashed\")\n\n        return plot\n</code></pre>"},{"location":"api/#monet_plots.plots.ConditionalBiasPlot.__init__","title":"<code>__init__(data=None, fig=None, ax=None, **kwargs)</code>","text":"<p>Initializes the plot.</p>"},{"location":"api/#monet_plots.plots.ConditionalBiasPlot.__init__--parameters","title":"Parameters","text":"<p>data : Any, optional     The input data (Dataset, DataArray, DataFrame, or ndarray). fig : matplotlib.figure.Figure, optional     Figure to plot on. ax : matplotlib.axes.Axes, optional     Axes to plot on. **kwargs : Any     Additional keyword arguments for the figure.</p> Source code in <code>src/monet_plots/plots/conditional_bias.py</code> <pre><code>def __init__(self, data: Optional[Any] = None, fig=None, ax=None, **kwargs):\n    \"\"\"\n    Initializes the plot.\n\n    Parameters\n    ----------\n    data : Any, optional\n        The input data (Dataset, DataArray, DataFrame, or ndarray).\n    fig : matplotlib.figure.Figure, optional\n        Figure to plot on.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on.\n    **kwargs : Any\n        Additional keyword arguments for the figure.\n    \"\"\"\n    super().__init__(fig=fig, ax=ax, **kwargs)\n    self.data = normalize_data(data) if data is not None else None\n</code></pre>"},{"location":"api/#monet_plots.plots.ConditionalBiasPlot.hvplot","title":"<code>hvplot(data=None, obs_col=None, fcst_col=None, n_bins=10, label_col=None, **kwargs)</code>","text":"<p>Generates an interactive plot using hvPlot.</p>"},{"location":"api/#monet_plots.plots.ConditionalBiasPlot.hvplot--parameters","title":"Parameters","text":"<p>data : Any, optional     Input data, overrides self.data if provided. obs_col : str, optional     Name of the observation variable. fcst_col : str, optional     Name of the forecast variable. n_bins : int, optional     Number of bins, by default 10. label_col : str, optional     Column name to group by. **kwargs : Any     Additional hvPlot arguments.</p>"},{"location":"api/#monet_plots.plots.ConditionalBiasPlot.hvplot--returns","title":"Returns","text":"<p>holoviews.core.Element     The interactive plot.</p> Source code in <code>src/monet_plots/plots/conditional_bias.py</code> <pre><code>def hvplot(\n    self,\n    data: Optional[Any] = None,\n    obs_col: Optional[str] = None,\n    fcst_col: Optional[str] = None,\n    n_bins: int = 10,\n    label_col: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"\n    Generates an interactive plot using hvPlot.\n\n    Parameters\n    ----------\n    data : Any, optional\n        Input data, overrides self.data if provided.\n    obs_col : str, optional\n        Name of the observation variable.\n    fcst_col : str, optional\n        Name of the forecast variable.\n    n_bins : int, optional\n        Number of bins, by default 10.\n    label_col : str, optional\n        Column name to group by.\n    **kwargs : Any\n        Additional hvPlot arguments.\n\n    Returns\n    -------\n    holoviews.core.Element\n        The interactive plot.\n    \"\"\"\n    import holoviews as hv\n    import hvplot.xarray  # noqa: F401\n\n    plot_data = normalize_data(data) if data is not None else self.data\n    if plot_data is None:\n        raise ValueError(\"No data provided.\")\n\n    if label_col:\n\n        def get_stats(group):\n            return compute_binned_bias(\n                group[obs_col], group[fcst_col], n_bins=n_bins\n            ).compute()\n\n        # We compute per group for the visualization summary\n        stats_list = []\n        for name, group in plot_data.groupby(label_col):\n            s = get_stats(group)\n            s = s.assign_coords({label_col: name}).expand_dims(label_col)\n            stats_list.append(s)\n        pdf = xr.concat(stats_list, dim=label_col).dropna(dim=\"bin_center\")\n        by = label_col\n    else:\n        if isinstance(plot_data, xr.Dataset):\n            obs = plot_data[obs_col]\n            mod = plot_data[fcst_col]\n        elif isinstance(plot_data, pd.DataFrame):\n            obs = plot_data[obs_col]\n            mod = plot_data[fcst_col]\n        else:\n            mod = plot_data\n            obs = kwargs.pop(\"obs\")\n        pdf = compute_binned_bias(obs, mod, n_bins=n_bins).compute()\n        pdf = pdf.dropna(dim=\"bin_center\")\n        by = None\n\n    xlabel = (\n        plot_data[obs_col].attrs.get(\"long_name\", obs_col)\n        if obs_col\n        else \"Observed Value\"\n    )\n\n    plot = pdf.hvplot.scatter(\n        x=\"bin_center\",\n        y=\"bias_mean\",\n        by=by,\n        xlabel=xlabel,\n        ylabel=\"Mean Bias\",\n        **kwargs,\n    ) * pdf.hvplot.errorbars(x=\"bin_center\", y=\"bias_mean\", yerr1=\"bias_std\", by=by)\n\n    # Add zero line\n    plot *= hv.HLine(0).opts(color=\"black\", line_dash=\"dashed\")\n\n    return plot\n</code></pre>"},{"location":"api/#monet_plots.plots.ConditionalBiasPlot.plot","title":"<code>plot(data=None, obs_col=None, fcst_col=None, n_bins=10, label='Model', label_col=None, **kwargs)</code>","text":"<p>Generates the static Matplotlib plot.</p>"},{"location":"api/#monet_plots.plots.ConditionalBiasPlot.plot--parameters","title":"Parameters","text":"<p>data : Any, optional     Input data, overrides self.data if provided. obs_col : str, optional     Name of the observation variable. Required for Dataset/DataFrame. fcst_col : str, optional     Name of the forecast variable. Required for Dataset/DataFrame. n_bins : int, optional     Number of bins for observed values, by default 10. label : str, optional     Label for the model data, by default \"Model\". label_col : str, optional     Column name to group by for plotting multiple lines. **kwargs : Any     Additional Matplotlib plotting arguments passed to <code>errorbar</code>.</p>"},{"location":"api/#monet_plots.plots.ConditionalBiasPlot.plot--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The axes object containing the plot.</p> Source code in <code>src/monet_plots/plots/conditional_bias.py</code> <pre><code>def plot(\n    self,\n    data: Optional[Any] = None,\n    obs_col: Optional[str] = None,\n    fcst_col: Optional[str] = None,\n    n_bins: int = 10,\n    label: str = \"Model\",\n    label_col: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"\n    Generates the static Matplotlib plot.\n\n    Parameters\n    ----------\n    data : Any, optional\n        Input data, overrides self.data if provided.\n    obs_col : str, optional\n        Name of the observation variable. Required for Dataset/DataFrame.\n    fcst_col : str, optional\n        Name of the forecast variable. Required for Dataset/DataFrame.\n    n_bins : int, optional\n        Number of bins for observed values, by default 10.\n    label : str, optional\n        Label for the model data, by default \"Model\".\n    label_col : str, optional\n        Column name to group by for plotting multiple lines.\n    **kwargs : Any\n        Additional Matplotlib plotting arguments passed to `errorbar`.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The axes object containing the plot.\n    \"\"\"\n    plot_data = normalize_data(data) if data is not None else self.data\n    if plot_data is None:\n        raise ValueError(\"No data provided.\")\n\n    try:\n        if label_col:\n            # Handle grouping for multiple models/categories\n            for name, group in plot_data.groupby(label_col):\n                obs = group[obs_col]\n                mod = group[fcst_col]\n                self._plot_single(obs, mod, n_bins, label=str(name), **kwargs)\n        else:\n            # Single model plot\n            if isinstance(plot_data, xr.Dataset):\n                obs = plot_data[obs_col]\n                mod = plot_data[fcst_col]\n            elif isinstance(plot_data, xr.DataArray):\n                mod = plot_data\n                obs = kwargs.pop(\"obs\", None)\n                if obs is None:\n                    raise ValueError(\"obs must be provided if data is a DataArray.\")\n            elif isinstance(plot_data, pd.DataFrame):\n                obs = plot_data[obs_col]\n                mod = plot_data[fcst_col]\n            else:\n                # Should have been normalized\n                raise TypeError(f\"Unsupported data type: {type(plot_data)}\")\n\n            self._plot_single(obs, mod, n_bins, label=label, **kwargs)\n    except KeyError as e:\n        raise ValueError(f\"Required column not found: {e}\") from e\n\n    self.ax.axhline(0, color=\"k\", linestyle=\"--\", linewidth=1.5, alpha=0.7)\n    xlabel = (\n        plot_data[obs_col].attrs.get(\"long_name\", obs_col)\n        if obs_col\n        else \"Observed Value\"\n    )\n    self.ax.set_xlabel(xlabel)\n    self.ax.set_ylabel(\"Mean Bias (Forecast - Observation)\")\n    self.ax.legend()\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.ConditionalQuantilePlot","title":"<code>ConditionalQuantilePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Conditional quantile plot.</p> <p>Plots the distribution (quantiles) of modeled values as a function of binned observed values. This helps identify if the model's uncertainty or bias changes across the range of observations.</p> Source code in <code>src/monet_plots/plots/conditional_quantile.py</code> <pre><code>class ConditionalQuantilePlot(BasePlot):\n    \"\"\"Conditional quantile plot.\n\n    Plots the distribution (quantiles) of modeled values as a function\n    of binned observed values. This helps identify if the model's\n    uncertainty or bias changes across the range of observations.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        obs_col: str,\n        mod_col: str,\n        *,\n        bins: Union[int, List[float]] = 10,\n        quantiles: List[float] = [0.25, 0.5, 0.75],\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize Conditional Quantile Plot.\n\n        Args:\n            data: Input data (DataFrame, DataArray, etc.).\n            obs_col: Column name for observations.\n            mod_col: Column name for model values.\n            bins: Number of bins or bin edges for observations.\n            quantiles: List of quantiles to calculate (0 to 1).\n            **kwargs: Arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.df = to_dataframe(data).dropna(subset=[obs_col, mod_col])\n        self.obs_col = obs_col\n        self.mod_col = mod_col\n        self.bins = bins\n        self.quantiles = sorted(quantiles)\n\n    def plot(self, show_points: bool = False, **kwargs):\n        \"\"\"Generate the conditional quantile plot.\"\"\"\n        # Bin observations\n        self.df[\"bin\"] = pd.cut(self.df[self.obs_col], bins=self.bins)\n\n        # Calculate quantiles for each bin\n        # We use the midpoint of each bin for the x-axis\n        bin_midpoints = []\n        quantile_vals = {q: [] for q in self.quantiles}\n\n        for bin_name, group in self.df.groupby(\"bin\", observed=True):\n            bin_midpoints.append(bin_name.mid)\n            for q in self.quantiles:\n                quantile_vals[q].append(group[self.mod_col].quantile(q))\n\n        # Plotting\n        if show_points:\n            self.ax.scatter(\n                self.df[self.obs_col],\n                self.df[self.mod_col],\n                alpha=0.3,\n                s=10,\n                color=\"grey\",\n                label=\"Data\",\n            )\n\n        # Plot 1:1 line\n        lims = [\n            min(self.df[self.obs_col].min(), self.df[self.mod_col].min()),\n            max(self.df[self.obs_col].max(), self.df[self.mod_col].max()),\n        ]\n        self.ax.plot(lims, lims, \"k--\", alpha=0.5, label=\"1:1\")\n\n        # Plot quantiles\n        colors = plt.cm.Blues(np.linspace(0.4, 0.8, len(self.quantiles)))\n        for i, q in enumerate(self.quantiles):\n            label = f\"{int(q * 100)}th percentile\"\n            linestyle = \"-\" if q == 0.5 else \"--\"\n            linewidth = 2 if q == 0.5 else 1\n            self.ax.plot(\n                bin_midpoints,\n                quantile_vals[q],\n                label=label,\n                color=colors[i],\n                linestyle=linestyle,\n                linewidth=linewidth,\n            )\n\n        # Shading between quantiles if there are at least 2 (e.g. 25th and 75th)\n        if 0.25 in self.quantiles and 0.75 in self.quantiles:\n            self.ax.fill_between(\n                bin_midpoints,\n                quantile_vals[0.25],\n                quantile_vals[0.75],\n                color=\"blue\",\n                alpha=0.1,\n            )\n\n        self.ax.set_xlabel(f\"Observed: {self.obs_col}\")\n        self.ax.set_ylabel(f\"Modeled: {self.mod_col}\")\n        self.ax.legend()\n        self.ax.grid(True, linestyle=\":\", alpha=0.6)\n\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.ConditionalQuantilePlot.__init__","title":"<code>__init__(data, obs_col, mod_col, *, bins=10, quantiles=[0.25, 0.5, 0.75], **kwargs)</code>","text":"<p>Initialize Conditional Quantile Plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data (DataFrame, DataArray, etc.).</p> required <code>obs_col</code> <code>str</code> <p>Column name for observations.</p> required <code>mod_col</code> <code>str</code> <p>Column name for model values.</p> required <code>bins</code> <code>Union[int, List[float]]</code> <p>Number of bins or bin edges for observations.</p> <code>10</code> <code>quantiles</code> <code>List[float]</code> <p>List of quantiles to calculate (0 to 1).</p> <code>[0.25, 0.5, 0.75]</code> <code>**kwargs</code> <p>Arguments passed to BasePlot.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/conditional_quantile.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    obs_col: str,\n    mod_col: str,\n    *,\n    bins: Union[int, List[float]] = 10,\n    quantiles: List[float] = [0.25, 0.5, 0.75],\n    **kwargs,\n):\n    \"\"\"\n    Initialize Conditional Quantile Plot.\n\n    Args:\n        data: Input data (DataFrame, DataArray, etc.).\n        obs_col: Column name for observations.\n        mod_col: Column name for model values.\n        bins: Number of bins or bin edges for observations.\n        quantiles: List of quantiles to calculate (0 to 1).\n        **kwargs: Arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.df = to_dataframe(data).dropna(subset=[obs_col, mod_col])\n    self.obs_col = obs_col\n    self.mod_col = mod_col\n    self.bins = bins\n    self.quantiles = sorted(quantiles)\n</code></pre>"},{"location":"api/#monet_plots.plots.ConditionalQuantilePlot.plot","title":"<code>plot(show_points=False, **kwargs)</code>","text":"<p>Generate the conditional quantile plot.</p> Source code in <code>src/monet_plots/plots/conditional_quantile.py</code> <pre><code>def plot(self, show_points: bool = False, **kwargs):\n    \"\"\"Generate the conditional quantile plot.\"\"\"\n    # Bin observations\n    self.df[\"bin\"] = pd.cut(self.df[self.obs_col], bins=self.bins)\n\n    # Calculate quantiles for each bin\n    # We use the midpoint of each bin for the x-axis\n    bin_midpoints = []\n    quantile_vals = {q: [] for q in self.quantiles}\n\n    for bin_name, group in self.df.groupby(\"bin\", observed=True):\n        bin_midpoints.append(bin_name.mid)\n        for q in self.quantiles:\n            quantile_vals[q].append(group[self.mod_col].quantile(q))\n\n    # Plotting\n    if show_points:\n        self.ax.scatter(\n            self.df[self.obs_col],\n            self.df[self.mod_col],\n            alpha=0.3,\n            s=10,\n            color=\"grey\",\n            label=\"Data\",\n        )\n\n    # Plot 1:1 line\n    lims = [\n        min(self.df[self.obs_col].min(), self.df[self.mod_col].min()),\n        max(self.df[self.obs_col].max(), self.df[self.mod_col].max()),\n    ]\n    self.ax.plot(lims, lims, \"k--\", alpha=0.5, label=\"1:1\")\n\n    # Plot quantiles\n    colors = plt.cm.Blues(np.linspace(0.4, 0.8, len(self.quantiles)))\n    for i, q in enumerate(self.quantiles):\n        label = f\"{int(q * 100)}th percentile\"\n        linestyle = \"-\" if q == 0.5 else \"--\"\n        linewidth = 2 if q == 0.5 else 1\n        self.ax.plot(\n            bin_midpoints,\n            quantile_vals[q],\n            label=label,\n            color=colors[i],\n            linestyle=linestyle,\n            linewidth=linewidth,\n        )\n\n    # Shading between quantiles if there are at least 2 (e.g. 25th and 75th)\n    if 0.25 in self.quantiles and 0.75 in self.quantiles:\n        self.ax.fill_between(\n            bin_midpoints,\n            quantile_vals[0.25],\n            quantile_vals[0.75],\n            color=\"blue\",\n            alpha=0.1,\n        )\n\n    self.ax.set_xlabel(f\"Observed: {self.obs_col}\")\n    self.ax.set_ylabel(f\"Modeled: {self.mod_col}\")\n    self.ax.legend()\n    self.ax.grid(True, linestyle=\":\", alpha=0.6)\n\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.CurtainPlot","title":"<code>CurtainPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Vertical curtain plot for cross-sectional data.</p> <p>This plot shows a 2D variable (e.g., concentration) as a function of one horizontal dimension (time or distance) and one vertical dimension (altitude or pressure).</p> Source code in <code>src/monet_plots/plots/curtain.py</code> <pre><code>class CurtainPlot(BasePlot):\n    \"\"\"Vertical curtain plot for cross-sectional data.\n\n    This plot shows a 2D variable (e.g., concentration) as a function of\n    one horizontal dimension (time or distance) and one vertical dimension\n    (altitude or pressure).\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        *,\n        x: Optional[str] = None,\n        y: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize Curtain Plot.\n\n        Args:\n            data: Input data. Should be a 2D xarray.DataArray or similar.\n            x: Name of the x-axis dimension/coordinate (e.g., 'time').\n            y: Name of the y-axis dimension/coordinate (e.g., 'level').\n            **kwargs: Arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.data = data\n        self.x = x\n        self.y = y\n\n    def plot(self, kind: str = \"pcolormesh\", colorbar: bool = True, **kwargs):\n        \"\"\"\n        Generate the curtain plot.\n\n        Args:\n            kind: Type of plot ('pcolormesh' or 'contourf').\n            colorbar: Whether to add a colorbar.\n            **kwargs: Additional arguments for the plotting function.\n        \"\"\"\n        plot_kwargs = get_plot_kwargs(**kwargs)\n\n        # Ensure we have a DataArray\n        if not isinstance(self.data, xr.DataArray):\n            # Try to convert or at least verify it's xarray-like\n            if hasattr(self.data, \"to_array\"):\n                da = self.data.to_array()\n            else:\n                raise TypeError(\n                    \"CurtainPlot requires xarray-like data with 2 dimensions.\"\n                )\n        else:\n            da = self.data\n\n        if da.ndim != 2:\n            raise ValueError(f\"CurtainPlot requires 2D data, got {da.ndim}D.\")\n\n        # Determine x and y if not provided\n        if self.x is None:\n            self.x = da.dims[1]\n        if self.y is None:\n            self.y = da.dims[0]\n\n        if kind == \"pcolormesh\":\n            mappable = self.ax.pcolormesh(\n                da[self.x], da[self.y], da, shading=\"auto\", **plot_kwargs\n            )\n        elif kind == \"contourf\":\n            mappable = self.ax.contourf(da[self.x], da[self.y], da, **plot_kwargs)\n        else:\n            raise ValueError(\"kind must be 'pcolormesh' or 'contourf'\")\n\n        if colorbar:\n            self.add_colorbar(mappable)\n\n        self.ax.set_xlabel(self.x)\n        self.ax.set_ylabel(self.y)\n\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.CurtainPlot.__init__","title":"<code>__init__(data, *, x=None, y=None, **kwargs)</code>","text":"<p>Initialize Curtain Plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data. Should be a 2D xarray.DataArray or similar.</p> required <code>x</code> <code>Optional[str]</code> <p>Name of the x-axis dimension/coordinate (e.g., 'time').</p> <code>None</code> <code>y</code> <code>Optional[str]</code> <p>Name of the y-axis dimension/coordinate (e.g., 'level').</p> <code>None</code> <code>**kwargs</code> <p>Arguments passed to BasePlot.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/curtain.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    *,\n    x: Optional[str] = None,\n    y: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"\n    Initialize Curtain Plot.\n\n    Args:\n        data: Input data. Should be a 2D xarray.DataArray or similar.\n        x: Name of the x-axis dimension/coordinate (e.g., 'time').\n        y: Name of the y-axis dimension/coordinate (e.g., 'level').\n        **kwargs: Arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.data = data\n    self.x = x\n    self.y = y\n</code></pre>"},{"location":"api/#monet_plots.plots.CurtainPlot.plot","title":"<code>plot(kind='pcolormesh', colorbar=True, **kwargs)</code>","text":"<p>Generate the curtain plot.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>Type of plot ('pcolormesh' or 'contourf').</p> <code>'pcolormesh'</code> <code>colorbar</code> <code>bool</code> <p>Whether to add a colorbar.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments for the plotting function.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/curtain.py</code> <pre><code>def plot(self, kind: str = \"pcolormesh\", colorbar: bool = True, **kwargs):\n    \"\"\"\n    Generate the curtain plot.\n\n    Args:\n        kind: Type of plot ('pcolormesh' or 'contourf').\n        colorbar: Whether to add a colorbar.\n        **kwargs: Additional arguments for the plotting function.\n    \"\"\"\n    plot_kwargs = get_plot_kwargs(**kwargs)\n\n    # Ensure we have a DataArray\n    if not isinstance(self.data, xr.DataArray):\n        # Try to convert or at least verify it's xarray-like\n        if hasattr(self.data, \"to_array\"):\n            da = self.data.to_array()\n        else:\n            raise TypeError(\n                \"CurtainPlot requires xarray-like data with 2 dimensions.\"\n            )\n    else:\n        da = self.data\n\n    if da.ndim != 2:\n        raise ValueError(f\"CurtainPlot requires 2D data, got {da.ndim}D.\")\n\n    # Determine x and y if not provided\n    if self.x is None:\n        self.x = da.dims[1]\n    if self.y is None:\n        self.y = da.dims[0]\n\n    if kind == \"pcolormesh\":\n        mappable = self.ax.pcolormesh(\n            da[self.x], da[self.y], da, shading=\"auto\", **plot_kwargs\n        )\n    elif kind == \"contourf\":\n        mappable = self.ax.contourf(da[self.x], da[self.y], da, **plot_kwargs)\n    else:\n        raise ValueError(\"kind must be 'pcolormesh' or 'contourf'\")\n\n    if colorbar:\n        self.add_colorbar(mappable)\n\n    self.ax.set_xlabel(self.x)\n    self.ax.set_ylabel(self.y)\n\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot","title":"<code>DiurnalErrorPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Diurnal error heat map.</p> <p>Visualizes model error (bias) as a function of the hour of day and another temporal dimension (e.g., month, day of week, or date).</p> <p>This class supports native Xarray and Dask objects for lazy evaluation and provenance tracking.</p>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot--examples","title":"Examples","text":"<p>import pandas as pd import numpy as np from monet_plots.plots import DiurnalErrorPlot dates = pd.date_range(\"2023-01-01\", periods=100, freq=\"h\") df = pd.DataFrame({ ...     \"time\": dates, ...     \"obs\": np.random.rand(100), ...     \"mod\": np.random.rand(100) ... }) plot = DiurnalErrorPlot(df, obs_col=\"obs\", mod_col=\"mod\") ax = plot.plot()</p> Source code in <code>src/monet_plots/plots/diurnal_error.py</code> <pre><code>class DiurnalErrorPlot(BasePlot):\n    \"\"\"Diurnal error heat map.\n\n    Visualizes model error (bias) as a function of the hour of day and another\n    temporal dimension (e.g., month, day of week, or date).\n\n    This class supports native Xarray and Dask objects for lazy evaluation\n    and provenance tracking.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from monet_plots.plots import DiurnalErrorPlot\n    &gt;&gt;&gt; dates = pd.date_range(\"2023-01-01\", periods=100, freq=\"h\")\n    &gt;&gt;&gt; df = pd.DataFrame({\n    ...     \"time\": dates,\n    ...     \"obs\": np.random.rand(100),\n    ...     \"mod\": np.random.rand(100)\n    ... })\n    &gt;&gt;&gt; plot = DiurnalErrorPlot(df, obs_col=\"obs\", mod_col=\"mod\")\n    &gt;&gt;&gt; ax = plot.plot()\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        obs_col: str,\n        mod_col: str,\n        *,\n        time_col: str = \"time\",\n        second_dim: str = \"month\",\n        metric: str = \"bias\",\n        fig: Any | None = None,\n        ax: Any | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize Diurnal Error Plot.\n\n        Parameters\n        ----------\n        data : Any\n            Input data. Can be a pandas DataFrame, xarray DataArray,\n            xarray Dataset, or dask-backed object.\n        obs_col : str\n            Column/variable name for observations.\n        mod_col : str\n            Column/variable name for model values.\n        time_col : str, optional\n            Dimension/column name for timestamp, by default \"time\".\n        second_dim : str, optional\n            The second dimension for the heatmap ('month', 'dayofweek', 'date',\n            or a coordinate name), by default \"month\".\n        metric : str, optional\n            The metric to plot ('bias' or 'error'), by default \"bias\".\n        fig : Any, optional\n            Existing figure object, by default None.\n        ax : Any, optional\n            Existing axes object, by default None.\n        **kwargs : Any\n            Additional arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n        # Normalize data to Xarray if possible\n        self.data = normalize_data(data)\n        self.obs_col = obs_col\n        self.mod_col = mod_col\n        self.time_col = time_col\n        self.second_dim = second_dim\n        self.metric = metric\n\n        # Prepare the calculation\n        self._calculate_metric()\n\n    def _calculate_metric(self) -&gt; None:\n        \"\"\"Calculates the aggregated metric for the heatmap.\n\n        This method identifies the appropriate backend (Xarray/Dask or Pandas),\n        calculates the specified metric (bias or absolute error), and aggregates\n        it into a 2D grid indexed by 'second_val' and 'hour'. It maintains\n        lazy evaluation for Dask-backed objects.\n\n        Raises\n        ------\n        ValueError\n            If the metric is not 'bias' or 'error', or if second_dim is not found.\n        \"\"\"\n        # Convert to Dataset if it's a DataArray to handle multiple columns easily\n        ds = self.data\n        if isinstance(ds, xr.DataArray):\n            ds = ds.to_dataset() if hasattr(ds, \"to_dataset\") else ds\n\n        if isinstance(ds, xr.Dataset):\n            # Calculate individual error/bias lazily\n            if self.metric == \"bias\":\n                val = ds[self.mod_col] - ds[self.obs_col]\n                val.name = \"bias\"\n                msg = \"Calculated diurnal bias\"\n            elif self.metric == \"error\":\n                val = np.abs(ds[self.mod_col] - ds[self.obs_col])\n                val.name = \"error\"\n                msg = \"Calculated diurnal absolute error\"\n            else:\n                raise ValueError(\"metric must be 'bias' or 'error'\")\n\n            # Add temporal coordinates for grouping\n            time_coord = ds[self.time_col]\n            val = val.assign_coords(hour=time_coord.dt.hour)\n\n            if self.second_dim == \"month\":\n                val = val.assign_coords(second_val=time_coord.dt.month)\n                self.second_label = \"Month\"\n            elif self.second_dim == \"dayofweek\":\n                val = val.assign_coords(second_val=time_coord.dt.dayofweek)\n                self.second_label = \"Day of Week\"\n            elif self.second_dim == \"date\":\n                val = val.assign_coords(second_val=time_coord.dt.floor(\"D\"))\n                self.second_label = \"Date\"\n            else:\n                if self.second_dim in ds.coords or self.second_dim in ds.data_vars:\n                    val = val.assign_coords(second_val=ds[self.second_dim])\n                    self.second_label = self.second_dim\n                else:\n                    raise ValueError(\n                        f\"second_dim '{self.second_dim}' not found in data\"\n                    )\n\n            # Group by and mean (Lazy if Dask)\n            try:\n                # To remain lazy with Dask, we avoid operations that require knowing\n                # the result shape eagerly (like drop=True in where).\n                hours = np.arange(24)\n                results = []\n                for h in hours:\n                    # Masking instead of dropping to keep it lazy\n                    h_val = val.where(val.hour == h)\n                    h_agg = h_val.groupby(\"second_val\").mean(dim=self.time_col)\n                    h_agg = h_agg.expand_dims(hour=[h])\n                    results.append(h_agg)\n\n                self.aggregated = xr.concat(results, dim=\"hour\")\n                self.aggregated = self.aggregated.transpose(\"second_val\", \"hour\")\n\n            except Exception:\n                # Fallback to eager if something goes wrong with complex Xarray ops\n                df = val.to_dataframe(name=val.name).reset_index()\n                pivot = df.pivot_table(\n                    index=\"second_val\", columns=\"hour\", values=val.name, aggfunc=\"mean\"\n                )\n                self.aggregated = xr.DataArray(\n                    pivot.values,\n                    coords={\n                        \"second_val\": pivot.index.values,\n                        \"hour\": pivot.columns.values,\n                    },\n                    dims=[\"second_val\", \"hour\"],\n                    name=val.name,\n                )\n\n            self.aggregated = _update_history(self.aggregated, msg)\n\n        else:\n            # Fallback for Pandas DataFrame (backward compatibility)\n            df = self.data.copy()\n            df[self.time_col] = pd.to_datetime(df[self.time_col])\n            df[\"hour\"] = df[self.time_col].dt.hour\n\n            if self.second_dim == \"month\":\n                df[\"second_val\"] = df[self.time_col].dt.month\n                self.second_label = \"Month\"\n            elif self.second_dim == \"dayofweek\":\n                df[\"second_val\"] = df[self.time_col].dt.dayofweek\n                self.second_label = \"Day of Week\"\n            elif self.second_dim == \"date\":\n                df[\"second_val\"] = df[self.time_col].dt.date\n                self.second_label = \"Date\"\n            else:\n                df[\"second_val\"] = df[self.second_dim]\n                self.second_label = self.second_dim\n\n            if self.metric == \"bias\":\n                df[\"val\"] = df[self.mod_col] - df[self.obs_col]\n                metric_name = \"bias\"\n            elif self.metric == \"error\":\n                df[\"val\"] = np.abs(df[self.mod_col] - df[self.obs_col])\n                metric_name = \"error\"\n\n            pivot = df.pivot_table(\n                index=\"second_val\", columns=\"hour\", values=\"val\", aggfunc=\"mean\"\n            )\n            self.aggregated = xr.DataArray(\n                pivot.values,\n                coords={\n                    \"second_val\": pivot.index.values,\n                    \"hour\": pivot.columns.values,\n                },\n                dims=[\"second_val\", \"hour\"],\n                name=metric_name,\n            )\n\n    def plot(self, cmap: str = \"RdBu_r\", **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Generate the diurnal error heatmap (Track A: Static).\n\n        Parameters\n        ----------\n        cmap : str, optional\n            Colormap to use, by default \"RdBu_r\".\n        **kwargs : Any\n            Additional arguments passed to sns.heatmap.\n\n        Returns\n        -------\n        matplotlib.axes.Axes\n            The axes object.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # Assuming 'plot' is a DiurnalErrorPlot instance\n        &gt;&gt;&gt; ax = plot.plot(cmap=\"viridis\")\n        \"\"\"\n        # Compute the aggregated data for plotting\n        data_to_plot = self.aggregated\n        if hasattr(data_to_plot.data, \"dask\"):\n            data_to_plot = data_to_plot.compute()\n\n        # Convert to DataFrame for Seaborn\n        plot_df = data_to_plot.to_pandas()\n\n        sns.heatmap(\n            plot_df,\n            ax=self.ax,\n            cmap=cmap,\n            center=0 if self.metric == \"bias\" else None,\n            **kwargs,\n        )\n\n        self.ax.set_xlabel(\"Hour of Day\")\n        self.ax.set_ylabel(self.second_label)\n        self.ax.set_title(f\"Diurnal {self.metric.capitalize()}\")\n\n        return self.ax\n\n    def hvplot(self, cmap: str = \"RdBu_r\", **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Generate the diurnal error heatmap (Track B: Interactive).\n\n        Parameters\n        ----------\n        cmap : str, optional\n            Colormap to use, by default \"RdBu_r\".\n        **kwargs : Any\n            Additional arguments passed to hvplot.heatmap.\n\n        Returns\n        -------\n        holoviews.Element\n            The interactive HoloViews object.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # Assuming 'plot' is a DiurnalErrorPlot instance\n        &gt;&gt;&gt; interactive_plot = plot.hvplot()\n        \"\"\"\n        import hvplot.xarray  # noqa: F401\n\n        # Track B: Interactive\n        return self.aggregated.hvplot.heatmap(\n            x=\"hour\",\n            y=\"second_val\",\n            C=self.aggregated.name,\n            cmap=cmap,\n            title=f\"Diurnal {self.metric.capitalize()}\",\n            xlabel=\"Hour of Day\",\n            ylabel=self.second_label,\n            rasterize=True,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.__init__","title":"<code>__init__(data, obs_col, mod_col, *, time_col='time', second_dim='month', metric='bias', fig=None, ax=None, **kwargs)</code>","text":"<p>Initialize Diurnal Error Plot.</p>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.__init__--parameters","title":"Parameters","text":"<p>data : Any     Input data. Can be a pandas DataFrame, xarray DataArray,     xarray Dataset, or dask-backed object. obs_col : str     Column/variable name for observations. mod_col : str     Column/variable name for model values. time_col : str, optional     Dimension/column name for timestamp, by default \"time\". second_dim : str, optional     The second dimension for the heatmap ('month', 'dayofweek', 'date',     or a coordinate name), by default \"month\". metric : str, optional     The metric to plot ('bias' or 'error'), by default \"bias\". fig : Any, optional     Existing figure object, by default None. ax : Any, optional     Existing axes object, by default None. **kwargs : Any     Additional arguments passed to BasePlot.</p> Source code in <code>src/monet_plots/plots/diurnal_error.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    obs_col: str,\n    mod_col: str,\n    *,\n    time_col: str = \"time\",\n    second_dim: str = \"month\",\n    metric: str = \"bias\",\n    fig: Any | None = None,\n    ax: Any | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize Diurnal Error Plot.\n\n    Parameters\n    ----------\n    data : Any\n        Input data. Can be a pandas DataFrame, xarray DataArray,\n        xarray Dataset, or dask-backed object.\n    obs_col : str\n        Column/variable name for observations.\n    mod_col : str\n        Column/variable name for model values.\n    time_col : str, optional\n        Dimension/column name for timestamp, by default \"time\".\n    second_dim : str, optional\n        The second dimension for the heatmap ('month', 'dayofweek', 'date',\n        or a coordinate name), by default \"month\".\n    metric : str, optional\n        The metric to plot ('bias' or 'error'), by default \"bias\".\n    fig : Any, optional\n        Existing figure object, by default None.\n    ax : Any, optional\n        Existing axes object, by default None.\n    **kwargs : Any\n        Additional arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(fig=fig, ax=ax, **kwargs)\n\n    # Normalize data to Xarray if possible\n    self.data = normalize_data(data)\n    self.obs_col = obs_col\n    self.mod_col = mod_col\n    self.time_col = time_col\n    self.second_dim = second_dim\n    self.metric = metric\n\n    # Prepare the calculation\n    self._calculate_metric()\n</code></pre>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.hvplot","title":"<code>hvplot(cmap='RdBu_r', **kwargs)</code>","text":"<p>Generate the diurnal error heatmap (Track B: Interactive).</p>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.hvplot--parameters","title":"Parameters","text":"<p>cmap : str, optional     Colormap to use, by default \"RdBu_r\". **kwargs : Any     Additional arguments passed to hvplot.heatmap.</p>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.hvplot--returns","title":"Returns","text":"<p>holoviews.Element     The interactive HoloViews object.</p>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.hvplot--examples","title":"Examples","text":"Source code in <code>src/monet_plots/plots/diurnal_error.py</code> <pre><code>def hvplot(self, cmap: str = \"RdBu_r\", **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Generate the diurnal error heatmap (Track B: Interactive).\n\n    Parameters\n    ----------\n    cmap : str, optional\n        Colormap to use, by default \"RdBu_r\".\n    **kwargs : Any\n        Additional arguments passed to hvplot.heatmap.\n\n    Returns\n    -------\n    holoviews.Element\n        The interactive HoloViews object.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Assuming 'plot' is a DiurnalErrorPlot instance\n    &gt;&gt;&gt; interactive_plot = plot.hvplot()\n    \"\"\"\n    import hvplot.xarray  # noqa: F401\n\n    # Track B: Interactive\n    return self.aggregated.hvplot.heatmap(\n        x=\"hour\",\n        y=\"second_val\",\n        C=self.aggregated.name,\n        cmap=cmap,\n        title=f\"Diurnal {self.metric.capitalize()}\",\n        xlabel=\"Hour of Day\",\n        ylabel=self.second_label,\n        rasterize=True,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.hvplot--assuming-plot-is-a-diurnalerrorplot-instance","title":"Assuming 'plot' is a DiurnalErrorPlot instance","text":"<p>interactive_plot = plot.hvplot()</p>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.plot","title":"<code>plot(cmap='RdBu_r', **kwargs)</code>","text":"<p>Generate the diurnal error heatmap (Track A: Static).</p>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.plot--parameters","title":"Parameters","text":"<p>cmap : str, optional     Colormap to use, by default \"RdBu_r\". **kwargs : Any     Additional arguments passed to sns.heatmap.</p>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.plot--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The axes object.</p>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.plot--examples","title":"Examples","text":"Source code in <code>src/monet_plots/plots/diurnal_error.py</code> <pre><code>def plot(self, cmap: str = \"RdBu_r\", **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Generate the diurnal error heatmap (Track A: Static).\n\n    Parameters\n    ----------\n    cmap : str, optional\n        Colormap to use, by default \"RdBu_r\".\n    **kwargs : Any\n        Additional arguments passed to sns.heatmap.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The axes object.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Assuming 'plot' is a DiurnalErrorPlot instance\n    &gt;&gt;&gt; ax = plot.plot(cmap=\"viridis\")\n    \"\"\"\n    # Compute the aggregated data for plotting\n    data_to_plot = self.aggregated\n    if hasattr(data_to_plot.data, \"dask\"):\n        data_to_plot = data_to_plot.compute()\n\n    # Convert to DataFrame for Seaborn\n    plot_df = data_to_plot.to_pandas()\n\n    sns.heatmap(\n        plot_df,\n        ax=self.ax,\n        cmap=cmap,\n        center=0 if self.metric == \"bias\" else None,\n        **kwargs,\n    )\n\n    self.ax.set_xlabel(\"Hour of Day\")\n    self.ax.set_ylabel(self.second_label)\n    self.ax.set_title(f\"Diurnal {self.metric.capitalize()}\")\n\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.DiurnalErrorPlot.plot--assuming-plot-is-a-diurnalerrorplot-instance","title":"Assuming 'plot' is a DiurnalErrorPlot instance","text":"<p>ax = plot.plot(cmap=\"viridis\")</p>"},{"location":"api/#monet_plots.plots.FacetGridPlot","title":"<code>FacetGridPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Creates a facet grid plot.</p> <p>This class creates a facet grid plot using seaborn's FacetGrid.</p> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>class FacetGridPlot(BasePlot):\n    \"\"\"Creates a facet grid plot.\n\n    This class creates a facet grid plot using seaborn's FacetGrid.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        row: str | None = None,\n        col: str | None = None,\n        hue: str | None = None,\n        col_wrap: int | None = None,\n        height: float = 3,\n        aspect: float = 1,\n        subplot_kws: dict[str, Any] | None = None,\n        style: str | None = \"wiley\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initializes the facet grid.\n\n        Args:\n            data: The data to plot.\n            row (str, optional): Variable to map to row facets. Defaults to None\n            col (str, optional): Variable to map to column facets. Defaults to None\n            hue (str, optional): Variable to map to color mapping. Defaults to None\n            col_wrap (int, optional): Number of columns before wrapping. Defaults to None\n            height (float, optional): Height of each facet in inches. Defaults to 3\n            aspect (float, optional): Aspect ratio of each facet. Defaults to 1\n            subplot_kws (dict, optional): Keyword arguments for subplots (e.g. projection).\n            style (str, optional): Style name to apply. Defaults to 'wiley'.\n            **kwargs: Additional keyword arguments to pass to `FacetGrid`.\n        \"\"\"\n        # Apply style\n        if style:\n            set_style(style)\n\n        # Store facet parameters\n        self.row = row\n        self.col = col\n        self.hue = hue\n        self.col_wrap = col_wrap\n        self.height = height\n        self.aspect = aspect\n\n        # Convert data to pandas DataFrame and ensure coordinates are columns\n        self.raw_data = data\n        self.data = to_dataframe(data).reset_index()\n\n        # Create the FacetGrid (this creates its own figure)\n        self.grid = sns.FacetGrid(\n            self.data,\n            row=self.row,\n            col=self.col,\n            hue=self.hue,\n            col_wrap=self.col_wrap,\n            height=self.height,\n            aspect=self.aspect,\n            subplot_kws=subplot_kws,\n            **kwargs,\n        )\n\n        # Initialize BasePlot with the figure and first axes from the grid\n        axes = self.grid.axes.flatten()\n        super().__init__(fig=self.grid.fig, ax=axes[0], style=None)\n\n        # For compatibility with tests, also store as 'g'\n        self.g = self.grid\n\n    def map_dataframe(self, plot_func: Callable, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Maps a plotting function to the facet grid.\n\n        Args:\n            plot_func (function): The plotting function to map.\n            *args: Positional arguments to pass to the plotting function.\n            **kwargs: Keyword arguments to pass to the plotting function.\n        \"\"\"\n        self.grid.map_dataframe(plot_func, *args, **kwargs)\n\n    def set_titles(self, *args, **kwargs):\n        \"\"\"Sets the titles of the facet grid.\n\n        Args:\n            *args: Positional arguments to pass to `set_titles`.\n            **kwargs: Keyword arguments to pass to `set_titles`.\n        \"\"\"\n        self.grid.set_titles(*args, **kwargs)\n\n    def save(self, filename, **kwargs):\n        \"\"\"Saves the plot to a file.\n\n        Args:\n            filename (str): The name of the file to save the plot to.\n            **kwargs: Additional keyword arguments to pass to `savefig`.\n        \"\"\"\n        self.fig.savefig(filename, **kwargs)\n\n    def plot(self, plot_func=None, *args, **kwargs):\n        \"\"\"Plots the data using the FacetGrid.\n\n        Args:\n            plot_func (function, optional): The plotting function to use.\n            *args: Positional arguments to pass to the plotting function.\n            **kwargs: Keyword arguments to pass to the plotting function.\n        \"\"\"\n        if plot_func is not None:\n            self.grid.map(plot_func, *args, **kwargs)\n\n    def close(self):\n        \"\"\"Closes the plot.\"\"\"\n        plt.close(self.fig)\n</code></pre>"},{"location":"api/#monet_plots.plots.FacetGridPlot.__init__","title":"<code>__init__(data, row=None, col=None, hue=None, col_wrap=None, height=3, aspect=1, subplot_kws=None, style='wiley', **kwargs)</code>","text":"<p>Initializes the facet grid.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to plot.</p> required <code>row</code> <code>str</code> <p>Variable to map to row facets. Defaults to None</p> <code>None</code> <code>col</code> <code>str</code> <p>Variable to map to column facets. Defaults to None</p> <code>None</code> <code>hue</code> <code>str</code> <p>Variable to map to color mapping. Defaults to None</p> <code>None</code> <code>col_wrap</code> <code>int</code> <p>Number of columns before wrapping. Defaults to None</p> <code>None</code> <code>height</code> <code>float</code> <p>Height of each facet in inches. Defaults to 3</p> <code>3</code> <code>aspect</code> <code>float</code> <p>Aspect ratio of each facet. Defaults to 1</p> <code>1</code> <code>subplot_kws</code> <code>dict</code> <p>Keyword arguments for subplots (e.g. projection).</p> <code>None</code> <code>style</code> <code>str</code> <p>Style name to apply. Defaults to 'wiley'.</p> <code>'wiley'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to <code>FacetGrid</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    row: str | None = None,\n    col: str | None = None,\n    hue: str | None = None,\n    col_wrap: int | None = None,\n    height: float = 3,\n    aspect: float = 1,\n    subplot_kws: dict[str, Any] | None = None,\n    style: str | None = \"wiley\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initializes the facet grid.\n\n    Args:\n        data: The data to plot.\n        row (str, optional): Variable to map to row facets. Defaults to None\n        col (str, optional): Variable to map to column facets. Defaults to None\n        hue (str, optional): Variable to map to color mapping. Defaults to None\n        col_wrap (int, optional): Number of columns before wrapping. Defaults to None\n        height (float, optional): Height of each facet in inches. Defaults to 3\n        aspect (float, optional): Aspect ratio of each facet. Defaults to 1\n        subplot_kws (dict, optional): Keyword arguments for subplots (e.g. projection).\n        style (str, optional): Style name to apply. Defaults to 'wiley'.\n        **kwargs: Additional keyword arguments to pass to `FacetGrid`.\n    \"\"\"\n    # Apply style\n    if style:\n        set_style(style)\n\n    # Store facet parameters\n    self.row = row\n    self.col = col\n    self.hue = hue\n    self.col_wrap = col_wrap\n    self.height = height\n    self.aspect = aspect\n\n    # Convert data to pandas DataFrame and ensure coordinates are columns\n    self.raw_data = data\n    self.data = to_dataframe(data).reset_index()\n\n    # Create the FacetGrid (this creates its own figure)\n    self.grid = sns.FacetGrid(\n        self.data,\n        row=self.row,\n        col=self.col,\n        hue=self.hue,\n        col_wrap=self.col_wrap,\n        height=self.height,\n        aspect=self.aspect,\n        subplot_kws=subplot_kws,\n        **kwargs,\n    )\n\n    # Initialize BasePlot with the figure and first axes from the grid\n    axes = self.grid.axes.flatten()\n    super().__init__(fig=self.grid.fig, ax=axes[0], style=None)\n\n    # For compatibility with tests, also store as 'g'\n    self.g = self.grid\n</code></pre>"},{"location":"api/#monet_plots.plots.FacetGridPlot.close","title":"<code>close()</code>","text":"<p>Closes the plot.</p> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def close(self):\n    \"\"\"Closes the plot.\"\"\"\n    plt.close(self.fig)\n</code></pre>"},{"location":"api/#monet_plots.plots.FacetGridPlot.map_dataframe","title":"<code>map_dataframe(plot_func, *args, **kwargs)</code>","text":"<p>Maps a plotting function to the facet grid.</p> <p>Parameters:</p> Name Type Description Default <code>plot_func</code> <code>function</code> <p>The plotting function to map.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the plotting function.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the plotting function.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def map_dataframe(self, plot_func: Callable, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Maps a plotting function to the facet grid.\n\n    Args:\n        plot_func (function): The plotting function to map.\n        *args: Positional arguments to pass to the plotting function.\n        **kwargs: Keyword arguments to pass to the plotting function.\n    \"\"\"\n    self.grid.map_dataframe(plot_func, *args, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.FacetGridPlot.plot","title":"<code>plot(plot_func=None, *args, **kwargs)</code>","text":"<p>Plots the data using the FacetGrid.</p> <p>Parameters:</p> Name Type Description Default <code>plot_func</code> <code>function</code> <p>The plotting function to use.</p> <code>None</code> <code>*args</code> <p>Positional arguments to pass to the plotting function.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to pass to the plotting function.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def plot(self, plot_func=None, *args, **kwargs):\n    \"\"\"Plots the data using the FacetGrid.\n\n    Args:\n        plot_func (function, optional): The plotting function to use.\n        *args: Positional arguments to pass to the plotting function.\n        **kwargs: Keyword arguments to pass to the plotting function.\n    \"\"\"\n    if plot_func is not None:\n        self.grid.map(plot_func, *args, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.FacetGridPlot.save","title":"<code>save(filename, **kwargs)</code>","text":"<p>Saves the plot to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save the plot to.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to <code>savefig</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def save(self, filename, **kwargs):\n    \"\"\"Saves the plot to a file.\n\n    Args:\n        filename (str): The name of the file to save the plot to.\n        **kwargs: Additional keyword arguments to pass to `savefig`.\n    \"\"\"\n    self.fig.savefig(filename, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.FacetGridPlot.set_titles","title":"<code>set_titles(*args, **kwargs)</code>","text":"<p>Sets the titles of the facet grid.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments to pass to <code>set_titles</code>.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to pass to <code>set_titles</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def set_titles(self, *args, **kwargs):\n    \"\"\"Sets the titles of the facet grid.\n\n    Args:\n        *args: Positional arguments to pass to `set_titles`.\n        **kwargs: Keyword arguments to pass to `set_titles`.\n    \"\"\"\n    self.grid.set_titles(*args, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.FingerprintPlot","title":"<code>FingerprintPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Fingerprint plot.</p> <p>Displays a variable as a heatmap across two different temporal scales, such as hour of day vs. day of year, to reveal periodic patterns.</p> Source code in <code>src/monet_plots/plots/fingerprint.py</code> <pre><code>class FingerprintPlot(BasePlot):\n    \"\"\"Fingerprint plot.\n\n    Displays a variable as a heatmap across two different temporal scales,\n    such as hour of day vs. day of year, to reveal periodic patterns.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        val_col: str,\n        *,\n        time_col: str = \"time\",\n        x_scale: str = \"hour\",\n        y_scale: str = \"dayofyear\",\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize Fingerprint Plot.\n\n        Args:\n            data: Input data (DataFrame, DataArray, etc.).\n            val_col: Column name of the value to plot.\n            time_col: Column name for timestamp.\n            x_scale: Temporal scale for the x-axis ('hour', 'month', 'dayofweek', etc.).\n            y_scale: Temporal scale for the y-axis ('dayofyear', 'year', 'week', etc.).\n            **kwargs: Arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.df = to_dataframe(data).copy()\n        self.val_col = val_col\n        self.time_col = time_col\n        self.x_scale = x_scale\n        self.y_scale = y_scale\n\n        # Ensure time_col is datetime\n        self.df[self.time_col] = pd.to_datetime(self.df[self.time_col])\n\n        self._extract_scale(self.x_scale, \"x_val\")\n        self._extract_scale(self.y_scale, \"y_val\")\n\n    def _extract_scale(self, scale: str, target_col: str):\n        \"\"\"Extract temporal features from datetime.\"\"\"\n        t = self.df[self.time_col].dt\n        if scale == \"hour\":\n            self.df[target_col] = t.hour\n        elif scale == \"month\":\n            self.df[target_col] = t.month\n        elif scale == \"dayofweek\":\n            self.df[target_col] = t.dayofweek\n        elif scale == \"dayofyear\":\n            self.df[target_col] = t.dayofyear\n        elif scale == \"week\":\n            self.df[target_col] = t.isocalendar().week\n        elif scale == \"year\":\n            self.df[target_col] = t.year\n        elif scale == \"date\":\n            self.df[target_col] = t.date\n        else:\n            # Try to use it as a direct column if not a known scale\n            if scale in self.df.columns:\n                self.df[target_col] = self.df[scale]\n            else:\n                raise ValueError(f\"Unknown temporal scale: {scale}\")\n\n    def plot(self, cmap: str = \"viridis\", **kwargs):\n        \"\"\"Generate the fingerprint heatmap.\"\"\"\n        pivot_df = self.df.pivot_table(\n            index=\"y_val\", columns=\"x_val\", values=self.val_col, aggfunc=\"mean\"\n        )\n\n        sns.heatmap(pivot_df, ax=self.ax, cmap=cmap, **kwargs)\n\n        self.ax.set_xlabel(self.x_scale.capitalize())\n        self.ax.set_ylabel(self.y_scale.capitalize())\n        self.ax.set_title(f\"Fingerprint: {self.val_col}\")\n\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.FingerprintPlot.__init__","title":"<code>__init__(data, val_col, *, time_col='time', x_scale='hour', y_scale='dayofyear', **kwargs)</code>","text":"<p>Initialize Fingerprint Plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data (DataFrame, DataArray, etc.).</p> required <code>val_col</code> <code>str</code> <p>Column name of the value to plot.</p> required <code>time_col</code> <code>str</code> <p>Column name for timestamp.</p> <code>'time'</code> <code>x_scale</code> <code>str</code> <p>Temporal scale for the x-axis ('hour', 'month', 'dayofweek', etc.).</p> <code>'hour'</code> <code>y_scale</code> <code>str</code> <p>Temporal scale for the y-axis ('dayofyear', 'year', 'week', etc.).</p> <code>'dayofyear'</code> <code>**kwargs</code> <p>Arguments passed to BasePlot.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/fingerprint.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    val_col: str,\n    *,\n    time_col: str = \"time\",\n    x_scale: str = \"hour\",\n    y_scale: str = \"dayofyear\",\n    **kwargs,\n):\n    \"\"\"\n    Initialize Fingerprint Plot.\n\n    Args:\n        data: Input data (DataFrame, DataArray, etc.).\n        val_col: Column name of the value to plot.\n        time_col: Column name for timestamp.\n        x_scale: Temporal scale for the x-axis ('hour', 'month', 'dayofweek', etc.).\n        y_scale: Temporal scale for the y-axis ('dayofyear', 'year', 'week', etc.).\n        **kwargs: Arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.df = to_dataframe(data).copy()\n    self.val_col = val_col\n    self.time_col = time_col\n    self.x_scale = x_scale\n    self.y_scale = y_scale\n\n    # Ensure time_col is datetime\n    self.df[self.time_col] = pd.to_datetime(self.df[self.time_col])\n\n    self._extract_scale(self.x_scale, \"x_val\")\n    self._extract_scale(self.y_scale, \"y_val\")\n</code></pre>"},{"location":"api/#monet_plots.plots.FingerprintPlot.plot","title":"<code>plot(cmap='viridis', **kwargs)</code>","text":"<p>Generate the fingerprint heatmap.</p> Source code in <code>src/monet_plots/plots/fingerprint.py</code> <pre><code>def plot(self, cmap: str = \"viridis\", **kwargs):\n    \"\"\"Generate the fingerprint heatmap.\"\"\"\n    pivot_df = self.df.pivot_table(\n        index=\"y_val\", columns=\"x_val\", values=self.val_col, aggfunc=\"mean\"\n    )\n\n    sns.heatmap(pivot_df, ax=self.ax, cmap=cmap, **kwargs)\n\n    self.ax.set_xlabel(self.x_scale.capitalize())\n    self.ax.set_ylabel(self.y_scale.capitalize())\n    self.ax.set_title(f\"Fingerprint: {self.val_col}\")\n\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.KDEPlot","title":"<code>KDEPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a kernel density estimate plot.</p> <p>This plot shows the distribution of a single variable.</p> Source code in <code>src/monet_plots/plots/kde.py</code> <pre><code>class KDEPlot(BasePlot):\n    \"\"\"Create a kernel density estimate plot.\n\n    This plot shows the distribution of a single variable.\n    \"\"\"\n\n    def __init__(self, df, x, y, title=None, label=None, *args, **kwargs):\n        \"\"\"\n        Initialize the plot with data and plot settings.\n\n        Args:\n            df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with the data to plot.\n            x (str): Column name for the x-axis.\n            y (str): Column name for the y-axis.\n            title (str, optional): Title for the plot.\n            label (str, optional): Label for the plot.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.df = df\n        self.x = x\n        self.y = y\n        self.title = title\n        self.label = label\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the KDE plot.\"\"\"\n        with sns.axes_style(\"ticks\"):\n            self.ax = sns.kdeplot(\n                data=self.df, x=self.x, y=self.y, ax=self.ax, label=self.label, **kwargs\n            )\n            if self.title:\n                self.ax.set_title(self.title)\n            sns.despine()\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.KDEPlot.__init__","title":"<code>__init__(df, x, y, title=None, label=None, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and plot settings.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>DataFrame with the data to plot.</p> required <code>x</code> <code>str</code> <p>Column name for the x-axis.</p> required <code>y</code> <code>str</code> <p>Column name for the y-axis.</p> required <code>title</code> <code>str</code> <p>Title for the plot.</p> <code>None</code> <code>label</code> <code>str</code> <p>Label for the plot.</p> <code>None</code> Source code in <code>src/monet_plots/plots/kde.py</code> <pre><code>def __init__(self, df, x, y, title=None, label=None, *args, **kwargs):\n    \"\"\"\n    Initialize the plot with data and plot settings.\n\n    Args:\n        df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with the data to plot.\n        x (str): Column name for the x-axis.\n        y (str): Column name for the y-axis.\n        title (str, optional): Title for the plot.\n        label (str, optional): Label for the plot.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.df = df\n    self.x = x\n    self.y = y\n    self.title = title\n    self.label = label\n</code></pre>"},{"location":"api/#monet_plots.plots.KDEPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the KDE plot.</p> Source code in <code>src/monet_plots/plots/kde.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the KDE plot.\"\"\"\n    with sns.axes_style(\"ticks\"):\n        self.ax = sns.kdeplot(\n            data=self.df, x=self.x, y=self.y, ax=self.ax, label=self.label, **kwargs\n        )\n        if self.title:\n            self.ax.set_title(self.title)\n        sns.despine()\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.PerformanceDiagramPlot","title":"<code>PerformanceDiagramPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Performance Diagram Plot (Roebber).</p> <p>Visualizes the relationship between Probability of Detection (POD), Success Ratio (SR), Critical Success Index (CSI), and Bias.</p> <p>Functional Requirements: 1. Plot POD (y-axis) vs Success Ratio (x-axis). 2. Draw background isolines for CSI and Bias. 3. Support input as pre-calculated metrics or contingency table counts. 4. Handle multiple models/configurations via grouping.</p> <p>Edge Cases: - SR or POD being 0 or 1 (division by zero in bias/CSI calculations). - Empty DataFrame. - Missing required columns.</p> Source code in <code>src/monet_plots/plots/performance_diagram.py</code> <pre><code>class PerformanceDiagramPlot(BasePlot):\n    \"\"\"\n    Performance Diagram Plot (Roebber).\n\n    Visualizes the relationship between Probability of Detection (POD),\n    Success Ratio (SR),\n    Critical Success Index (CSI), and Bias.\n\n    Functional Requirements:\n    1. Plot POD (y-axis) vs Success Ratio (x-axis).\n    2. Draw background isolines for CSI and Bias.\n    3. Support input as pre-calculated metrics or contingency table counts.\n    4. Handle multiple models/configurations via grouping.\n\n    Edge Cases:\n    - SR or POD being 0 or 1 (division by zero in bias/CSI calculations).\n    - Empty DataFrame.\n    - Missing required columns.\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        x_col: str = \"success_ratio\",\n        y_col: str = \"pod\",\n        counts_cols: Optional[List[str]] = None,\n        label_col: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data.\n            x_col (str): Column name for Success Ratio (1-FAR).\n            y_col (str): Column name for POD.\n            counts_cols (list, optional): List of columns [hits, misses, fa, cn]\n                                        to calculate metrics if x_col/y_col not present.\n            label_col (str, optional): Column to use for legend labels.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        # TDD Anchor: Test validation raises error on missing cols\n        self._validate_inputs(df, x_col, y_col, counts_cols)\n\n        # Data Preparation\n        df_plot = self._prepare_data(df, x_col, y_col, counts_cols)\n\n        # Plot Background (Isolines)\n        self._draw_background()\n\n        # Plot Data\n        # TDD Anchor: Verify scatter points match input data coordinates\n        if label_col:\n            for name, group in df_plot.groupby(label_col):\n                self.ax.plot(\n                    group[x_col],\n                    group[y_col],\n                    marker=\"o\",\n                    label=name,\n                    linestyle=\"none\",\n                    **kwargs,\n                )\n            self.ax.legend(loc=\"best\")\n        else:\n            self.ax.plot(\n                df_plot[x_col], df_plot[y_col], marker=\"o\", linestyle=\"none\", **kwargs\n            )\n\n        # Formatting\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 1)\n        self.ax.set_xlabel(\"Success Ratio (1-FAR)\")\n        self.ax.set_ylabel(\"Probability of Detection (POD)\")\n        self.ax.set_aspect(\"equal\")\n\n    def _validate_inputs(self, data, x, y, counts):\n        \"\"\"Validates input dataframe structure.\"\"\"\n        if counts:\n            validate_dataframe(data, required_columns=counts)\n        else:\n            validate_dataframe(data, required_columns=[x, y])\n\n    def _prepare_data(self, data, x, y, counts):\n        \"\"\"\n        Calculates metrics if counts provided, otherwise returns subset.\n        TDD Anchor: Test calculation logic: SR = hits/(hits+fa), POD = hits/(hits+miss).\n        \"\"\"\n        df = data.copy()\n        if counts:\n            hits_col, misses_col, fa_col, cn_col = counts\n            df[x] = compute_success_ratio(df[hits_col], df[fa_col])\n            df[y] = compute_pod(df[hits_col], df[misses_col])\n        return df\n\n    def _draw_background(self):\n        \"\"\"\n        Draws CSI and Bias isolines.\n\n        Pseudocode:\n        1. Create meshgrid for x (SR) and y (POD) from 0.01 to 1.\n        2. Calculate CSI = 1 / (1/SR + 1/POD - 1).\n        3. Calculate Bias = POD / SR.\n        4. Contour plot CSI (dashed).\n        5. Contour plot Bias (dotted).\n        6. Label contours.\n        \"\"\"\n        # Avoid division by zero at boundaries\n        xx, yy = np.meshgrid(np.linspace(0.01, 0.99, 50), np.linspace(0.01, 0.99, 50))\n        csi = (xx * yy) / (xx + yy - xx * yy)\n        bias = yy / xx\n\n        # CSI contours (dashed, lightgray)\n        cs_csi = self.ax.contour(\n            xx,\n            yy,\n            csi,\n            levels=np.arange(0.1, 0.95, 0.1),\n            colors=\"lightgray\",\n            linestyles=\"--\",\n            alpha=0.6,\n        )\n        self.ax.clabel(cs_csi, inline=True, fontsize=8, fmt=\"%.1f\")\n\n        # Bias contours (dotted, darkgray)\n        cs_bias = self.ax.contour(\n            xx,\n            yy,\n            bias,\n            levels=[0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0],\n            colors=\"darkgray\",\n            linestyles=\":\",\n            alpha=0.6,\n        )\n        self.ax.clabel(cs_bias, inline=True, fontsize=8, fmt=\"%.1f\")\n\n        # Perfect forecast line\n        self.ax.plot([0.01, 0.99], [0.01, 0.99], \"k-\", linewidth=1.5, alpha=0.8)\n</code></pre>"},{"location":"api/#monet_plots.plots.PerformanceDiagramPlot.plot","title":"<code>plot(data, x_col='success_ratio', y_col='pod', counts_cols=None, label_col=None, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Input data.</p> required <code>x_col</code> <code>str</code> <p>Column name for Success Ratio (1-FAR).</p> <code>'success_ratio'</code> <code>y_col</code> <code>str</code> <p>Column name for POD.</p> <code>'pod'</code> <code>counts_cols</code> <code>list</code> <p>List of columns [hits, misses, fa, cn]                         to calculate metrics if x_col/y_col not present.</p> <code>None</code> <code>label_col</code> <code>str</code> <p>Column to use for legend labels.</p> <code>None</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/performance_diagram.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    x_col: str = \"success_ratio\",\n    y_col: str = \"pod\",\n    counts_cols: Optional[List[str]] = None,\n    label_col: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data.\n        x_col (str): Column name for Success Ratio (1-FAR).\n        y_col (str): Column name for POD.\n        counts_cols (list, optional): List of columns [hits, misses, fa, cn]\n                                    to calculate metrics if x_col/y_col not present.\n        label_col (str, optional): Column to use for legend labels.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    # TDD Anchor: Test validation raises error on missing cols\n    self._validate_inputs(df, x_col, y_col, counts_cols)\n\n    # Data Preparation\n    df_plot = self._prepare_data(df, x_col, y_col, counts_cols)\n\n    # Plot Background (Isolines)\n    self._draw_background()\n\n    # Plot Data\n    # TDD Anchor: Verify scatter points match input data coordinates\n    if label_col:\n        for name, group in df_plot.groupby(label_col):\n            self.ax.plot(\n                group[x_col],\n                group[y_col],\n                marker=\"o\",\n                label=name,\n                linestyle=\"none\",\n                **kwargs,\n            )\n        self.ax.legend(loc=\"best\")\n    else:\n        self.ax.plot(\n            df_plot[x_col], df_plot[y_col], marker=\"o\", linestyle=\"none\", **kwargs\n        )\n\n    # Formatting\n    self.ax.set_xlim(0, 1)\n    self.ax.set_ylim(0, 1)\n    self.ax.set_xlabel(\"Success Ratio (1-FAR)\")\n    self.ax.set_ylabel(\"Probability of Detection (POD)\")\n    self.ax.set_aspect(\"equal\")\n</code></pre>"},{"location":"api/#monet_plots.plots.ProfilePlot","title":"<code>ProfilePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Profile or cross-section plot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>class ProfilePlot(BasePlot):\n    \"\"\"Profile or cross-section plot.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        x: np.ndarray,\n        y: np.ndarray,\n        z: np.ndarray | None = None,\n        alt_adjust: float | None = None,\n        **kwargs: t.Any,\n    ) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        x\n            X-axis data.\n        y\n            Y-axis data.\n        z\n            Optional Z-axis data for contour plots.\n        alt_adjust\n            Value to subtract from the y-axis data for altitude adjustment.\n        **kwargs\n            Keyword arguments passed to the parent class.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.x = x\n        if alt_adjust is not None:\n            self.y = y - alt_adjust\n        else:\n            self.y = y\n        self.z = z\n\n    def plot(self, **kwargs: t.Any) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        **kwargs\n            Keyword arguments passed to `matplotlib.pyplot.plot` or\n            `matplotlib.pyplot.contourf`.\n        \"\"\"\n        if self.ax is None:\n            if self.fig is None:\n                self.fig = plt.figure()\n            self.ax = self.fig.add_subplot()\n\n        if self.z is not None:\n            self.ax.contourf(self.x, self.y, self.z, **kwargs)\n        else:\n            self.ax.plot(self.x, self.y, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.ProfilePlot.__init__","title":"<code>__init__(*, x, y, z=None, alt_adjust=None, **kwargs)</code>","text":""},{"location":"api/#monet_plots.plots.ProfilePlot.__init__--parameters","title":"Parameters","text":"<p>x     X-axis data. y     Y-axis data. z     Optional Z-axis data for contour plots. alt_adjust     Value to subtract from the y-axis data for altitude adjustment. **kwargs     Keyword arguments passed to the parent class.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def __init__(\n    self,\n    *,\n    x: np.ndarray,\n    y: np.ndarray,\n    z: np.ndarray | None = None,\n    alt_adjust: float | None = None,\n    **kwargs: t.Any,\n) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    x\n        X-axis data.\n    y\n        Y-axis data.\n    z\n        Optional Z-axis data for contour plots.\n    alt_adjust\n        Value to subtract from the y-axis data for altitude adjustment.\n    **kwargs\n        Keyword arguments passed to the parent class.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.x = x\n    if alt_adjust is not None:\n        self.y = y - alt_adjust\n    else:\n        self.y = y\n    self.z = z\n</code></pre>"},{"location":"api/#monet_plots.plots.ProfilePlot.plot","title":"<code>plot(**kwargs)</code>","text":""},{"location":"api/#monet_plots.plots.ProfilePlot.plot--parameters","title":"Parameters","text":"<p>**kwargs     Keyword arguments passed to <code>matplotlib.pyplot.plot</code> or     <code>matplotlib.pyplot.contourf</code>.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def plot(self, **kwargs: t.Any) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    **kwargs\n        Keyword arguments passed to `matplotlib.pyplot.plot` or\n        `matplotlib.pyplot.contourf`.\n    \"\"\"\n    if self.ax is None:\n        if self.fig is None:\n            self.fig = plt.figure()\n        self.ax = self.fig.add_subplot()\n\n    if self.z is not None:\n        self.ax.contourf(self.x, self.y, self.z, **kwargs)\n    else:\n        self.ax.plot(self.x, self.y, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.ROCCurvePlot","title":"<code>ROCCurvePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Receiver Operating Characteristic (ROC) Curve Plot.</p> <p>Visualizes the trade-off between Probability of Detection (POD) and Probability of False Detection (POFD).</p> <p>Functional Requirements: 1. Plot POD (y-axis) vs POFD (x-axis). 2. Draw diagonal \"no skill\" line (0,0) to (1,1). 3. Calculate and display Area Under Curve (AUC) in legend. 4. Support multiple models/curves via grouping.</p> <p>Edge Cases: - Non-monotonic data points (should sort by threshold/prob). - Single point provided (cannot calculate AUC properly, return NaN or handle gracefully). - Missing columns.</p> Source code in <code>src/monet_plots/plots/roc_curve.py</code> <pre><code>class ROCCurvePlot(BasePlot):\n    \"\"\"\n    Receiver Operating Characteristic (ROC) Curve Plot.\n\n    Visualizes the trade-off between Probability of Detection (POD) and\n    Probability of False Detection (POFD).\n\n    Functional Requirements:\n    1. Plot POD (y-axis) vs POFD (x-axis).\n    2. Draw diagonal \"no skill\" line (0,0) to (1,1).\n    3. Calculate and display Area Under Curve (AUC) in legend.\n    4. Support multiple models/curves via grouping.\n\n    Edge Cases:\n    - Non-monotonic data points (should sort by threshold/prob).\n    - Single point provided (cannot calculate AUC properly, return NaN or handle gracefully).\n    - Missing columns.\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        x_col: str = \"pofd\",\n        y_col: str = \"pod\",\n        label_col: Optional[str] = None,\n        show_auc: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data containing ROC points.\n            x_col (str): Column name for POFD (False Alarm Rate).\n            y_col (str): Column name for POD (Hit Rate).\n            label_col (str, optional): Column for grouping different curves.\n            show_auc (bool): Whether to calculate and append AUC to labels.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        # TDD Anchor: Test validation raises error on missing cols\n        validate_dataframe(df, required_columns=[x_col, y_col])\n\n        # Draw No Skill Line\n        self.ax.plot([0, 1], [0, 1], \"k--\", label=\"No Skill\", alpha=0.5)\n        self.ax.grid(True, alpha=0.3)\n\n        if label_col:\n            groups = df.groupby(label_col)\n            for name, group in groups:\n                self._plot_single_curve(\n                    group, x_col, y_col, label=str(name), show_auc=show_auc, **kwargs\n                )\n            self.ax.legend(loc=\"lower right\")\n        else:\n            self._plot_single_curve(\n                df, x_col, y_col, label=\"Model\", show_auc=show_auc, **kwargs\n            )\n\n        # Formatting\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 1)\n        self.ax.set_xlabel(\"Probability of False Detection (POFD)\")\n        self.ax.set_ylabel(\"Probability of Detection (POD)\")\n        self.ax.set_aspect(\"equal\")\n\n    def _plot_single_curve(self, df, x_col, y_col, label, show_auc, **kwargs):\n        \"\"\"\n        Helper to plot a single ROC curve and calc AUC.\n\n        Pseudocode:\n        1. Sort df by x_col (POFD) ascending.\n        2. Get x (POFD) and y (POD) arrays.\n        3. If show_auc:\n            auc = trapz(y, x)\n            label += f\" (AUC={auc:.3f})\"\n        4. self.ax.plot(x, y, label=label, **kwargs)\n        \"\"\"\n        # TDD Anchor: Test AUC calculation against sklearn.metrics.auc or manual known\n        # values.\n        # TDD Anchor: Ensure sorting is applied correctly.\n\n        df_sorted = df.sort_values(by=x_col).dropna(subset=[x_col, y_col])\n        x = df_sorted[x_col].values\n        y = df_sorted[y_col].values\n\n        auc_str = \"\"\n        if len(x) &gt;= 2 and show_auc:\n            auc = compute_auc(x, y)\n            auc_str = f\" (AUC={auc:.3f})\"\n\n        full_label = label + auc_str\n        self.ax.plot(x, y, label=full_label, **kwargs)\n        self.ax.fill_between(x, 0, y, alpha=0.2, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.ROCCurvePlot.plot","title":"<code>plot(data, x_col='pofd', y_col='pod', label_col=None, show_auc=True, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Input data containing ROC points.</p> required <code>x_col</code> <code>str</code> <p>Column name for POFD (False Alarm Rate).</p> <code>'pofd'</code> <code>y_col</code> <code>str</code> <p>Column name for POD (Hit Rate).</p> <code>'pod'</code> <code>label_col</code> <code>str</code> <p>Column for grouping different curves.</p> <code>None</code> <code>show_auc</code> <code>bool</code> <p>Whether to calculate and append AUC to labels.</p> <code>True</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/roc_curve.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    x_col: str = \"pofd\",\n    y_col: str = \"pod\",\n    label_col: Optional[str] = None,\n    show_auc: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data containing ROC points.\n        x_col (str): Column name for POFD (False Alarm Rate).\n        y_col (str): Column name for POD (Hit Rate).\n        label_col (str, optional): Column for grouping different curves.\n        show_auc (bool): Whether to calculate and append AUC to labels.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    # TDD Anchor: Test validation raises error on missing cols\n    validate_dataframe(df, required_columns=[x_col, y_col])\n\n    # Draw No Skill Line\n    self.ax.plot([0, 1], [0, 1], \"k--\", label=\"No Skill\", alpha=0.5)\n    self.ax.grid(True, alpha=0.3)\n\n    if label_col:\n        groups = df.groupby(label_col)\n        for name, group in groups:\n            self._plot_single_curve(\n                group, x_col, y_col, label=str(name), show_auc=show_auc, **kwargs\n            )\n        self.ax.legend(loc=\"lower right\")\n    else:\n        self._plot_single_curve(\n            df, x_col, y_col, label=\"Model\", show_auc=show_auc, **kwargs\n        )\n\n    # Formatting\n    self.ax.set_xlim(0, 1)\n    self.ax.set_ylim(0, 1)\n    self.ax.set_xlabel(\"Probability of False Detection (POFD)\")\n    self.ax.set_ylabel(\"Probability of Detection (POD)\")\n    self.ax.set_aspect(\"equal\")\n</code></pre>"},{"location":"api/#monet_plots.plots.RankHistogramPlot","title":"<code>RankHistogramPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Rank Histogram (Talagrand Diagram).</p> <p>Visualizes the distribution of observation ranks within an ensemble.</p> <p>Functional Requirements: 1. Plot bar chart of rank frequencies. 2. Draw horizontal line for \"Perfect Flatness\" (uniform distribution). 3. Support normalizing frequencies (relative frequency) or raw counts. 4. Interpret shapes: U-shape (underdispersed), A-shape (overdispersed), Bias (slope).</p> <p>Edge Cases: - Unequal ensemble sizes (requires binning or normalization logic, but typically preprocessing handles this). - Missing ranks (should be 0 height bars).</p> Source code in <code>src/monet_plots/plots/rank_histogram.py</code> <pre><code>class RankHistogramPlot(BasePlot):\n    \"\"\"\n    Rank Histogram (Talagrand Diagram).\n\n    Visualizes the distribution of observation ranks within an ensemble.\n\n    Functional Requirements:\n    1. Plot bar chart of rank frequencies.\n    2. Draw horizontal line for \"Perfect Flatness\" (uniform distribution).\n    3. Support normalizing frequencies (relative frequency) or raw counts.\n    4. Interpret shapes: U-shape (underdispersed), A-shape (overdispersed), Bias (slope).\n\n    Edge Cases:\n    - Unequal ensemble sizes (requires binning or normalization logic, but typically preprocessing handles this).\n    - Missing ranks (should be 0 height bars).\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        rank_col: str = \"rank\",\n        n_members: Optional[int] = None,\n        label_col: Optional[str] = None,\n        normalize: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Data containing ranks (0 to n_members).\n            rank_col (str): Column containing the rank of the observation.\n            n_members (Optional[int]): Number of ensemble members (defines n_bins = n_members + 1).\n                                      Inferred from max(rank) if None.\n            label_col (Optional[str]): Grouping for multiple histograms (e.g., lead times).\n            normalize (bool): If True, plot relative frequency; else raw counts.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        validate_dataframe(df, required_columns=[rank_col])\n\n        if n_members is None:\n            n_members = int(df[rank_col].max())\n\n        num_bins = n_members + 1\n\n        if normalize:\n            expected = 1.0 / num_bins\n        else:\n            expected = len(df) / num_bins\n\n        # TDD Anchor: Validate inputs\n\n        if label_col:\n            for name, group in df.groupby(label_col):\n                counts = (\n                    group[rank_col]\n                    .value_counts()\n                    .reindex(np.arange(num_bins), fill_value=0)\n                )\n                total = counts.sum()\n                freq = counts / total if normalize else counts\n                self.ax.bar(\n                    counts.index, freq.values, label=str(name), alpha=0.7, **kwargs\n                )\n            self.ax.legend()\n        else:\n            counts = (\n                df[rank_col].value_counts().reindex(np.arange(num_bins), fill_value=0)\n            )\n            total = counts.sum()\n            freq = counts / total if normalize else counts\n            self.ax.bar(counts.index, freq.values, alpha=0.7, **kwargs)\n\n        # Expected uniform line\n        self.ax.axhline(\n            expected, color=\"k\", linestyle=\"--\", linewidth=2, label=\"Expected (Uniform)\"\n        )\n        self.ax.legend()\n\n        # Formatting\n        self.ax.set_xlabel(\"Rank\")\n        self.ax.set_ylabel(\"Relative Frequency\" if normalize else \"Count\")\n        self.ax.set_xticks(np.arange(n_members + 1))\n        self.ax.set_xlim(-0.5, n_members + 0.5)\n        self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"api/#monet_plots.plots.RankHistogramPlot.plot","title":"<code>plot(data, rank_col='rank', n_members=None, label_col=None, normalize=True, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Data containing ranks (0 to n_members).</p> required <code>rank_col</code> <code>str</code> <p>Column containing the rank of the observation.</p> <code>'rank'</code> <code>n_members</code> <code>Optional[int]</code> <p>Number of ensemble members (defines n_bins = n_members + 1).                       Inferred from max(rank) if None.</p> <code>None</code> <code>label_col</code> <code>Optional[str]</code> <p>Grouping for multiple histograms (e.g., lead times).</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If True, plot relative frequency; else raw counts.</p> <code>True</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/rank_histogram.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    rank_col: str = \"rank\",\n    n_members: Optional[int] = None,\n    label_col: Optional[str] = None,\n    normalize: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Data containing ranks (0 to n_members).\n        rank_col (str): Column containing the rank of the observation.\n        n_members (Optional[int]): Number of ensemble members (defines n_bins = n_members + 1).\n                                  Inferred from max(rank) if None.\n        label_col (Optional[str]): Grouping for multiple histograms (e.g., lead times).\n        normalize (bool): If True, plot relative frequency; else raw counts.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    validate_dataframe(df, required_columns=[rank_col])\n\n    if n_members is None:\n        n_members = int(df[rank_col].max())\n\n    num_bins = n_members + 1\n\n    if normalize:\n        expected = 1.0 / num_bins\n    else:\n        expected = len(df) / num_bins\n\n    # TDD Anchor: Validate inputs\n\n    if label_col:\n        for name, group in df.groupby(label_col):\n            counts = (\n                group[rank_col]\n                .value_counts()\n                .reindex(np.arange(num_bins), fill_value=0)\n            )\n            total = counts.sum()\n            freq = counts / total if normalize else counts\n            self.ax.bar(\n                counts.index, freq.values, label=str(name), alpha=0.7, **kwargs\n            )\n        self.ax.legend()\n    else:\n        counts = (\n            df[rank_col].value_counts().reindex(np.arange(num_bins), fill_value=0)\n        )\n        total = counts.sum()\n        freq = counts / total if normalize else counts\n        self.ax.bar(counts.index, freq.values, alpha=0.7, **kwargs)\n\n    # Expected uniform line\n    self.ax.axhline(\n        expected, color=\"k\", linestyle=\"--\", linewidth=2, label=\"Expected (Uniform)\"\n    )\n    self.ax.legend()\n\n    # Formatting\n    self.ax.set_xlabel(\"Rank\")\n    self.ax.set_ylabel(\"Relative Frequency\" if normalize else \"Count\")\n    self.ax.set_xticks(np.arange(n_members + 1))\n    self.ax.set_xlim(-0.5, n_members + 0.5)\n    self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"api/#monet_plots.plots.RelativeEconomicValuePlot","title":"<code>RelativeEconomicValuePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Relative Economic Value (REV) Plot.</p> <p>Visualizes the potential economic value of a forecast system relative to climatology.</p> <p>Functional Requirements: 1. Plot Value (y-axis) vs Cost/Loss Ratio (x-axis). 2. Calculate REV based on Hits, Misses, False Alarms, Correct Negatives. 3. Support multiple models. 4. X-axis usually logarithmic or specific range [0, 1].</p> <p>Edge Cases: - C/L ratio 0 or 1 (value is 0). - No events observed (metrics undefined).</p> Source code in <code>src/monet_plots/plots/rev.py</code> <pre><code>class RelativeEconomicValuePlot(BasePlot):\n    \"\"\"\n    Relative Economic Value (REV) Plot.\n\n    Visualizes the potential economic value of a forecast system relative to climatology.\n\n    Functional Requirements:\n    1. Plot Value (y-axis) vs Cost/Loss Ratio (x-axis).\n    2. Calculate REV based on Hits, Misses, False Alarms, Correct Negatives.\n    3. Support multiple models.\n    4. X-axis usually logarithmic or specific range [0, 1].\n\n    Edge Cases:\n    - C/L ratio 0 or 1 (value is 0).\n    - No events observed (metrics undefined).\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        counts_cols: List[str] = [\"hits\", \"misses\", \"fa\", \"cn\"],\n        climatology: Optional[float] = None,\n        label_col: Optional[str] = None,\n        cost_loss_ratios: Optional[np.ndarray] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data with contingency table counts.\n            counts_cols (List[str]): Contingency table columns [hits, misses, fa, cn].\n            climatology (Optional[float]): Sample climatology (base rate). Computed if None.\n            label_col (Optional[str]): Grouping column for multiple curves.\n            cost_loss_ratios (Optional[np.ndarray]): Array of C/L ratios. Default linspace(0.001,0.999,100).\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        validate_dataframe(df, required_columns=counts_cols)\n\n        if climatology is None:\n            total_events = df[counts_cols[0]].sum() + df[counts_cols[1]].sum()\n            total = total_events + df[counts_cols[2]].sum() + df[counts_cols[3]].sum()\n            climatology = total_events / total if total &gt; 0 else 0.5\n\n        if cost_loss_ratios is None:\n            cost_loss_ratios = np.linspace(0.001, 0.999, 100)\n\n        # TDD Anchor: Test REV calculation logic\n\n        if label_col:\n            for name, group in df.groupby(label_col):\n                rev_values = self._calculate_rev(\n                    group, counts_cols, cost_loss_ratios, climatology\n                )\n                self.ax.plot(cost_loss_ratios, rev_values, label=str(name), **kwargs)\n            self.ax.legend(loc=\"best\")\n        else:\n            rev_values = self._calculate_rev(\n                df, counts_cols, cost_loss_ratios, climatology\n            )\n            self.ax.plot(cost_loss_ratios, rev_values, label=\"Model\", **kwargs)\n\n        self.ax.set_xlabel(\"Cost/Loss Ratio\")\n        self.ax.set_ylabel(\"Relative Economic Value (REV)\")\n        self.ax.set_ylim(-0.2, 1.05)\n        self.ax.axhline(0, color=\"k\", linestyle=\"--\", alpha=0.7, label=\"Climatology\")\n        self.ax.axhline(1, color=\"gray\", linestyle=\":\", alpha=0.7, label=\"Perfect\")\n        self.ax.legend()\n        self.ax.grid(True, alpha=0.3)\n\n    def _calculate_rev(self, df, cols, ratios, clim):\n        \"\"\"\n        Calculates REV for given ratios.\n        \"\"\"\n        hits = df[cols[0]].sum()\n        misses = df[cols[1]].sum()\n        fa = df[cols[2]].sum()\n        cn = df[cols[3]].sum()\n        return compute_rev(hits, misses, fa, cn, ratios, clim)\n</code></pre>"},{"location":"api/#monet_plots.plots.RelativeEconomicValuePlot.plot","title":"<code>plot(data, counts_cols=['hits', 'misses', 'fa', 'cn'], climatology=None, label_col=None, cost_loss_ratios=None, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Input data with contingency table counts.</p> required <code>counts_cols</code> <code>List[str]</code> <p>Contingency table columns [hits, misses, fa, cn].</p> <code>['hits', 'misses', 'fa', 'cn']</code> <code>climatology</code> <code>Optional[float]</code> <p>Sample climatology (base rate). Computed if None.</p> <code>None</code> <code>label_col</code> <code>Optional[str]</code> <p>Grouping column for multiple curves.</p> <code>None</code> <code>cost_loss_ratios</code> <code>Optional[ndarray]</code> <p>Array of C/L ratios. Default linspace(0.001,0.999,100).</p> <code>None</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/rev.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    counts_cols: List[str] = [\"hits\", \"misses\", \"fa\", \"cn\"],\n    climatology: Optional[float] = None,\n    label_col: Optional[str] = None,\n    cost_loss_ratios: Optional[np.ndarray] = None,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data with contingency table counts.\n        counts_cols (List[str]): Contingency table columns [hits, misses, fa, cn].\n        climatology (Optional[float]): Sample climatology (base rate). Computed if None.\n        label_col (Optional[str]): Grouping column for multiple curves.\n        cost_loss_ratios (Optional[np.ndarray]): Array of C/L ratios. Default linspace(0.001,0.999,100).\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    validate_dataframe(df, required_columns=counts_cols)\n\n    if climatology is None:\n        total_events = df[counts_cols[0]].sum() + df[counts_cols[1]].sum()\n        total = total_events + df[counts_cols[2]].sum() + df[counts_cols[3]].sum()\n        climatology = total_events / total if total &gt; 0 else 0.5\n\n    if cost_loss_ratios is None:\n        cost_loss_ratios = np.linspace(0.001, 0.999, 100)\n\n    # TDD Anchor: Test REV calculation logic\n\n    if label_col:\n        for name, group in df.groupby(label_col):\n            rev_values = self._calculate_rev(\n                group, counts_cols, cost_loss_ratios, climatology\n            )\n            self.ax.plot(cost_loss_ratios, rev_values, label=str(name), **kwargs)\n        self.ax.legend(loc=\"best\")\n    else:\n        rev_values = self._calculate_rev(\n            df, counts_cols, cost_loss_ratios, climatology\n        )\n        self.ax.plot(cost_loss_ratios, rev_values, label=\"Model\", **kwargs)\n\n    self.ax.set_xlabel(\"Cost/Loss Ratio\")\n    self.ax.set_ylabel(\"Relative Economic Value (REV)\")\n    self.ax.set_ylim(-0.2, 1.05)\n    self.ax.axhline(0, color=\"k\", linestyle=\"--\", alpha=0.7, label=\"Climatology\")\n    self.ax.axhline(1, color=\"gray\", linestyle=\":\", alpha=0.7, label=\"Perfect\")\n    self.ax.legend()\n    self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"api/#monet_plots.plots.ReliabilityDiagramPlot","title":"<code>ReliabilityDiagramPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Reliability Diagram Plot (Attributes Diagram).</p> <p>Visualizes Observed Frequency vs Forecast Probability.</p> <p>Functional Requirements: 1. Plot Observed Frequency (y-axis) vs Forecast Probability (x-axis). 2. Draw \"Perfect Reliability\" diagonal (1:1). 3. Draw \"No Skill\" line (horizontal at climatology/sample mean). 4. Shade \"Skill\" areas (where Brier Skill Score &gt; 0). 5. Include inset histogram of forecast usage (Sharpness) if requested.</p> <p>Edge Cases: - Empty bins (no forecasts with that probability). - Climatology not provided (cannot draw skill regions correctly).</p> Source code in <code>src/monet_plots/plots/reliability_diagram.py</code> <pre><code>class ReliabilityDiagramPlot(BasePlot):\n    \"\"\"\n    Reliability Diagram Plot (Attributes Diagram).\n\n    Visualizes Observed Frequency vs Forecast Probability.\n\n    Functional Requirements:\n    1. Plot Observed Frequency (y-axis) vs Forecast Probability (x-axis).\n    2. Draw \"Perfect Reliability\" diagonal (1:1).\n    3. Draw \"No Skill\" line (horizontal at climatology/sample mean).\n    4. Shade \"Skill\" areas (where Brier Skill Score &gt; 0).\n    5. Include inset histogram of forecast usage (Sharpness) if requested.\n\n    Edge Cases:\n    - Empty bins (no forecasts with that probability).\n    - Climatology not provided (cannot draw skill regions correctly).\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        x_col: str = \"prob\",\n        y_col: str = \"freq\",\n        forecasts_col: Optional[str] = None,\n        observations_col: Optional[str] = None,\n        n_bins: int = 10,\n        climatology: Optional[float] = None,\n        label_col: Optional[str] = None,\n        show_hist: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data: Input data.\n            x_col (str): Forecast Probability bin center (for pre-binned).\n            y_col (str): Observed Frequency in bin (for pre-binned).\n            forecasts_col (str, optional): Column of raw forecast probabilities [0,1].\n            observations_col (str, optional): Column of binary observations {0,1}.\n            n_bins (int): Number of bins for reliability curve computation.\n            climatology (Optional[float]): Sample climatology (mean(observations)).\n            label_col (str, optional): Grouping column.\n            show_hist (bool): Whether to show frequency of usage histogram.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        # Compute if raw data provided\n        if forecasts_col and observations_col:\n            if climatology is None:\n                climatology = float(df[observations_col].mean())\n            bin_centers, obs_freq, bin_counts = compute_reliability_curve(\n                np.asarray(df[forecasts_col]), np.asarray(df[observations_col]), n_bins\n            )\n            plot_data = pd.DataFrame(\n                {x_col: bin_centers, y_col: obs_freq, \"count\": bin_counts}\n            )\n        else:\n            validate_dataframe(df, required_columns=[x_col, y_col])\n            plot_data = df\n\n        # Draw Reference Lines\n        self.ax.plot([0, 1], [0, 1], \"k--\", label=\"Perfect Reliability\")\n        if climatology is not None:\n            self.ax.axhline(\n                climatology, color=\"gray\", linestyle=\":\", label=\"Climatology\"\n            )\n            self._draw_skill_regions(climatology)\n\n        # Plot Data\n        if label_col:\n            for name, group in plot_data.groupby(label_col):\n                # pop label from kwargs if it exists to avoid multiple values\n                k = kwargs.copy()\n                k.pop(\"label\", None)\n                self.ax.plot(group[x_col], group[y_col], marker=\"o\", label=name, **k)\n        else:\n            k = kwargs.copy()\n            label = k.pop(\"label\", \"Model\")\n            self.ax.plot(\n                plot_data[x_col], plot_data[y_col], marker=\"o\", label=label, **k\n            )\n\n        # Histogram Overlay (Sharpness)\n        if show_hist and \"count\" in plot_data.columns:\n            self._add_sharpness_histogram(plot_data, x_col)\n\n        # Formatting\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 1)\n        self.ax.set_xlabel(\"Forecast Probability\")\n        self.ax.set_ylabel(\"Observed Relative Frequency\")\n        self.ax.set_aspect(\"equal\")\n        self.ax.grid(True, alpha=0.3)\n        self.ax.legend()\n\n    def _draw_skill_regions(self, clim):\n        \"\"\"Shades areas where BSS &gt; 0.\"\"\"\n        x = np.linspace(0, 1, 100)\n        y_no_skill = np.full_like(x, clim)\n        y_perfect = x\n\n        # Shade skill region (above no-skill towards perfect)\n        self.ax.fill_between(\n            x, y_no_skill, y_perfect, alpha=0.1, color=\"green\", label=\"Skill Region\"\n        )\n\n    def _add_sharpness_histogram(self, data, x_col):\n        \"\"\"Adds a small inset axes for sharpness histogram.\"\"\"\n        from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\n        inset_ax = inset_axes(self.ax, width=1.5, height=1.2, loc=\"upper right\")\n        inset_ax.bar(data[x_col], data[\"count\"], alpha=0.5, color=\"blue\", width=0.08)\n        inset_ax.set_title(\"Sharpness\")\n        inset_ax.set_xlabel(x_col)\n        inset_ax.set_ylabel(\"Count\")\n</code></pre>"},{"location":"api/#monet_plots.plots.ReliabilityDiagramPlot.plot","title":"<code>plot(data, x_col='prob', y_col='freq', forecasts_col=None, observations_col=None, n_bins=10, climatology=None, label_col=None, show_hist=False, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data.</p> required <code>x_col</code> <code>str</code> <p>Forecast Probability bin center (for pre-binned).</p> <code>'prob'</code> <code>y_col</code> <code>str</code> <p>Observed Frequency in bin (for pre-binned).</p> <code>'freq'</code> <code>forecasts_col</code> <code>str</code> <p>Column of raw forecast probabilities [0,1].</p> <code>None</code> <code>observations_col</code> <code>str</code> <p>Column of binary observations {0,1}.</p> <code>None</code> <code>n_bins</code> <code>int</code> <p>Number of bins for reliability curve computation.</p> <code>10</code> <code>climatology</code> <code>Optional[float]</code> <p>Sample climatology (mean(observations)).</p> <code>None</code> <code>label_col</code> <code>str</code> <p>Grouping column.</p> <code>None</code> <code>show_hist</code> <code>bool</code> <p>Whether to show frequency of usage histogram.</p> <code>False</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/reliability_diagram.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    x_col: str = \"prob\",\n    y_col: str = \"freq\",\n    forecasts_col: Optional[str] = None,\n    observations_col: Optional[str] = None,\n    n_bins: int = 10,\n    climatology: Optional[float] = None,\n    label_col: Optional[str] = None,\n    show_hist: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data: Input data.\n        x_col (str): Forecast Probability bin center (for pre-binned).\n        y_col (str): Observed Frequency in bin (for pre-binned).\n        forecasts_col (str, optional): Column of raw forecast probabilities [0,1].\n        observations_col (str, optional): Column of binary observations {0,1}.\n        n_bins (int): Number of bins for reliability curve computation.\n        climatology (Optional[float]): Sample climatology (mean(observations)).\n        label_col (str, optional): Grouping column.\n        show_hist (bool): Whether to show frequency of usage histogram.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    # Compute if raw data provided\n    if forecasts_col and observations_col:\n        if climatology is None:\n            climatology = float(df[observations_col].mean())\n        bin_centers, obs_freq, bin_counts = compute_reliability_curve(\n            np.asarray(df[forecasts_col]), np.asarray(df[observations_col]), n_bins\n        )\n        plot_data = pd.DataFrame(\n            {x_col: bin_centers, y_col: obs_freq, \"count\": bin_counts}\n        )\n    else:\n        validate_dataframe(df, required_columns=[x_col, y_col])\n        plot_data = df\n\n    # Draw Reference Lines\n    self.ax.plot([0, 1], [0, 1], \"k--\", label=\"Perfect Reliability\")\n    if climatology is not None:\n        self.ax.axhline(\n            climatology, color=\"gray\", linestyle=\":\", label=\"Climatology\"\n        )\n        self._draw_skill_regions(climatology)\n\n    # Plot Data\n    if label_col:\n        for name, group in plot_data.groupby(label_col):\n            # pop label from kwargs if it exists to avoid multiple values\n            k = kwargs.copy()\n            k.pop(\"label\", None)\n            self.ax.plot(group[x_col], group[y_col], marker=\"o\", label=name, **k)\n    else:\n        k = kwargs.copy()\n        label = k.pop(\"label\", \"Model\")\n        self.ax.plot(\n            plot_data[x_col], plot_data[y_col], marker=\"o\", label=label, **k\n        )\n\n    # Histogram Overlay (Sharpness)\n    if show_hist and \"count\" in plot_data.columns:\n        self._add_sharpness_histogram(plot_data, x_col)\n\n    # Formatting\n    self.ax.set_xlim(0, 1)\n    self.ax.set_ylim(0, 1)\n    self.ax.set_xlabel(\"Forecast Probability\")\n    self.ax.set_ylabel(\"Observed Relative Frequency\")\n    self.ax.set_aspect(\"equal\")\n    self.ax.grid(True, alpha=0.3)\n    self.ax.legend()\n</code></pre>"},{"location":"api/#monet_plots.plots.RidgelinePlot","title":"<code>RidgelinePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Creates a ridgeline plot (joyplot) from an xarray DataArray or pandas DataFrame.</p> <p>A ridgeline plot shows the distribution of a numeric value for several groups. Each group has its own distribution curve, often overlapping with others.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>DataArray | Dataset | DataFrame</code> <p>Normalized input data.</p> <code>group_dim</code> <code>str</code> <p>The dimension or column to group by for the Y-axis.</p> <code>x</code> <code>str | None</code> <p>The column name for values if data is a DataFrame or Dataset.</p> <code>x_range</code> <code>tuple | None</code> <p>Tuple (min, max) for the x-axis limits.</p> <code>scale_factor</code> <code>float</code> <p>Height scaling of the curves.</p> <code>overlap</code> <code>float</code> <p>Vertical spacing between curves.</p> <code>cmap_name</code> <code>str</code> <p>Colormap name for coloring curves.</p> <code>title</code> <code>str | None</code> <p>Plot title.</p> Source code in <code>src/monet_plots/plots/ridgeline.py</code> <pre><code>class RidgelinePlot(BasePlot):\n    \"\"\"\n    Creates a ridgeline plot (joyplot) from an xarray DataArray or pandas DataFrame.\n\n    A ridgeline plot shows the distribution of a numeric value for several groups.\n    Each group has its own distribution curve, often overlapping with others.\n\n    Attributes:\n        data (xr.DataArray | xr.Dataset | pd.DataFrame): Normalized input data.\n        group_dim (str): The dimension or column to group by for the Y-axis.\n        x (str | None): The column name for values if data is a DataFrame or Dataset.\n        x_range (tuple | None): Tuple (min, max) for the x-axis limits.\n        scale_factor (float): Height scaling of the curves.\n        overlap (float): Vertical spacing between curves.\n        cmap_name (str): Colormap name for coloring curves.\n        title (str | None): Plot title.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        group_dim: str,\n        x: Optional[str] = None,\n        *,\n        x_range: Optional[Tuple[float, float]] = None,\n        scale_factor: float = 1.0,\n        overlap: float = 0.5,\n        cmap: str = \"RdBu_r\",\n        title: Optional[str] = None,\n        bw_method: Optional[Any] = None,\n        alpha: float = 0.8,\n        quantiles: Optional[list[float]] = None,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initializes the ridgeline plot with data and settings.\n\n        Args:\n            data (Any): The data to plot (xr.DataArray, xr.Dataset, or pd.DataFrame).\n            group_dim (str): The dimension or column to group by for the Y-axis.\n            x (str, optional): The variable/column to plot distributions of.\n                Required if data is a Dataset or DataFrame with multiple variables.\n            x_range (tuple[float, float], optional): Tuple (min, max) for the x-axis limits.\n                If None, auto-calculated.\n            scale_factor (float): Height scaling of the curves. Defaults to 1.0.\n            overlap (float): Vertical spacing between curves. Higher values mean more overlap.\n                Defaults to 0.5.\n            cmap (str): Colormap name for coloring curves. Defaults to 'RdBu_r'.\n            title (str, optional): Plot title.\n            bw_method (Any, optional): KDE bandwidth method (passed to scipy.stats.gaussian_kde).\n            alpha (float): Transparency of the ridges. Defaults to 0.8.\n            quantiles (list[float], optional): List of quantiles to display (e.g., [0.5]).\n            **kwargs: Additional keyword arguments for BasePlot (figure/axes creation).\n        \"\"\"\n        super().__init__(**kwargs)\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1)\n\n        self.data = normalize_data(data)\n        self.group_dim = group_dim\n        self.x = x\n        self.x_range = x_range\n        self.scale_factor = scale_factor\n        self.overlap = overlap\n        self.cmap_name = cmap\n        self.title = title\n        self.bw_method = bw_method\n        self.alpha = alpha\n        self.quantiles = quantiles\n\n    def plot(\n        self, gradient: bool = True, color_by_group: bool = False, **kwargs: Any\n    ) -&gt; matplotlib.axes.Axes:\n        \"\"\"\n        Generate the ridgeline plot.\n\n        Args:\n            gradient (bool): If True, fill curves with a gradient based on x-values.\n            color_by_group (bool): If True, color each ridge by its group category.\n                Takes precedence over gradient if True.\n            **kwargs: Additional keyword arguments for formatting.\n\n        Returns:\n            matplotlib.axes.Axes: The axes object containing the plot.\n        \"\"\"\n        import matplotlib.pyplot as plt\n\n        from ..verification_metrics import _update_history\n\n        # 1. Prepare Data and Groups\n        if isinstance(self.data, xr.DataArray):\n            da = self.data\n            da_sorted = da.sortby(self.group_dim, ascending=False)\n            groups = da_sorted[self.group_dim].values\n            data_name = str(da.name) if da.name else \"Value\"\n\n            if self.x_range is None:\n                vmin = float(da.min().compute())\n                vmax = float(da.max().compute())\n            else:\n                vmin, vmax = self.x_range\n\n            if np.isnan(vmin) or np.isnan(vmax):\n                raise ValueError(\"No valid data points found to plot.\")\n\n        elif isinstance(self.data, xr.Dataset):\n            if self.x is None:\n                self.x = list(self.data.data_vars)[0]\n            da = self.data[self.x]\n            da_sorted = da.sortby(self.group_dim, ascending=False)\n            groups = da_sorted[self.group_dim].values\n            data_name = str(da.name) if da.name else self.x\n\n            if self.x_range is None:\n                vmin = float(da.min().compute())\n                vmax = float(da.max().compute())\n            else:\n                vmin, vmax = self.x_range\n\n            if np.isnan(vmin) or np.isnan(vmax):\n                raise ValueError(\"No valid data points found to plot.\")\n\n        else:\n            # Pandas DataFrame\n            df = self.data\n            if self.x is None:\n                # Try to find a numeric column that is not group_dim\n                numeric_cols = df.select_dtypes(include=[np.number]).columns\n                cols_to_use = [c for c in numeric_cols if c != self.group_dim]\n                if not cols_to_use:\n                    raise ValueError(\"No numeric columns found in DataFrame to plot.\")\n                self.x = cols_to_use[0]\n\n            df_sorted = df.sort_values(self.group_dim, ascending=False)\n            groups = df_sorted[self.group_dim].unique()\n            data_name = str(self.x)\n\n            if self.x_range is None:\n                vmin = float(df[self.x].min())\n                vmax = float(df[self.x].max())\n            else:\n                vmin, vmax = self.x_range\n\n            if np.isnan(vmin) or np.isnan(vmax):\n                raise ValueError(\"No valid data points found to plot.\")\n\n        # Setup X-axis grid for density calculation\n        if self.x_range is None:\n            pad = (vmax - vmin) * 0.1\n            x_grid = np.linspace(vmin - pad, vmax + pad, 200)\n        else:\n            x_grid = np.linspace(vmin, vmax, 200)\n\n        # Setup Colors\n        cmap, norm = get_linear_scale(None, cmap=self.cmap_name, vmin=vmin, vmax=vmax)\n\n        # 2. Iterate and Plot\n        for i, val in enumerate(groups):\n            if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n                # Handle DataArray/Dataset slice\n                data_slice = da_sorted.sel({self.group_dim: val}).values.flatten()\n            else:\n                # Handle DataFrame slice\n                data_slice = df_sorted[df_sorted[self.group_dim] == val][\n                    self.x\n                ].values.flatten()\n\n            data_slice = data_slice[~np.isnan(data_slice)]\n\n            if len(data_slice) &lt; 2:\n                continue\n\n            try:\n                kde = gaussian_kde(data_slice, bw_method=self.bw_method)\n                y_density = kde(x_grid)\n            except (np.linalg.LinAlgError, ValueError):\n                continue\n\n            # Scale density and calculate vertical baseline\n            y_density_scaled = y_density * self.scale_factor\n            baseline = -i * self.overlap\n            y_final = baseline + y_density_scaled\n\n            # Plot filling\n            if color_by_group:\n                # Use qualitative cmap or indexed colors\n                color = plt.get_cmap(\"tab10\")(i % 10)\n                self.ax.fill_between(\n                    x_grid,\n                    baseline,\n                    y_final,\n                    facecolor=color,\n                    edgecolor=\"white\",\n                    linewidth=0.5,\n                    alpha=self.alpha,\n                    zorder=len(groups) - i,\n                )\n                self.ax.plot(\n                    x_grid,\n                    y_final,\n                    color=\"black\",\n                    linewidth=0.5,\n                    zorder=len(groups) - i + 0.1,\n                )\n            elif gradient:\n                # Plot in segments to create a gradient effect\n                for j in range(len(x_grid) - 1):\n                    self.ax.fill_between(\n                        x_grid[j : j + 2],\n                        baseline,\n                        y_final[j : j + 2],\n                        facecolor=cmap(norm(x_grid[j])),\n                        edgecolor=\"none\",\n                        alpha=self.alpha,\n                        zorder=len(groups) - i,\n                    )\n                # Add a clean top outline\n                self.ax.plot(\n                    x_grid,\n                    y_final,\n                    color=\"black\",\n                    linewidth=0.5,\n                    zorder=len(groups) - i + 0.1,\n                )\n            else:\n                # Single color based on the mean of this slice\n                slice_mean = np.mean(data_slice)\n                color = cmap(norm(slice_mean))\n                self.ax.fill_between(\n                    x_grid,\n                    baseline,\n                    y_final,\n                    facecolor=color,\n                    edgecolor=\"white\",\n                    linewidth=0.5,\n                    alpha=self.alpha,\n                    zorder=len(groups) - i,\n                )\n                self.ax.plot(\n                    x_grid,\n                    y_final,\n                    color=\"black\",\n                    linewidth=0.5,\n                    zorder=len(groups) - i + 0.1,\n                )\n\n            # 3. Add Quantiles\n            if self.quantiles is not None:\n                q_values = np.quantile(data_slice, self.quantiles)\n                q_densities = kde(q_values) * self.scale_factor\n                for qv, qd in zip(q_values, q_densities):\n                    self.ax.vlines(\n                        qv,\n                        baseline,\n                        baseline + qd,\n                        color=\"black\",\n                        linestyle=\"--\",\n                        linewidth=0.8,\n                        zorder=len(groups) - i + 0.2,\n                    )\n\n        # 3. Final Formatting\n        self.ax.set_yticks([-i * self.overlap for i in range(len(groups))])\n        self.ax.set_yticklabels(groups)\n        self.ax.set_xlabel(data_name)\n        if self.title:\n            self.ax.set_title(self.title, pad=20)\n\n        # Add Colorbar matching the x-axis scale if not coloring by group\n        if not color_by_group:\n            mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n            self.add_colorbar(mappable, label=data_name)\n\n        # Add vertical gridlines as seen in the reference\n        self.ax.xaxis.grid(True, linestyle=\"-\", alpha=0.3)\n\n        # Add a vertical zero line if the range crosses zero\n        if x_grid.min() &lt; 0 and x_grid.max() &gt; 0:\n            self.ax.axvline(0, color=\"black\", alpha=0.3, linestyle=\"--\", linewidth=1)\n\n        # Remove unnecessary spines\n        self.ax.spines[\"top\"].set_visible(False)\n        self.ax.spines[\"right\"].set_visible(False)\n        self.ax.spines[\"left\"].set_visible(False)\n\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            _update_history(self.data, f\"Created ridgeline plot for {data_name}\")\n\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.RidgelinePlot.__init__","title":"<code>__init__(data, group_dim, x=None, *, x_range=None, scale_factor=1.0, overlap=0.5, cmap='RdBu_r', title=None, bw_method=None, alpha=0.8, quantiles=None, **kwargs)</code>","text":"<p>Initializes the ridgeline plot with data and settings.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to plot (xr.DataArray, xr.Dataset, or pd.DataFrame).</p> required <code>group_dim</code> <code>str</code> <p>The dimension or column to group by for the Y-axis.</p> required <code>x</code> <code>str</code> <p>The variable/column to plot distributions of. Required if data is a Dataset or DataFrame with multiple variables.</p> <code>None</code> <code>x_range</code> <code>tuple[float, float]</code> <p>Tuple (min, max) for the x-axis limits. If None, auto-calculated.</p> <code>None</code> <code>scale_factor</code> <code>float</code> <p>Height scaling of the curves. Defaults to 1.0.</p> <code>1.0</code> <code>overlap</code> <code>float</code> <p>Vertical spacing between curves. Higher values mean more overlap. Defaults to 0.5.</p> <code>0.5</code> <code>cmap</code> <code>str</code> <p>Colormap name for coloring curves. Defaults to 'RdBu_r'.</p> <code>'RdBu_r'</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>None</code> <code>bw_method</code> <code>Any</code> <p>KDE bandwidth method (passed to scipy.stats.gaussian_kde).</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Transparency of the ridges. Defaults to 0.8.</p> <code>0.8</code> <code>quantiles</code> <code>list[float]</code> <p>List of quantiles to display (e.g., [0.5]).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for BasePlot (figure/axes creation).</p> <code>{}</code> Source code in <code>src/monet_plots/plots/ridgeline.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    group_dim: str,\n    x: Optional[str] = None,\n    *,\n    x_range: Optional[Tuple[float, float]] = None,\n    scale_factor: float = 1.0,\n    overlap: float = 0.5,\n    cmap: str = \"RdBu_r\",\n    title: Optional[str] = None,\n    bw_method: Optional[Any] = None,\n    alpha: float = 0.8,\n    quantiles: Optional[list[float]] = None,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initializes the ridgeline plot with data and settings.\n\n    Args:\n        data (Any): The data to plot (xr.DataArray, xr.Dataset, or pd.DataFrame).\n        group_dim (str): The dimension or column to group by for the Y-axis.\n        x (str, optional): The variable/column to plot distributions of.\n            Required if data is a Dataset or DataFrame with multiple variables.\n        x_range (tuple[float, float], optional): Tuple (min, max) for the x-axis limits.\n            If None, auto-calculated.\n        scale_factor (float): Height scaling of the curves. Defaults to 1.0.\n        overlap (float): Vertical spacing between curves. Higher values mean more overlap.\n            Defaults to 0.5.\n        cmap (str): Colormap name for coloring curves. Defaults to 'RdBu_r'.\n        title (str, optional): Plot title.\n        bw_method (Any, optional): KDE bandwidth method (passed to scipy.stats.gaussian_kde).\n        alpha (float): Transparency of the ridges. Defaults to 0.8.\n        quantiles (list[float], optional): List of quantiles to display (e.g., [0.5]).\n        **kwargs: Additional keyword arguments for BasePlot (figure/axes creation).\n    \"\"\"\n    super().__init__(**kwargs)\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1)\n\n    self.data = normalize_data(data)\n    self.group_dim = group_dim\n    self.x = x\n    self.x_range = x_range\n    self.scale_factor = scale_factor\n    self.overlap = overlap\n    self.cmap_name = cmap\n    self.title = title\n    self.bw_method = bw_method\n    self.alpha = alpha\n    self.quantiles = quantiles\n</code></pre>"},{"location":"api/#monet_plots.plots.RidgelinePlot.plot","title":"<code>plot(gradient=True, color_by_group=False, **kwargs)</code>","text":"<p>Generate the ridgeline plot.</p> <p>Parameters:</p> Name Type Description Default <code>gradient</code> <code>bool</code> <p>If True, fill curves with a gradient based on x-values.</p> <code>True</code> <code>color_by_group</code> <code>bool</code> <p>If True, color each ridge by its group category. Takes precedence over gradient if True.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for formatting.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>matplotlib.axes.Axes: The axes object containing the plot.</p> Source code in <code>src/monet_plots/plots/ridgeline.py</code> <pre><code>def plot(\n    self, gradient: bool = True, color_by_group: bool = False, **kwargs: Any\n) -&gt; matplotlib.axes.Axes:\n    \"\"\"\n    Generate the ridgeline plot.\n\n    Args:\n        gradient (bool): If True, fill curves with a gradient based on x-values.\n        color_by_group (bool): If True, color each ridge by its group category.\n            Takes precedence over gradient if True.\n        **kwargs: Additional keyword arguments for formatting.\n\n    Returns:\n        matplotlib.axes.Axes: The axes object containing the plot.\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    from ..verification_metrics import _update_history\n\n    # 1. Prepare Data and Groups\n    if isinstance(self.data, xr.DataArray):\n        da = self.data\n        da_sorted = da.sortby(self.group_dim, ascending=False)\n        groups = da_sorted[self.group_dim].values\n        data_name = str(da.name) if da.name else \"Value\"\n\n        if self.x_range is None:\n            vmin = float(da.min().compute())\n            vmax = float(da.max().compute())\n        else:\n            vmin, vmax = self.x_range\n\n        if np.isnan(vmin) or np.isnan(vmax):\n            raise ValueError(\"No valid data points found to plot.\")\n\n    elif isinstance(self.data, xr.Dataset):\n        if self.x is None:\n            self.x = list(self.data.data_vars)[0]\n        da = self.data[self.x]\n        da_sorted = da.sortby(self.group_dim, ascending=False)\n        groups = da_sorted[self.group_dim].values\n        data_name = str(da.name) if da.name else self.x\n\n        if self.x_range is None:\n            vmin = float(da.min().compute())\n            vmax = float(da.max().compute())\n        else:\n            vmin, vmax = self.x_range\n\n        if np.isnan(vmin) or np.isnan(vmax):\n            raise ValueError(\"No valid data points found to plot.\")\n\n    else:\n        # Pandas DataFrame\n        df = self.data\n        if self.x is None:\n            # Try to find a numeric column that is not group_dim\n            numeric_cols = df.select_dtypes(include=[np.number]).columns\n            cols_to_use = [c for c in numeric_cols if c != self.group_dim]\n            if not cols_to_use:\n                raise ValueError(\"No numeric columns found in DataFrame to plot.\")\n            self.x = cols_to_use[0]\n\n        df_sorted = df.sort_values(self.group_dim, ascending=False)\n        groups = df_sorted[self.group_dim].unique()\n        data_name = str(self.x)\n\n        if self.x_range is None:\n            vmin = float(df[self.x].min())\n            vmax = float(df[self.x].max())\n        else:\n            vmin, vmax = self.x_range\n\n        if np.isnan(vmin) or np.isnan(vmax):\n            raise ValueError(\"No valid data points found to plot.\")\n\n    # Setup X-axis grid for density calculation\n    if self.x_range is None:\n        pad = (vmax - vmin) * 0.1\n        x_grid = np.linspace(vmin - pad, vmax + pad, 200)\n    else:\n        x_grid = np.linspace(vmin, vmax, 200)\n\n    # Setup Colors\n    cmap, norm = get_linear_scale(None, cmap=self.cmap_name, vmin=vmin, vmax=vmax)\n\n    # 2. Iterate and Plot\n    for i, val in enumerate(groups):\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            # Handle DataArray/Dataset slice\n            data_slice = da_sorted.sel({self.group_dim: val}).values.flatten()\n        else:\n            # Handle DataFrame slice\n            data_slice = df_sorted[df_sorted[self.group_dim] == val][\n                self.x\n            ].values.flatten()\n\n        data_slice = data_slice[~np.isnan(data_slice)]\n\n        if len(data_slice) &lt; 2:\n            continue\n\n        try:\n            kde = gaussian_kde(data_slice, bw_method=self.bw_method)\n            y_density = kde(x_grid)\n        except (np.linalg.LinAlgError, ValueError):\n            continue\n\n        # Scale density and calculate vertical baseline\n        y_density_scaled = y_density * self.scale_factor\n        baseline = -i * self.overlap\n        y_final = baseline + y_density_scaled\n\n        # Plot filling\n        if color_by_group:\n            # Use qualitative cmap or indexed colors\n            color = plt.get_cmap(\"tab10\")(i % 10)\n            self.ax.fill_between(\n                x_grid,\n                baseline,\n                y_final,\n                facecolor=color,\n                edgecolor=\"white\",\n                linewidth=0.5,\n                alpha=self.alpha,\n                zorder=len(groups) - i,\n            )\n            self.ax.plot(\n                x_grid,\n                y_final,\n                color=\"black\",\n                linewidth=0.5,\n                zorder=len(groups) - i + 0.1,\n            )\n        elif gradient:\n            # Plot in segments to create a gradient effect\n            for j in range(len(x_grid) - 1):\n                self.ax.fill_between(\n                    x_grid[j : j + 2],\n                    baseline,\n                    y_final[j : j + 2],\n                    facecolor=cmap(norm(x_grid[j])),\n                    edgecolor=\"none\",\n                    alpha=self.alpha,\n                    zorder=len(groups) - i,\n                )\n            # Add a clean top outline\n            self.ax.plot(\n                x_grid,\n                y_final,\n                color=\"black\",\n                linewidth=0.5,\n                zorder=len(groups) - i + 0.1,\n            )\n        else:\n            # Single color based on the mean of this slice\n            slice_mean = np.mean(data_slice)\n            color = cmap(norm(slice_mean))\n            self.ax.fill_between(\n                x_grid,\n                baseline,\n                y_final,\n                facecolor=color,\n                edgecolor=\"white\",\n                linewidth=0.5,\n                alpha=self.alpha,\n                zorder=len(groups) - i,\n            )\n            self.ax.plot(\n                x_grid,\n                y_final,\n                color=\"black\",\n                linewidth=0.5,\n                zorder=len(groups) - i + 0.1,\n            )\n\n        # 3. Add Quantiles\n        if self.quantiles is not None:\n            q_values = np.quantile(data_slice, self.quantiles)\n            q_densities = kde(q_values) * self.scale_factor\n            for qv, qd in zip(q_values, q_densities):\n                self.ax.vlines(\n                    qv,\n                    baseline,\n                    baseline + qd,\n                    color=\"black\",\n                    linestyle=\"--\",\n                    linewidth=0.8,\n                    zorder=len(groups) - i + 0.2,\n                )\n\n    # 3. Final Formatting\n    self.ax.set_yticks([-i * self.overlap for i in range(len(groups))])\n    self.ax.set_yticklabels(groups)\n    self.ax.set_xlabel(data_name)\n    if self.title:\n        self.ax.set_title(self.title, pad=20)\n\n    # Add Colorbar matching the x-axis scale if not coloring by group\n    if not color_by_group:\n        mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n        self.add_colorbar(mappable, label=data_name)\n\n    # Add vertical gridlines as seen in the reference\n    self.ax.xaxis.grid(True, linestyle=\"-\", alpha=0.3)\n\n    # Add a vertical zero line if the range crosses zero\n    if x_grid.min() &lt; 0 and x_grid.max() &gt; 0:\n        self.ax.axvline(0, color=\"black\", alpha=0.3, linestyle=\"--\", linewidth=1)\n\n    # Remove unnecessary spines\n    self.ax.spines[\"top\"].set_visible(False)\n    self.ax.spines[\"right\"].set_visible(False)\n    self.ax.spines[\"left\"].set_visible(False)\n\n    if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n        _update_history(self.data, f\"Created ridgeline plot for {data_name}\")\n\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.ScatterPlot","title":"<code>ScatterPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a scatter plot with a regression line.</p> <p>This plot shows the relationship between two variables and includes a linear regression model fit. It supports lazy evaluation for large Xarray/Dask datasets by delaying computation until the plot call.</p>"},{"location":"api/#monet_plots.plots.ScatterPlot--attributes","title":"Attributes","text":"<p>data : Union[xr.Dataset, xr.DataArray, pd.DataFrame]     The input data for the plot. x : str     The name of the variable for the x-axis. y : List[str]     The names of the variables for the y-axis. c : Optional[str]     The name of the variable used for colorizing points. colorbar : bool     Whether to add a colorbar to the plot. title : Optional[str]     The title for the plot.</p> Source code in <code>src/monet_plots/plots/scatter.py</code> <pre><code>class ScatterPlot(BasePlot):\n    \"\"\"Create a scatter plot with a regression line.\n\n    This plot shows the relationship between two variables and includes a\n    linear regression model fit. It supports lazy evaluation for large\n    Xarray/Dask datasets by delaying computation until the plot call.\n\n    Attributes\n    ----------\n    data : Union[xr.Dataset, xr.DataArray, pd.DataFrame]\n        The input data for the plot.\n    x : str\n        The name of the variable for the x-axis.\n    y : List[str]\n        The names of the variables for the y-axis.\n    c : Optional[str]\n        The name of the variable used for colorizing points.\n    colorbar : bool\n        Whether to add a colorbar to the plot.\n    title : Optional[str]\n        The title for the plot.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any = None,\n        x: Optional[str] = None,\n        y: Optional[Union[str, List[str]]] = None,\n        c: Optional[str] = None,\n        colorbar: bool = False,\n        title: Optional[str] = None,\n        fig: Optional[matplotlib.figure.Figure] = None,\n        ax: Optional[matplotlib.axes.Axes] = None,\n        df: Any = None,  # Backward compatibility alias\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the scatter plot.\n\n        Parameters\n        ----------\n        data : Any, optional\n            Input data. Can be a pandas DataFrame, xarray DataArray,\n            xarray Dataset, or numpy ndarray.\n        x : str, optional\n            Variable name for the x-axis.\n        y : Union[str, List[str]], optional\n            Variable name(s) for the y-axis.\n        c : str, optional\n            Variable name for colorizing the points, by default None.\n        colorbar : bool, optional\n            Whether to add a colorbar, by default False.\n        title : str, optional\n            Title for the plot, by default None.\n        fig : matplotlib.figure.Figure, optional\n            An existing Figure object.\n        ax : matplotlib.axes.Axes, optional\n            An existing Axes object.\n        df : Any, optional\n            Alias for `data` for backward compatibility.\n        **kwargs : Any\n            Additional keyword arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(fig=fig, ax=ax, **kwargs)\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1)\n\n        self.data = normalize_data(data if data is not None else df)\n        self.x = x\n        self.y = [y] if isinstance(y, str) else (y if y is not None else [])\n        self.c = c\n        self.colorbar = colorbar\n        self.title = title\n\n        if not self.x or not self.y:\n            raise ValueError(\"Parameters 'x' and 'y' must be provided.\")\n\n        # Update history for provenance if Xarray\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            history = self.data.attrs.get(\"history\", \"\")\n            self.data.attrs[\"history\"] = f\"Initialized ScatterPlot; {history}\"\n\n    def _get_regression_line(\n        self, x_val: np.ndarray, y_val: np.ndarray\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Calculate regression line points using only endpoints.\n\n        Parameters\n        ----------\n        x_val : np.ndarray\n            The concrete x-axis data.\n        y_val : np.ndarray\n            The concrete y-axis data.\n\n        Returns\n        -------\n        tuple[np.ndarray, np.ndarray]\n            The x and y values for the regression line endpoints.\n        \"\"\"\n        mask = ~np.isnan(x_val) &amp; ~np.isnan(y_val)\n        if not np.any(mask):\n            return np.array([np.nan, np.nan]), np.array([np.nan, np.nan])\n\n        m, b = np.polyfit(x_val[mask], y_val[mask], 1)\n        x_min, x_max = np.nanmin(x_val), np.nanmax(x_val)\n        x_reg = np.array([x_min, x_max])\n        y_reg = m * x_reg + b\n        return x_reg, y_reg\n\n    def plot(\n        self,\n        scatter_kws: Optional[dict[str, Any]] = None,\n        line_kws: Optional[dict[str, Any]] = None,\n        **kwargs: Any,\n    ) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the scatter plot.\n\n        Parameters\n        ----------\n        scatter_kws : dict, optional\n            Additional keyword arguments for `ax.scatter`.\n        line_kws : dict, optional\n            Additional keyword arguments for the regression `ax.plot`.\n        **kwargs : Any\n            Secondary way to pass keyword arguments to `ax.scatter`.\n            Merged with `scatter_kws`.\n\n        Returns\n        -------\n        matplotlib.axes.Axes\n            The axes object with the scatter plot.\n\n        Notes\n        -----\n        For massive datasets (&gt; RAM), consider using Track B (Exploration)\n        tools like `hvplot` with `rasterize=True`.\n        \"\"\"\n        from ..plot_utils import get_plot_kwargs\n\n        # Combine scatter_kws and kwargs\n        s_kws = scatter_kws.copy() if scatter_kws is not None else {}\n        s_kws.update(kwargs)\n\n        l_kws = line_kws.copy() if line_kws is not None else {}\n\n        # Aero Protocol Requirement: Mandatory transform for GeoAxes\n        is_geo = hasattr(self.ax, \"projection\")\n        if is_geo:\n            s_kws.setdefault(\"transform\", ccrs.PlateCarree())\n            l_kws.setdefault(\"transform\", ccrs.PlateCarree())\n\n        transform = s_kws.get(\"transform\")\n\n        # Performance: Compute required variables once to avoid double work\n        cols = [self.x] + self.y\n        if self.c:\n            cols.append(self.c)\n\n        if hasattr(self.data, \"compute\"):\n            # Sub-selection before compute to minimize data transfer\n            subset = self.data[cols]\n            concrete_data = subset.compute()\n        else:\n            concrete_data = self.data\n\n        x_plot = concrete_data[self.x].values.flatten()\n\n        for y_col in self.y:\n            y_plot = concrete_data[y_col].values.flatten()\n\n            if self.c is not None:\n                c_plot = concrete_data[self.c].values.flatten()\n\n                final_s_kwargs = get_plot_kwargs(c=c_plot, **s_kws)\n                mappable = self.ax.scatter(x_plot, y_plot, **final_s_kwargs)\n\n                if self.colorbar:\n                    self.add_colorbar(mappable)\n            else:\n                final_s_kwargs = s_kws.copy()\n                final_s_kwargs.setdefault(\"label\", y_col)\n                self.ax.scatter(x_plot, y_plot, **final_s_kwargs)\n\n            # Add regression line using endpoints\n            x_reg, y_reg = self._get_regression_line(x_plot, y_plot)\n\n            final_l_kwargs = {\n                \"color\": \"red\",\n                \"linestyle\": \"--\",\n                \"label\": \"Fit\" if (self.c is None and len(self.y) == 1) else None,\n            }\n            final_l_kwargs.update(l_kws)\n            if transform:\n                final_l_kwargs.setdefault(\"transform\", transform)\n\n            self.ax.plot(x_reg, y_reg, **final_l_kwargs)\n\n        if len(self.y) &gt; 1 and self.c is None:\n            self.ax.legend()\n\n        if self.title:\n            self.ax.set_title(self.title)\n        else:\n            self.ax.set_title(f\"Scatter: {self.x} vs {', '.join(self.y)}\")\n\n        self.ax.set_xlabel(self.x)\n        self.ax.set_ylabel(\", \".join(self.y) if len(self.y) &gt; 1 else self.y[0])\n\n        # Update history for provenance\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            history = self.data.attrs.get(\"history\", \"\")\n            self.data.attrs[\"history\"] = f\"Generated ScatterPlot; {history}\"\n\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.ScatterPlot.__init__","title":"<code>__init__(data=None, x=None, y=None, c=None, colorbar=False, title=None, fig=None, ax=None, df=None, **kwargs)</code>","text":"<p>Initialize the scatter plot.</p>"},{"location":"api/#monet_plots.plots.ScatterPlot.__init__--parameters","title":"Parameters","text":"<p>data : Any, optional     Input data. Can be a pandas DataFrame, xarray DataArray,     xarray Dataset, or numpy ndarray. x : str, optional     Variable name for the x-axis. y : Union[str, List[str]], optional     Variable name(s) for the y-axis. c : str, optional     Variable name for colorizing the points, by default None. colorbar : bool, optional     Whether to add a colorbar, by default False. title : str, optional     Title for the plot, by default None. fig : matplotlib.figure.Figure, optional     An existing Figure object. ax : matplotlib.axes.Axes, optional     An existing Axes object. df : Any, optional     Alias for <code>data</code> for backward compatibility. **kwargs : Any     Additional keyword arguments passed to BasePlot.</p> Source code in <code>src/monet_plots/plots/scatter.py</code> <pre><code>def __init__(\n    self,\n    data: Any = None,\n    x: Optional[str] = None,\n    y: Optional[Union[str, List[str]]] = None,\n    c: Optional[str] = None,\n    colorbar: bool = False,\n    title: Optional[str] = None,\n    fig: Optional[matplotlib.figure.Figure] = None,\n    ax: Optional[matplotlib.axes.Axes] = None,\n    df: Any = None,  # Backward compatibility alias\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the scatter plot.\n\n    Parameters\n    ----------\n    data : Any, optional\n        Input data. Can be a pandas DataFrame, xarray DataArray,\n        xarray Dataset, or numpy ndarray.\n    x : str, optional\n        Variable name for the x-axis.\n    y : Union[str, List[str]], optional\n        Variable name(s) for the y-axis.\n    c : str, optional\n        Variable name for colorizing the points, by default None.\n    colorbar : bool, optional\n        Whether to add a colorbar, by default False.\n    title : str, optional\n        Title for the plot, by default None.\n    fig : matplotlib.figure.Figure, optional\n        An existing Figure object.\n    ax : matplotlib.axes.Axes, optional\n        An existing Axes object.\n    df : Any, optional\n        Alias for `data` for backward compatibility.\n    **kwargs : Any\n        Additional keyword arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(fig=fig, ax=ax, **kwargs)\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1)\n\n    self.data = normalize_data(data if data is not None else df)\n    self.x = x\n    self.y = [y] if isinstance(y, str) else (y if y is not None else [])\n    self.c = c\n    self.colorbar = colorbar\n    self.title = title\n\n    if not self.x or not self.y:\n        raise ValueError(\"Parameters 'x' and 'y' must be provided.\")\n\n    # Update history for provenance if Xarray\n    if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n        history = self.data.attrs.get(\"history\", \"\")\n        self.data.attrs[\"history\"] = f\"Initialized ScatterPlot; {history}\"\n</code></pre>"},{"location":"api/#monet_plots.plots.ScatterPlot.plot","title":"<code>plot(scatter_kws=None, line_kws=None, **kwargs)</code>","text":"<p>Generate the scatter plot.</p>"},{"location":"api/#monet_plots.plots.ScatterPlot.plot--parameters","title":"Parameters","text":"<p>scatter_kws : dict, optional     Additional keyword arguments for <code>ax.scatter</code>. line_kws : dict, optional     Additional keyword arguments for the regression <code>ax.plot</code>. **kwargs : Any     Secondary way to pass keyword arguments to <code>ax.scatter</code>.     Merged with <code>scatter_kws</code>.</p>"},{"location":"api/#monet_plots.plots.ScatterPlot.plot--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The axes object with the scatter plot.</p>"},{"location":"api/#monet_plots.plots.ScatterPlot.plot--notes","title":"Notes","text":"<p>For massive datasets (&gt; RAM), consider using Track B (Exploration) tools like <code>hvplot</code> with <code>rasterize=True</code>.</p> Source code in <code>src/monet_plots/plots/scatter.py</code> <pre><code>def plot(\n    self,\n    scatter_kws: Optional[dict[str, Any]] = None,\n    line_kws: Optional[dict[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the scatter plot.\n\n    Parameters\n    ----------\n    scatter_kws : dict, optional\n        Additional keyword arguments for `ax.scatter`.\n    line_kws : dict, optional\n        Additional keyword arguments for the regression `ax.plot`.\n    **kwargs : Any\n        Secondary way to pass keyword arguments to `ax.scatter`.\n        Merged with `scatter_kws`.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The axes object with the scatter plot.\n\n    Notes\n    -----\n    For massive datasets (&gt; RAM), consider using Track B (Exploration)\n    tools like `hvplot` with `rasterize=True`.\n    \"\"\"\n    from ..plot_utils import get_plot_kwargs\n\n    # Combine scatter_kws and kwargs\n    s_kws = scatter_kws.copy() if scatter_kws is not None else {}\n    s_kws.update(kwargs)\n\n    l_kws = line_kws.copy() if line_kws is not None else {}\n\n    # Aero Protocol Requirement: Mandatory transform for GeoAxes\n    is_geo = hasattr(self.ax, \"projection\")\n    if is_geo:\n        s_kws.setdefault(\"transform\", ccrs.PlateCarree())\n        l_kws.setdefault(\"transform\", ccrs.PlateCarree())\n\n    transform = s_kws.get(\"transform\")\n\n    # Performance: Compute required variables once to avoid double work\n    cols = [self.x] + self.y\n    if self.c:\n        cols.append(self.c)\n\n    if hasattr(self.data, \"compute\"):\n        # Sub-selection before compute to minimize data transfer\n        subset = self.data[cols]\n        concrete_data = subset.compute()\n    else:\n        concrete_data = self.data\n\n    x_plot = concrete_data[self.x].values.flatten()\n\n    for y_col in self.y:\n        y_plot = concrete_data[y_col].values.flatten()\n\n        if self.c is not None:\n            c_plot = concrete_data[self.c].values.flatten()\n\n            final_s_kwargs = get_plot_kwargs(c=c_plot, **s_kws)\n            mappable = self.ax.scatter(x_plot, y_plot, **final_s_kwargs)\n\n            if self.colorbar:\n                self.add_colorbar(mappable)\n        else:\n            final_s_kwargs = s_kws.copy()\n            final_s_kwargs.setdefault(\"label\", y_col)\n            self.ax.scatter(x_plot, y_plot, **final_s_kwargs)\n\n        # Add regression line using endpoints\n        x_reg, y_reg = self._get_regression_line(x_plot, y_plot)\n\n        final_l_kwargs = {\n            \"color\": \"red\",\n            \"linestyle\": \"--\",\n            \"label\": \"Fit\" if (self.c is None and len(self.y) == 1) else None,\n        }\n        final_l_kwargs.update(l_kws)\n        if transform:\n            final_l_kwargs.setdefault(\"transform\", transform)\n\n        self.ax.plot(x_reg, y_reg, **final_l_kwargs)\n\n    if len(self.y) &gt; 1 and self.c is None:\n        self.ax.legend()\n\n    if self.title:\n        self.ax.set_title(self.title)\n    else:\n        self.ax.set_title(f\"Scatter: {self.x} vs {', '.join(self.y)}\")\n\n    self.ax.set_xlabel(self.x)\n    self.ax.set_ylabel(\", \".join(self.y) if len(self.y) &gt; 1 else self.y[0])\n\n    # Update history for provenance\n    if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n        history = self.data.attrs.get(\"history\", \"\")\n        self.data.attrs[\"history\"] = f\"Generated ScatterPlot; {history}\"\n\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.ScorecardPlot","title":"<code>ScorecardPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Scorecard Plot.</p> <p>Heatmap table displaying performance metrics across multiple dimensions (e.g., Variables vs Lead Times), colored by performance relative to a baseline.</p> <p>Functional Requirements: 1. Heatmap grid: Rows (Variables/Regions), Cols (Lead Times/Levels). 2. Color cells based on statistic (e.g., Difference from Baseline, RMSE ratio). 3. Annotate cells with symbols (+/-) or values indicating significance. 4. Handle Green (Better) / Red (Worse) color schemes correctly.</p> <p>Edge Cases: - Missing data for some cells (show as white/gray). - Infinite values (clip or mask).</p> Source code in <code>src/monet_plots/plots/scorecard.py</code> <pre><code>class ScorecardPlot(BasePlot):\n    \"\"\"\n    Scorecard Plot.\n\n    Heatmap table displaying performance metrics across multiple dimensions\n    (e.g., Variables vs Lead Times), colored by performance relative to a baseline.\n\n    Functional Requirements:\n    1. Heatmap grid: Rows (Variables/Regions), Cols (Lead Times/Levels).\n    2. Color cells based on statistic (e.g., Difference from Baseline, RMSE ratio).\n    3. Annotate cells with symbols (+/-) or values indicating significance.\n    4. Handle Green (Better) / Red (Worse) color schemes correctly.\n\n    Edge Cases:\n    - Missing data for some cells (show as white/gray).\n    - Infinite values (clip or mask).\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        x_col: str,\n        y_col: str,\n        val_col: str,\n        sig_col: Optional[str] = None,\n        cmap: str = \"RdYlGn\",\n        center: float = 0.0,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Long-format dataframe.\n            x_col (str): Column for x-axis (Columns).\n            y_col (str): Column for y-axis (Rows).\n            val_col (str): Column for cell values (color).\n            sig_col (str, optional): Column for significance (marker).\n            cmap (str): Colormap.\n            center (float): Center value for colormap divergence.\n            **kwargs: Seaborn heatmap kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        validate_dataframe(df, required_columns=[x_col, y_col, val_col])\n\n        # Pivot Data\n        pivot_data = df.pivot(index=y_col, columns=x_col, values=val_col)\n\n        # TDD Anchor: Test pivot structure\n\n        # Plot Heatmap\n        sns.heatmap(\n            pivot_data,\n            ax=self.ax,\n            cmap=cmap,\n            center=center,\n            annot=True,\n            fmt=\".2f\",\n            cbar_kws={\"label\": \"Relative Performance\"},\n            **kwargs,\n        )\n\n        # Add Significance Markers\n        if sig_col:\n            pivot_sig = df.pivot(index=y_col, columns=x_col, values=sig_col)\n            self._overlay_significance(pivot_data, pivot_sig)\n\n        self.ax.set_xlabel(x_col.title())\n        self.ax.set_ylabel(y_col.title())\n        self.ax.tick_params(axis=\"x\", rotation=45)\n        self.ax.set_title(\"Performance Scorecard\")\n\n    def _overlay_significance(self, data_grid, sig_grid):\n        \"\"\"\n        Overlays markers for significant differences.\n\n        Assumes sig_grid contains boolean or truthy values for significance.\n        \"\"\"\n        rows, cols = data_grid.shape\n        for i in range(rows):\n            for j in range(cols):\n                sig_val = sig_grid.iloc[i, j]\n                if pd.notna(sig_val) and bool(sig_val):\n                    # Position at center of cell\n                    self.ax.text(\n                        j + 0.5,\n                        rows - i - 0.5,\n                        \"*\",\n                        ha=\"center\",\n                        va=\"center\",\n                        fontweight=\"bold\",\n                        fontsize=12,\n                        color=\"black\",\n                        zorder=5,\n                    )\n</code></pre>"},{"location":"api/#monet_plots.plots.ScorecardPlot.plot","title":"<code>plot(data, x_col, y_col, val_col, sig_col=None, cmap='RdYlGn', center=0.0, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Long-format dataframe.</p> required <code>x_col</code> <code>str</code> <p>Column for x-axis (Columns).</p> required <code>y_col</code> <code>str</code> <p>Column for y-axis (Rows).</p> required <code>val_col</code> <code>str</code> <p>Column for cell values (color).</p> required <code>sig_col</code> <code>str</code> <p>Column for significance (marker).</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Colormap.</p> <code>'RdYlGn'</code> <code>center</code> <code>float</code> <p>Center value for colormap divergence.</p> <code>0.0</code> <code>**kwargs</code> <p>Seaborn heatmap kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/scorecard.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    x_col: str,\n    y_col: str,\n    val_col: str,\n    sig_col: Optional[str] = None,\n    cmap: str = \"RdYlGn\",\n    center: float = 0.0,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Long-format dataframe.\n        x_col (str): Column for x-axis (Columns).\n        y_col (str): Column for y-axis (Rows).\n        val_col (str): Column for cell values (color).\n        sig_col (str, optional): Column for significance (marker).\n        cmap (str): Colormap.\n        center (float): Center value for colormap divergence.\n        **kwargs: Seaborn heatmap kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    validate_dataframe(df, required_columns=[x_col, y_col, val_col])\n\n    # Pivot Data\n    pivot_data = df.pivot(index=y_col, columns=x_col, values=val_col)\n\n    # TDD Anchor: Test pivot structure\n\n    # Plot Heatmap\n    sns.heatmap(\n        pivot_data,\n        ax=self.ax,\n        cmap=cmap,\n        center=center,\n        annot=True,\n        fmt=\".2f\",\n        cbar_kws={\"label\": \"Relative Performance\"},\n        **kwargs,\n    )\n\n    # Add Significance Markers\n    if sig_col:\n        pivot_sig = df.pivot(index=y_col, columns=x_col, values=sig_col)\n        self._overlay_significance(pivot_data, pivot_sig)\n\n    self.ax.set_xlabel(x_col.title())\n    self.ax.set_ylabel(y_col.title())\n    self.ax.tick_params(axis=\"x\", rotation=45)\n    self.ax.set_title(\"Performance Scorecard\")\n</code></pre>"},{"location":"api/#monet_plots.plots.SoccerPlot","title":"<code>SoccerPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Soccer plot for model evaluation.</p> <p>This plot shows model performance by plotting bias (x-axis) against error (y-axis). It typically includes 'goal' and 'criteria' zones to visually assess if the model meets specific performance standards.</p>"},{"location":"api/#monet_plots.plots.SoccerPlot--attributes","title":"Attributes","text":"<p>data : Union[pd.DataFrame, xr.Dataset, xr.DataArray]     The input data for the plot. bias_data : Union[pd.Series, xr.DataArray]     Calculated or provided bias values. error_data : Union[pd.Series, xr.DataArray]     Calculated or provided error values.</p> Source code in <code>src/monet_plots/plots/soccer.py</code> <pre><code>class SoccerPlot(BasePlot):\n    \"\"\"Soccer plot for model evaluation.\n\n    This plot shows model performance by plotting bias (x-axis) against error (y-axis).\n    It typically includes 'goal' and 'criteria' zones to visually assess if the\n    model meets specific performance standards.\n\n    Attributes\n    ----------\n    data : Union[pd.DataFrame, xr.Dataset, xr.DataArray]\n        The input data for the plot.\n    bias_data : Union[pd.Series, xr.DataArray]\n        Calculated or provided bias values.\n    error_data : Union[pd.Series, xr.DataArray]\n        Calculated or provided error values.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        *,\n        obs_col: Optional[str] = None,\n        mod_col: Optional[str] = None,\n        bias_col: Optional[str] = None,\n        error_col: Optional[str] = None,\n        label_col: Optional[str] = None,\n        metric: str = \"fractional\",\n        goal: Optional[Dict[str, float]] = {\"bias\": 30.0, \"error\": 50.0},\n        criteria: Optional[Dict[str, float]] = {\"bias\": 60.0, \"error\": 75.0},\n        fig: Optional[matplotlib.figure.Figure] = None,\n        ax: Optional[matplotlib.axes.Axes] = None,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize Soccer Plot.\n\n        Parameters\n        ----------\n        data : Any\n            Input data. Can be a pandas DataFrame, xarray DataArray,\n            xarray Dataset, or numpy ndarray.\n        obs_col : str, optional\n            Column name for observations. Required if bias/error not provided.\n        mod_col : str, optional\n            Column name for model values. Required if bias/error not provided.\n        bias_col : str, optional\n            Column name for pre-calculated bias.\n        error_col : str, optional\n            Column name for pre-calculated error.\n        label_col : str, optional\n            Column name for labeling points.\n        metric : str, optional\n            Type of metric to calculate if obs/mod provided ('fractional' or 'normalized'),\n            by default \"fractional\".\n        goal : Dict[str, float], optional\n            Dictionary with 'bias' and 'error' thresholds for the goal zone,\n            by default {\"bias\": 30.0, \"error\": 50.0}.\n        criteria : Dict[str, float], optional\n            Dictionary with 'bias' and 'error' thresholds for the criteria zone,\n            by default {\"bias\": 60.0, \"error\": 75.0}.\n        fig : matplotlib.figure.Figure, optional\n            An existing Figure object.\n        ax : matplotlib.axes.Axes, optional\n            An existing Axes object.\n        **kwargs : Any\n            Arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(fig=fig, ax=ax, **kwargs)\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1)\n\n        self.data = normalize_data(data)\n        self.bias_col = bias_col\n        self.error_col = error_col\n        self.label_col = label_col\n        self.metric = metric\n        self.goal = goal\n        self.criteria = criteria\n\n        # Track provenance for Xarray\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            history = self.data.attrs.get(\"history\", \"\")\n            self.data.attrs[\"history\"] = f\"Initialized SoccerPlot; {history}\"\n\n        if bias_col is None or error_col is None:\n            if obs_col is None or mod_col is None:\n                raise ValueError(\n                    \"Must provide either bias_col/error_col or obs_col/mod_col\"\n                )\n            self._calculate_metrics(obs_col, mod_col)\n        else:\n            self.bias_data = self.data[bias_col]\n            self.error_data = self.data[error_col]\n\n    def _calculate_metrics(self, obs_col: str, mod_col: str) -&gt; None:\n        \"\"\"Calculate MFB/MFE or NMB/NME using vectorized operations.\n\n        Parameters\n        ----------\n        obs_col : str\n            Column/variable name for observations.\n        mod_col : str\n            Column/variable name for model values.\n        \"\"\"\n        obs = self.data[obs_col]\n        mod = self.data[mod_col]\n\n        if self.metric == \"fractional\":\n            # Mean Fractional Bias and Error\n            denom = (obs + mod).astype(float)\n            num_bias = 200.0 * (mod - obs)\n            num_error = 200.0 * np.abs(mod - obs)\n\n            if isinstance(denom, xr.DataArray):\n                self.bias_data = (num_bias / denom).where(denom != 0, np.nan)\n                self.error_data = (num_error / denom).where(denom != 0, np.nan)\n            else:\n                self.bias_data = np.divide(\n                    num_bias, denom, out=np.full(denom.shape, np.nan), where=denom != 0\n                )\n                self.error_data = np.divide(\n                    num_error, denom, out=np.full(denom.shape, np.nan), where=denom != 0\n                )\n\n            self.xlabel = \"Mean Fractional Bias (%)\"\n            self.ylabel = \"Mean Fractional Error (%)\"\n\n        elif self.metric == \"normalized\":\n            # Normalized Mean Bias and Error\n            obs_float = obs.astype(float)\n            num_bias = 100.0 * (mod - obs)\n            num_error = 100.0 * np.abs(mod - obs)\n\n            if isinstance(obs_float, xr.DataArray):\n                self.bias_data = (num_bias / obs_float).where(obs_float != 0, np.nan)\n                self.error_data = (num_error / obs_float).where(obs_float != 0, np.nan)\n            else:\n                self.bias_data = np.divide(\n                    num_bias,\n                    obs_float,\n                    out=np.full(obs_float.shape, np.nan),\n                    where=obs_float != 0,\n                )\n                self.error_data = np.divide(\n                    num_error,\n                    obs_float,\n                    out=np.full(obs_float.shape, np.nan),\n                    where=obs_float != 0,\n                )\n\n            self.xlabel = \"Normalized Mean Bias (%)\"\n            self.ylabel = \"Normalized Mean Error (%)\"\n        else:\n            raise ValueError(\"metric must be 'fractional' or 'normalized'\")\n\n        # Update history if Xarray\n        if isinstance(self.bias_data, xr.DataArray):\n            history = self.bias_data.attrs.get(\"history\", \"\")\n            self.bias_data.attrs[\"history\"] = (\n                f\"Calculated {self.metric} soccer metrics; {history}\"\n            )\n\n    def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the soccer plot.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Keyword arguments passed to `ax.scatter`.\n\n        Returns\n        -------\n        matplotlib.axes.Axes\n            The axes object with the soccer plot.\n        \"\"\"\n        # Draw zones\n        if self.criteria:\n            rect_crit = patches.Rectangle(\n                (-self.criteria[\"bias\"], 0),\n                2 * self.criteria[\"bias\"],\n                self.criteria[\"error\"],\n                linewidth=1,\n                edgecolor=\"lightgrey\",\n                facecolor=\"lightgrey\",\n                alpha=0.3,\n                label=\"Criteria\",\n                zorder=0,\n            )\n            self.ax.add_patch(rect_crit)\n\n        if self.goal:\n            rect_goal = patches.Rectangle(\n                (-self.goal[\"bias\"], 0),\n                2 * self.goal[\"bias\"],\n                self.goal[\"error\"],\n                linewidth=1,\n                edgecolor=\"grey\",\n                facecolor=\"grey\",\n                alpha=0.3,\n                label=\"Goal\",\n                zorder=1,\n            )\n            self.ax.add_patch(rect_goal)\n\n        # Plot points - compute if lazy\n        bias = self.bias_data\n        error = self.error_data\n\n        if hasattr(bias, \"compute\"):\n            bias = bias.compute()\n        if hasattr(error, \"compute\"):\n            error = error.compute()\n\n        scatter_kwargs = {\"zorder\": 5}\n        scatter_kwargs.update(kwargs)\n        self.ax.scatter(bias, error, **scatter_kwargs)\n\n        # Labels\n        if self.label_col is not None:\n            labels = self.data[self.label_col]\n            if hasattr(labels, \"values\"):\n                labels = labels.values\n\n            for i, txt in enumerate(labels):\n                # Ensure we have scalar values for annotation\n                b_val = bias.iloc[i] if hasattr(bias, \"iloc\") else bias[i]\n                e_val = error.iloc[i] if hasattr(error, \"iloc\") else error[i]\n                self.ax.annotate(\n                    str(txt),\n                    (b_val, e_val),\n                    xytext=(5, 5),\n                    textcoords=\"offset points\",\n                )\n\n        # Setup axes\n        limit = 0\n        if self.criteria:\n            limit = max(limit, self.criteria[\"bias\"] * 1.1)\n            limit_y = self.criteria[\"error\"] * 1.1\n        else:\n            limit = max(limit, float(np.abs(bias).max()) * 1.1)\n            limit_y = float(error.max()) * 1.1\n\n        self.ax.set_xlim(-limit, limit)\n        self.ax.set_ylim(0, limit_y)\n\n        self.ax.axvline(0, color=\"k\", linestyle=\"--\", alpha=0.5)\n        self.ax.set_xlabel(getattr(self, \"xlabel\", \"Bias (%)\"))\n        self.ax.set_ylabel(getattr(self, \"ylabel\", \"Error (%)\"))\n        self.ax.grid(True, linestyle=\":\", alpha=0.6)\n\n        # Update history for provenance\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            history = self.data.attrs.get(\"history\", \"\")\n            self.data.attrs[\"history\"] = f\"Generated SoccerPlot; {history}\"\n\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.SoccerPlot.__init__","title":"<code>__init__(data, *, obs_col=None, mod_col=None, bias_col=None, error_col=None, label_col=None, metric='fractional', goal={'bias': 30.0, 'error': 50.0}, criteria={'bias': 60.0, 'error': 75.0}, fig=None, ax=None, **kwargs)</code>","text":"<p>Initialize Soccer Plot.</p>"},{"location":"api/#monet_plots.plots.SoccerPlot.__init__--parameters","title":"Parameters","text":"<p>data : Any     Input data. Can be a pandas DataFrame, xarray DataArray,     xarray Dataset, or numpy ndarray. obs_col : str, optional     Column name for observations. Required if bias/error not provided. mod_col : str, optional     Column name for model values. Required if bias/error not provided. bias_col : str, optional     Column name for pre-calculated bias. error_col : str, optional     Column name for pre-calculated error. label_col : str, optional     Column name for labeling points. metric : str, optional     Type of metric to calculate if obs/mod provided ('fractional' or 'normalized'),     by default \"fractional\". goal : Dict[str, float], optional     Dictionary with 'bias' and 'error' thresholds for the goal zone,     by default {\"bias\": 30.0, \"error\": 50.0}. criteria : Dict[str, float], optional     Dictionary with 'bias' and 'error' thresholds for the criteria zone,     by default {\"bias\": 60.0, \"error\": 75.0}. fig : matplotlib.figure.Figure, optional     An existing Figure object. ax : matplotlib.axes.Axes, optional     An existing Axes object. **kwargs : Any     Arguments passed to BasePlot.</p> Source code in <code>src/monet_plots/plots/soccer.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    *,\n    obs_col: Optional[str] = None,\n    mod_col: Optional[str] = None,\n    bias_col: Optional[str] = None,\n    error_col: Optional[str] = None,\n    label_col: Optional[str] = None,\n    metric: str = \"fractional\",\n    goal: Optional[Dict[str, float]] = {\"bias\": 30.0, \"error\": 50.0},\n    criteria: Optional[Dict[str, float]] = {\"bias\": 60.0, \"error\": 75.0},\n    fig: Optional[matplotlib.figure.Figure] = None,\n    ax: Optional[matplotlib.axes.Axes] = None,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize Soccer Plot.\n\n    Parameters\n    ----------\n    data : Any\n        Input data. Can be a pandas DataFrame, xarray DataArray,\n        xarray Dataset, or numpy ndarray.\n    obs_col : str, optional\n        Column name for observations. Required if bias/error not provided.\n    mod_col : str, optional\n        Column name for model values. Required if bias/error not provided.\n    bias_col : str, optional\n        Column name for pre-calculated bias.\n    error_col : str, optional\n        Column name for pre-calculated error.\n    label_col : str, optional\n        Column name for labeling points.\n    metric : str, optional\n        Type of metric to calculate if obs/mod provided ('fractional' or 'normalized'),\n        by default \"fractional\".\n    goal : Dict[str, float], optional\n        Dictionary with 'bias' and 'error' thresholds for the goal zone,\n        by default {\"bias\": 30.0, \"error\": 50.0}.\n    criteria : Dict[str, float], optional\n        Dictionary with 'bias' and 'error' thresholds for the criteria zone,\n        by default {\"bias\": 60.0, \"error\": 75.0}.\n    fig : matplotlib.figure.Figure, optional\n        An existing Figure object.\n    ax : matplotlib.axes.Axes, optional\n        An existing Axes object.\n    **kwargs : Any\n        Arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(fig=fig, ax=ax, **kwargs)\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1)\n\n    self.data = normalize_data(data)\n    self.bias_col = bias_col\n    self.error_col = error_col\n    self.label_col = label_col\n    self.metric = metric\n    self.goal = goal\n    self.criteria = criteria\n\n    # Track provenance for Xarray\n    if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n        history = self.data.attrs.get(\"history\", \"\")\n        self.data.attrs[\"history\"] = f\"Initialized SoccerPlot; {history}\"\n\n    if bias_col is None or error_col is None:\n        if obs_col is None or mod_col is None:\n            raise ValueError(\n                \"Must provide either bias_col/error_col or obs_col/mod_col\"\n            )\n        self._calculate_metrics(obs_col, mod_col)\n    else:\n        self.bias_data = self.data[bias_col]\n        self.error_data = self.data[error_col]\n</code></pre>"},{"location":"api/#monet_plots.plots.SoccerPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the soccer plot.</p>"},{"location":"api/#monet_plots.plots.SoccerPlot.plot--parameters","title":"Parameters","text":"<p>**kwargs : Any     Keyword arguments passed to <code>ax.scatter</code>.</p>"},{"location":"api/#monet_plots.plots.SoccerPlot.plot--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The axes object with the soccer plot.</p> Source code in <code>src/monet_plots/plots/soccer.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the soccer plot.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Keyword arguments passed to `ax.scatter`.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The axes object with the soccer plot.\n    \"\"\"\n    # Draw zones\n    if self.criteria:\n        rect_crit = patches.Rectangle(\n            (-self.criteria[\"bias\"], 0),\n            2 * self.criteria[\"bias\"],\n            self.criteria[\"error\"],\n            linewidth=1,\n            edgecolor=\"lightgrey\",\n            facecolor=\"lightgrey\",\n            alpha=0.3,\n            label=\"Criteria\",\n            zorder=0,\n        )\n        self.ax.add_patch(rect_crit)\n\n    if self.goal:\n        rect_goal = patches.Rectangle(\n            (-self.goal[\"bias\"], 0),\n            2 * self.goal[\"bias\"],\n            self.goal[\"error\"],\n            linewidth=1,\n            edgecolor=\"grey\",\n            facecolor=\"grey\",\n            alpha=0.3,\n            label=\"Goal\",\n            zorder=1,\n        )\n        self.ax.add_patch(rect_goal)\n\n    # Plot points - compute if lazy\n    bias = self.bias_data\n    error = self.error_data\n\n    if hasattr(bias, \"compute\"):\n        bias = bias.compute()\n    if hasattr(error, \"compute\"):\n        error = error.compute()\n\n    scatter_kwargs = {\"zorder\": 5}\n    scatter_kwargs.update(kwargs)\n    self.ax.scatter(bias, error, **scatter_kwargs)\n\n    # Labels\n    if self.label_col is not None:\n        labels = self.data[self.label_col]\n        if hasattr(labels, \"values\"):\n            labels = labels.values\n\n        for i, txt in enumerate(labels):\n            # Ensure we have scalar values for annotation\n            b_val = bias.iloc[i] if hasattr(bias, \"iloc\") else bias[i]\n            e_val = error.iloc[i] if hasattr(error, \"iloc\") else error[i]\n            self.ax.annotate(\n                str(txt),\n                (b_val, e_val),\n                xytext=(5, 5),\n                textcoords=\"offset points\",\n            )\n\n    # Setup axes\n    limit = 0\n    if self.criteria:\n        limit = max(limit, self.criteria[\"bias\"] * 1.1)\n        limit_y = self.criteria[\"error\"] * 1.1\n    else:\n        limit = max(limit, float(np.abs(bias).max()) * 1.1)\n        limit_y = float(error.max()) * 1.1\n\n    self.ax.set_xlim(-limit, limit)\n    self.ax.set_ylim(0, limit_y)\n\n    self.ax.axvline(0, color=\"k\", linestyle=\"--\", alpha=0.5)\n    self.ax.set_xlabel(getattr(self, \"xlabel\", \"Bias (%)\"))\n    self.ax.set_ylabel(getattr(self, \"ylabel\", \"Error (%)\"))\n    self.ax.grid(True, linestyle=\":\", alpha=0.6)\n\n    # Update history for provenance\n    if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n        history = self.data.attrs.get(\"history\", \"\")\n        self.data.attrs[\"history\"] = f\"Generated SoccerPlot; {history}\"\n\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialBiasScatterPlot","title":"<code>SpatialBiasScatterPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a spatial scatter plot showing bias between model and observations.</p> <p>The scatter points are colored by the difference (CMAQ - Obs) and sized by the absolute magnitude of this difference, making larger biases more visible.</p> Source code in <code>src/monet_plots/plots/spatial_bias_scatter.py</code> <pre><code>class SpatialBiasScatterPlot(SpatialPlot):\n    \"\"\"Create a spatial scatter plot showing bias between model and observations.\n\n    The scatter points are colored by the difference (CMAQ - Obs) and sized\n    by the absolute magnitude of this difference, making larger biases more visible.\n    \"\"\"\n\n    def __init__(\n        self,\n        df: Any,\n        col1: str,\n        col2: str,\n        vmin: float = None,\n        vmax: float = None,\n        ncolors: int = 15,\n        fact: float = 1.5,\n        cmap: str = \"RdBu_r\",\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with 'latitude', 'longitude', and data columns.\n            col1 (str): Name of the first column (e.g., observations).\n            col2 (str): Name of the second column (e.g., model). Bias is calculated as col2 - col1.\n            vmin (float, optional): Minimum for colorscale.\n            vmax (float, optional): Maximum for colorscale.\n            ncolors (int): Number of discrete colors.\n            fact (float): Scaling factor for point sizes.\n            cmap (str or Colormap): Colormap for bias values.\n            **kwargs: Additional keyword arguments for map creation, passed to\n                      :class:`monet_plots.plots.spatial.SpatialPlot`. These\n                      include `projection`, `figsize`, `ax`, and cartopy\n                      features like `states`, `coastlines`, etc.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.df = to_dataframe(df)\n        self.col1 = col1\n        self.col2 = col2\n        self.vmin = vmin\n        self.vmax = vmax\n        self.ncolors = ncolors\n        self.fact = fact\n        self.cmap = cmap\n\n    def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the spatial bias scatter plot.\"\"\"\n        from numpy import around\n\n        # Separate feature kwargs from scatter kwargs\n        scatter_kwargs = self.add_features(**kwargs)\n\n        # Ensure we are working with a clean copy with no NaNs in relevant columns\n        new = (\n            self.df[[\"latitude\", \"longitude\", self.col1, self.col2]]\n            .dropna()\n            .copy(deep=True)\n        )\n\n        diff = new[self.col2] - new[self.col1]\n        top = around(score(diff.abs(), per=95))\n\n        # Use new scaling tools\n        cmap, norm = get_discrete_scale(\n            diff, cmap=self.cmap, n_levels=self.ncolors, vmin=-top, vmax=top\n        )\n\n        # Create colorbar\n        mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n        cbar = self.add_colorbar(mappable, format=\"%1.2g\")\n        cbar.ax.tick_params(labelsize=10)\n\n        colors = diff\n        ss = diff.abs() / top * 100.0\n        ss[ss &gt; 300] = 300.0\n\n        # Prepare scatter kwargs\n        final_scatter_kwargs = get_plot_kwargs(\n            cmap=cmap,\n            norm=norm,\n            s=ss,\n            c=colors,\n            transform=ccrs.PlateCarree(),\n            edgecolors=\"k\",\n            linewidths=0.25,\n            alpha=0.7,\n            **scatter_kwargs,\n        )\n\n        self.ax.scatter(\n            new.longitude.values,\n            new.latitude.values,\n            **final_scatter_kwargs,\n        )\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialBiasScatterPlot.__init__","title":"<code>__init__(df, col1, col2, vmin=None, vmax=None, ncolors=15, fact=1.5, cmap='RdBu_r', **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>DataFrame with 'latitude', 'longitude', and data columns.</p> required <code>col1</code> <code>str</code> <p>Name of the first column (e.g., observations).</p> required <code>col2</code> <code>str</code> <p>Name of the second column (e.g., model). Bias is calculated as col2 - col1.</p> required <code>vmin</code> <code>float</code> <p>Minimum for colorscale.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum for colorscale.</p> <code>None</code> <code>ncolors</code> <code>int</code> <p>Number of discrete colors.</p> <code>15</code> <code>fact</code> <code>float</code> <p>Scaling factor for point sizes.</p> <code>1.5</code> <code>cmap</code> <code>str or Colormap</code> <p>Colormap for bias values.</p> <code>'RdBu_r'</code> <code>**kwargs</code> <p>Additional keyword arguments for map creation, passed to       :class:<code>monet_plots.plots.spatial.SpatialPlot</code>. These       include <code>projection</code>, <code>figsize</code>, <code>ax</code>, and cartopy       features like <code>states</code>, <code>coastlines</code>, etc.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/spatial_bias_scatter.py</code> <pre><code>def __init__(\n    self,\n    df: Any,\n    col1: str,\n    col2: str,\n    vmin: float = None,\n    vmax: float = None,\n    ncolors: int = 15,\n    fact: float = 1.5,\n    cmap: str = \"RdBu_r\",\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with 'latitude', 'longitude', and data columns.\n        col1 (str): Name of the first column (e.g., observations).\n        col2 (str): Name of the second column (e.g., model). Bias is calculated as col2 - col1.\n        vmin (float, optional): Minimum for colorscale.\n        vmax (float, optional): Maximum for colorscale.\n        ncolors (int): Number of discrete colors.\n        fact (float): Scaling factor for point sizes.\n        cmap (str or Colormap): Colormap for bias values.\n        **kwargs: Additional keyword arguments for map creation, passed to\n                  :class:`monet_plots.plots.spatial.SpatialPlot`. These\n                  include `projection`, `figsize`, `ax`, and cartopy\n                  features like `states`, `coastlines`, etc.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.df = to_dataframe(df)\n    self.col1 = col1\n    self.col2 = col2\n    self.vmin = vmin\n    self.vmax = vmax\n    self.ncolors = ncolors\n    self.fact = fact\n    self.cmap = cmap\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialBiasScatterPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spatial bias scatter plot.</p> Source code in <code>src/monet_plots/plots/spatial_bias_scatter.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the spatial bias scatter plot.\"\"\"\n    from numpy import around\n\n    # Separate feature kwargs from scatter kwargs\n    scatter_kwargs = self.add_features(**kwargs)\n\n    # Ensure we are working with a clean copy with no NaNs in relevant columns\n    new = (\n        self.df[[\"latitude\", \"longitude\", self.col1, self.col2]]\n        .dropna()\n        .copy(deep=True)\n    )\n\n    diff = new[self.col2] - new[self.col1]\n    top = around(score(diff.abs(), per=95))\n\n    # Use new scaling tools\n    cmap, norm = get_discrete_scale(\n        diff, cmap=self.cmap, n_levels=self.ncolors, vmin=-top, vmax=top\n    )\n\n    # Create colorbar\n    mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n    cbar = self.add_colorbar(mappable, format=\"%1.2g\")\n    cbar.ax.tick_params(labelsize=10)\n\n    colors = diff\n    ss = diff.abs() / top * 100.0\n    ss[ss &gt; 300] = 300.0\n\n    # Prepare scatter kwargs\n    final_scatter_kwargs = get_plot_kwargs(\n        cmap=cmap,\n        norm=norm,\n        s=ss,\n        c=colors,\n        transform=ccrs.PlateCarree(),\n        edgecolors=\"k\",\n        linewidths=0.25,\n        alpha=0.7,\n        **scatter_kwargs,\n    )\n\n    self.ax.scatter(\n        new.longitude.values,\n        new.latitude.values,\n        **final_scatter_kwargs,\n    )\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialContourPlot","title":"<code>SpatialContourPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a contour plot on a map with an optional discrete colorbar.</p> <p>This plot is useful for visualizing spatial data with continuous values.</p> Source code in <code>src/monet_plots/plots/spatial_contour.py</code> <pre><code>class SpatialContourPlot(SpatialPlot):\n    \"\"\"Create a contour plot on a map with an optional discrete colorbar.\n\n    This plot is useful for visualizing spatial data with continuous values.\n    \"\"\"\n\n    def __init__(\n        self,\n        modelvar: Any,\n        gridobj,\n        date=None,\n        discrete: bool = True,\n        ncolors: int = None,\n        dtype: str = \"int\",\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n                2D model variable array to contour.\n            modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n                2D model variable array to contour.\n            gridobj (object): Object with LAT and LON variables.\n            date (datetime.datetime): Date/time for the plot title.\n            discrete (bool): If True, use a discrete colorbar.\n            ncolors (int, optional): Number of discrete colors.\n            dtype (str): Data type for colorbar tick labels.\n            **kwargs: Keyword arguments passed to SpatialPlot for\n                projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.modelvar = np.asarray(modelvar)\n        self.gridobj = gridobj\n        self.date = date\n        self.discrete = discrete\n        self.ncolors = ncolors\n        self.dtype = dtype\n\n    def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the spatial contour plot.\"\"\"\n        # Draw map features and get remaining kwargs for contourf\n        plot_kwargs = self.add_features(**kwargs)\n\n        # Try to handle different gridobj structures\n        if hasattr(self.gridobj, \"variables\"):\n            lat_var = self.gridobj.variables[\"LAT\"]\n            lon_var = self.gridobj.variables[\"LON\"]\n\n            # Flexible indexing based on dimension count\n            if lat_var.ndim == 4:\n                lat = lat_var[0, 0, :, :].squeeze()\n                lon = lon_var[0, 0, :, :].squeeze()\n            elif lat_var.ndim == 3:\n                lat = lat_var[0, :, :].squeeze()\n                lon = lon_var[0, :, :].squeeze()\n            else:\n                lat = lat_var.squeeze()\n                lon = lon_var.squeeze()\n        else:\n            # Assume it's already an array or similar\n            lat = self.gridobj.LAT\n            lon = self.gridobj.LON\n\n        # Data is in lat/lon, so specify transform\n        plot_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        mesh = self.ax.contourf(lon, lat, self.modelvar, **plot_kwargs)\n\n        cmap = plot_kwargs.get(\"cmap\")\n        levels = plot_kwargs.get(\"levels\")\n\n        if self.discrete:\n            ncolors = self.ncolors\n            if ncolors is None and levels is not None:\n                # If levels is an int, convert to a sequence for len()\n                if isinstance(levels, int):\n                    ncolors = levels - 1\n                    levels_seq = np.linspace(\n                        np.nanmin(self.modelvar), np.nanmax(self.modelvar), levels\n                    )\n                else:\n                    ncolors = len(levels) - 1\n                    levels_seq = levels\n            else:\n                levels_seq = levels\n            c, _ = colorbar_index(\n                ncolors,\n                cmap,\n                minval=levels_seq[0],\n                maxval=levels_seq[-1],\n                dtype=self.dtype,\n                ax=self.ax,\n            )\n        else:\n            self.add_colorbar(mesh)\n\n        if self.date:\n            titstring = self.date.strftime(\"%B %d %Y %H\")\n            self.ax.set_title(titstring)\n        self.fig.tight_layout()\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialContourPlot.__init__","title":"<code>__init__(modelvar, gridobj, date=None, discrete=True, ncolors=None, dtype='int', *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>modelvar</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D model variable array to contour.</p> required <code>modelvar</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D model variable array to contour.</p> required <code>gridobj</code> <code>object</code> <p>Object with LAT and LON variables.</p> required <code>date</code> <code>datetime</code> <p>Date/time for the plot title.</p> <code>None</code> <code>discrete</code> <code>bool</code> <p>If True, use a discrete colorbar.</p> <code>True</code> <code>ncolors</code> <code>int</code> <p>Number of discrete colors.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>Data type for colorbar tick labels.</p> <code>'int'</code> <code>**kwargs</code> <p>Keyword arguments passed to SpatialPlot for projection and features.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/spatial_contour.py</code> <pre><code>def __init__(\n    self,\n    modelvar: Any,\n    gridobj,\n    date=None,\n    discrete: bool = True,\n    ncolors: int = None,\n    dtype: str = \"int\",\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n            2D model variable array to contour.\n        modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n            2D model variable array to contour.\n        gridobj (object): Object with LAT and LON variables.\n        date (datetime.datetime): Date/time for the plot title.\n        discrete (bool): If True, use a discrete colorbar.\n        ncolors (int, optional): Number of discrete colors.\n        dtype (str): Data type for colorbar tick labels.\n        **kwargs: Keyword arguments passed to SpatialPlot for\n            projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.modelvar = np.asarray(modelvar)\n    self.gridobj = gridobj\n    self.date = date\n    self.discrete = discrete\n    self.ncolors = ncolors\n    self.dtype = dtype\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialContourPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spatial contour plot.</p> Source code in <code>src/monet_plots/plots/spatial_contour.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the spatial contour plot.\"\"\"\n    # Draw map features and get remaining kwargs for contourf\n    plot_kwargs = self.add_features(**kwargs)\n\n    # Try to handle different gridobj structures\n    if hasattr(self.gridobj, \"variables\"):\n        lat_var = self.gridobj.variables[\"LAT\"]\n        lon_var = self.gridobj.variables[\"LON\"]\n\n        # Flexible indexing based on dimension count\n        if lat_var.ndim == 4:\n            lat = lat_var[0, 0, :, :].squeeze()\n            lon = lon_var[0, 0, :, :].squeeze()\n        elif lat_var.ndim == 3:\n            lat = lat_var[0, :, :].squeeze()\n            lon = lon_var[0, :, :].squeeze()\n        else:\n            lat = lat_var.squeeze()\n            lon = lon_var.squeeze()\n    else:\n        # Assume it's already an array or similar\n        lat = self.gridobj.LAT\n        lon = self.gridobj.LON\n\n    # Data is in lat/lon, so specify transform\n    plot_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    mesh = self.ax.contourf(lon, lat, self.modelvar, **plot_kwargs)\n\n    cmap = plot_kwargs.get(\"cmap\")\n    levels = plot_kwargs.get(\"levels\")\n\n    if self.discrete:\n        ncolors = self.ncolors\n        if ncolors is None and levels is not None:\n            # If levels is an int, convert to a sequence for len()\n            if isinstance(levels, int):\n                ncolors = levels - 1\n                levels_seq = np.linspace(\n                    np.nanmin(self.modelvar), np.nanmax(self.modelvar), levels\n                )\n            else:\n                ncolors = len(levels) - 1\n                levels_seq = levels\n        else:\n            levels_seq = levels\n        c, _ = colorbar_index(\n            ncolors,\n            cmap,\n            minval=levels_seq[0],\n            maxval=levels_seq[-1],\n            dtype=self.dtype,\n            ax=self.ax,\n        )\n    else:\n        self.add_colorbar(mesh)\n\n    if self.date:\n        titstring = self.date.strftime(\"%B %d %Y %H\")\n        self.ax.set_title(titstring)\n    self.fig.tight_layout()\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialImshowPlot","title":"<code>SpatialImshowPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a basic spatial plot using imshow.</p> <p>This plot is useful for visualizing 2D model data on a map.</p> Source code in <code>src/monet_plots/plots/spatial_imshow.py</code> <pre><code>class SpatialImshowPlot(SpatialPlot):\n    \"\"\"Create a basic spatial plot using imshow.\n\n    This plot is useful for visualizing 2D model data on a map.\n    \"\"\"\n\n    def __init__(\n        self,\n        modelvar: Any,\n        gridobj: Any | None = None,\n        plotargs: dict[str, Any] | None = None,\n        ncolors: int = 15,\n        discrete: bool = False,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Parameters\n        ----------\n        modelvar : xarray.DataArray or array-like\n            2D model variable array to plot.\n        gridobj : Any, optional\n            Object with LAT and LON variables to determine extent.\n        plotargs : dict, optional\n            Arguments for imshow.\n        ncolors : int, optional\n            Number of discrete colors for discrete colorbar.\n        discrete : bool, optional\n            If True, use a discrete colorbar.\n        *args : Any\n            Positional arguments for SpatialPlot.\n        **kwargs : Any\n            Keyword arguments passed to SpatialPlot for projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.modelvar = modelvar\n        self.gridobj = gridobj\n        self.plotargs = plotargs\n        self.ncolors = ncolors\n        self.discrete = discrete\n\n    def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the spatial imshow plot.\n\n        Returns\n        -------\n        matplotlib.axes.Axes\n            The axes object containing the plot.\n        \"\"\"\n        imshow_kwargs = self.add_features(**kwargs)\n        if self.plotargs:\n            imshow_kwargs.update(self.plotargs)\n\n        # Handle eager vs lazy data by delaying conversion until plotting\n        # we still eventually need a numpy array for imshow.\n        model_data = np.asarray(self.modelvar)\n\n        if self.gridobj is not None:\n            lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n            lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n            extent = [lon.min(), lon.max(), lat.min(), lat.max()]\n        elif hasattr(self.modelvar, \"lat\") and hasattr(self.modelvar, \"lon\"):\n            lat = self.modelvar.lat\n            lon = self.modelvar.lon\n            extent = [lon.min(), lon.max(), lat.min(), lat.max()]\n        else:\n            # Fallback to extent from plotargs or default\n            extent = imshow_kwargs.get(\"extent\", None)\n\n        # imshow requires the extent [lon_min, lon_max, lat_min, lat_max]\n\n        imshow_kwargs.setdefault(\"cmap\", \"viridis\")\n        imshow_kwargs.setdefault(\"origin\", \"lower\")\n        imshow_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        img = self.ax.imshow(model_data, extent=extent, **imshow_kwargs)\n\n        if self.discrete:\n            vmin, vmax = img.get_clim()\n            colorbar_index(\n                self.ncolors,\n                imshow_kwargs[\"cmap\"],\n                minval=vmin,\n                maxval=vmax,\n                ax=self.ax,\n            )\n        else:\n            self.add_colorbar(img)\n\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialImshowPlot.__init__","title":"<code>__init__(modelvar, gridobj=None, plotargs=None, ncolors=15, discrete=False, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p>"},{"location":"api/#monet_plots.plots.SpatialImshowPlot.__init__--parameters","title":"Parameters","text":"<p>modelvar : xarray.DataArray or array-like     2D model variable array to plot. gridobj : Any, optional     Object with LAT and LON variables to determine extent. plotargs : dict, optional     Arguments for imshow. ncolors : int, optional     Number of discrete colors for discrete colorbar. discrete : bool, optional     If True, use a discrete colorbar. args : Any     Positional arguments for SpatialPlot. *kwargs : Any     Keyword arguments passed to SpatialPlot for projection and features.</p> Source code in <code>src/monet_plots/plots/spatial_imshow.py</code> <pre><code>def __init__(\n    self,\n    modelvar: Any,\n    gridobj: Any | None = None,\n    plotargs: dict[str, Any] | None = None,\n    ncolors: int = 15,\n    discrete: bool = False,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Parameters\n    ----------\n    modelvar : xarray.DataArray or array-like\n        2D model variable array to plot.\n    gridobj : Any, optional\n        Object with LAT and LON variables to determine extent.\n    plotargs : dict, optional\n        Arguments for imshow.\n    ncolors : int, optional\n        Number of discrete colors for discrete colorbar.\n    discrete : bool, optional\n        If True, use a discrete colorbar.\n    *args : Any\n        Positional arguments for SpatialPlot.\n    **kwargs : Any\n        Keyword arguments passed to SpatialPlot for projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.modelvar = modelvar\n    self.gridobj = gridobj\n    self.plotargs = plotargs\n    self.ncolors = ncolors\n    self.discrete = discrete\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialImshowPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spatial imshow plot.</p>"},{"location":"api/#monet_plots.plots.SpatialImshowPlot.plot--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The axes object containing the plot.</p> Source code in <code>src/monet_plots/plots/spatial_imshow.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the spatial imshow plot.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The axes object containing the plot.\n    \"\"\"\n    imshow_kwargs = self.add_features(**kwargs)\n    if self.plotargs:\n        imshow_kwargs.update(self.plotargs)\n\n    # Handle eager vs lazy data by delaying conversion until plotting\n    # we still eventually need a numpy array for imshow.\n    model_data = np.asarray(self.modelvar)\n\n    if self.gridobj is not None:\n        lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n        lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n        extent = [lon.min(), lon.max(), lat.min(), lat.max()]\n    elif hasattr(self.modelvar, \"lat\") and hasattr(self.modelvar, \"lon\"):\n        lat = self.modelvar.lat\n        lon = self.modelvar.lon\n        extent = [lon.min(), lon.max(), lat.min(), lat.max()]\n    else:\n        # Fallback to extent from plotargs or default\n        extent = imshow_kwargs.get(\"extent\", None)\n\n    # imshow requires the extent [lon_min, lon_max, lat_min, lat_max]\n\n    imshow_kwargs.setdefault(\"cmap\", \"viridis\")\n    imshow_kwargs.setdefault(\"origin\", \"lower\")\n    imshow_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    img = self.ax.imshow(model_data, extent=extent, **imshow_kwargs)\n\n    if self.discrete:\n        vmin, vmax = img.get_clim()\n        colorbar_index(\n            self.ncolors,\n            imshow_kwargs[\"cmap\"],\n            minval=vmin,\n            maxval=vmax,\n            ax=self.ax,\n        )\n    else:\n        self.add_colorbar(img)\n\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialPlot","title":"<code>SpatialPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>A base class for creating spatial plots with cartopy.</p> <p>This class provides a high-level interface for geospatial plots, handling the setup of cartopy axes and the addition of common map features like coastlines, states, and gridlines.</p>"},{"location":"api/#monet_plots.plots.SpatialPlot--attributes","title":"Attributes","text":"<p>resolution : str     The resolution of the cartopy features (e.g., '50m').</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>class SpatialPlot(BasePlot):\n    \"\"\"A base class for creating spatial plots with cartopy.\n\n    This class provides a high-level interface for geospatial plots, handling\n    the setup of cartopy axes and the addition of common map features like\n    coastlines, states, and gridlines.\n\n    Attributes\n    ----------\n    resolution : str\n        The resolution of the cartopy features (e.g., '50m').\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        projection: ccrs.Projection = ccrs.PlateCarree(),\n        fig: matplotlib.figure.Figure | None = None,\n        ax: matplotlib.axes.Axes | None = None,\n        figsize: tuple[float, float] | None = None,\n        subplot_kw: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize the spatial plot and draw map features.\n\n        This constructor sets up the matplotlib Figure and cartopy GeoAxes,\n        and provides a single interface to draw common map features like\n        coastlines and states.\n\n        Parameters\n        ----------\n        projection : ccrs.Projection, optional\n            The cartopy projection for the map, by default ccrs.PlateCarree().\n        fig : plt.Figure | None, optional\n            An existing matplotlib Figure object. If None, a new one is\n            created, by default None.\n        ax : plt.Axes | None, optional\n            An existing matplotlib Axes object. If None, a new one is created,\n            by default None.\n        figsize : tuple[float, float] | None, optional\n             Width, height in inches. If not provided, the matplotlib default\n             will be used.\n        subplot_kw : dict[str, Any] | None, optional\n            Keyword arguments passed to `fig.add_subplot`, by default None.\n            The 'projection' is added to these keywords automatically.\n        **kwargs : Any\n            Keyword arguments for map features, passed to `add_features`.\n            Common options include `coastlines`, `states`, `countries`,\n            `ocean`, `land`, `lakes`, `rivers`, `borders`, `gridlines`,\n            `extent`, and `resolution`.\n\n        Attributes\n        ----------\n        fig : plt.Figure\n            The matplotlib Figure object.\n        ax : plt.Axes\n            The matplotlib Axes (or GeoAxes) object.\n        resolution : str\n            The default resolution for cartopy features.\n        \"\"\"\n        # Ensure 'projection' is correctly passed to subplot creation.\n        current_subplot_kw = subplot_kw.copy() if subplot_kw else {}\n        current_subplot_kw[\"projection\"] = projection\n\n        self.resolution = kwargs.pop(\"resolution\", \"50m\")\n        style = kwargs.pop(\"style\", \"wiley\")\n\n        # Ensure coastlines are enabled by default if not specified.\n        if \"coastlines\" not in kwargs:\n            kwargs[\"coastlines\"] = True\n\n        # Initialize the base plot, which creates the figure and axes.\n        super().__init__(\n            fig=fig, ax=ax, figsize=figsize, style=style, subplot_kw=current_subplot_kw\n        )\n\n        # If BasePlot didn't create an axes (e.g. because fig was provided),\n        # create one now.\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1, **current_subplot_kw)\n\n        # If BasePlot didn't create an axes (e.g. because fig was provided),\n        # create one now.\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1, **current_subplot_kw)\n\n        # Add features from kwargs\n        self.add_features(**kwargs)\n\n    def _get_feature_registry(self, resolution: str) -&gt; dict[str, dict[str, Any]]:\n        \"\"\"Return a registry of cartopy features and their default styles.\n\n        This approach centralizes feature management, making it easier to\n        add new features and maintain existing ones.\n\n        Parameters\n        ----------\n        resolution : str\n            The resolution for the cartopy features (e.g., '10m', '50m').\n\n        Returns\n        -------\n        dict[str, dict[str, Any]]\n            A dictionary mapping feature names to a specification dictionary\n            containing the feature object and its default styling.\n        \"\"\"\n        from cartopy.feature import (\n            BORDERS,\n            COASTLINE,\n            LAKES,\n            LAND,\n            OCEAN,\n            RIVERS,\n            STATES,\n        )\n\n        # Define default styles, falling back to sane defaults if not in rcParams.\n        coastline_defaults = {\n            \"linewidth\": get_style_setting(\"coastline.width\", 0.5),\n            \"edgecolor\": get_style_setting(\"coastline.color\", \"black\"),\n            \"facecolor\": \"none\",\n        }\n        states_defaults = {\n            \"linewidth\": get_style_setting(\"states.width\", 0.5),\n            \"edgecolor\": get_style_setting(\"states.color\", \"black\"),\n            \"facecolor\": \"none\",\n        }\n        borders_defaults = {\n            \"linewidth\": get_style_setting(\"borders.width\", 0.5),\n            \"edgecolor\": get_style_setting(\"borders.color\", \"black\"),\n            \"facecolor\": \"none\",\n        }\n\n        feature_mapping = {\n            \"coastlines\": {\n                \"feature\": COASTLINE.with_scale(resolution),\n                \"defaults\": coastline_defaults,\n            },\n            \"countries\": {\n                \"feature\": BORDERS.with_scale(resolution),\n                \"defaults\": borders_defaults,\n            },\n            \"states\": {\n                \"feature\": STATES.with_scale(resolution),\n                \"defaults\": states_defaults,\n            },\n            \"borders\": {\n                \"feature\": BORDERS.with_scale(resolution),\n                \"defaults\": borders_defaults,\n            },\n            \"ocean\": {\"feature\": OCEAN.with_scale(resolution), \"defaults\": {}},\n            \"land\": {\"feature\": LAND.with_scale(resolution), \"defaults\": {}},\n            \"rivers\": {\"feature\": RIVERS.with_scale(resolution), \"defaults\": {}},\n            \"lakes\": {\"feature\": LAKES.with_scale(resolution), \"defaults\": {}},\n            \"counties\": {\n                \"feature\": cfeature.NaturalEarthFeature(\n                    category=\"cultural\",\n                    name=\"admin_2_counties\",\n                    scale=resolution,\n                    facecolor=\"none\",\n                ),\n                \"defaults\": borders_defaults,\n            },\n        }\n        return feature_mapping\n\n    @staticmethod\n    def _get_style(\n        style: bool | dict[str, Any], defaults: dict[str, Any] | None = None\n    ) -&gt; dict[str, Any]:\n        \"\"\"Get a style dictionary for a feature.\n\n        Parameters\n        ----------\n        style : bool or dict[str, Any]\n            The user-provided style. If True, use defaults. If a dict, use it.\n        defaults : dict[str, Any], optional\n            The default style to apply if `style` is True.\n\n        Returns\n        -------\n        dict[str, Any]\n            The resolved keyword arguments for styling.\n        \"\"\"\n        if isinstance(style, dict):\n            return style\n        if style and defaults:\n            # Return a copy to prevent modifying the defaults dictionary in place\n            return defaults.copy()\n        return {}\n\n    def _draw_single_feature(\n        self, style_arg: bool | dict[str, Any], feature_spec: dict[str, Any]\n    ) -&gt; None:\n        \"\"\"Draw a single cartopy feature on the axes.\n\n        Parameters\n        ----------\n        style_arg : bool or dict[str, Any]\n            The user-provided style for the feature.\n        feature_spec : dict[str, Any]\n            A dictionary containing the feature object and default styles.\n        \"\"\"\n        if not style_arg:  # Allows for `coastlines=False`\n            return\n\n        style_kwargs = self._get_style(style_arg, feature_spec[\"defaults\"])\n        feature = feature_spec[\"feature\"]\n        self.ax.add_feature(feature, **style_kwargs)\n\n    def add_features(self, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Add and style cartopy features on the map axes.\n\n        This method provides a flexible, data-driven interface to add common\n        map features. Features can be enabled with a boolean flag (e.g.,\n        `coastlines=True`) or styled with a dictionary of keyword arguments\n        (e.g., `states=dict(linewidth=2, edgecolor='red')`).\n\n        The `extent` keyword is also supported to set the map boundaries.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Keyword arguments controlling the features to add and their\n            styles. Common options include `coastlines`, `states`,\n            `countries`, `ocean`, `land`, `lakes`, `rivers`, `borders`,\n            and `gridlines`.\n\n        Returns\n        -------\n        dict[str, Any]\n            A dictionary of the keyword arguments that were not used for\n            adding features. This can be useful for passing remaining\n            arguments to other functions.\n        \"\"\"\n        # Note: The order of these calls is important.\n        # Extent must be set before gridlines are drawn to ensure labels\n        # are placed correctly.\n        if \"extent\" in kwargs:\n            extent = kwargs.pop(\"extent\")\n            self._set_extent(extent)\n\n        if \"gridlines\" in kwargs:\n            gridline_style = kwargs.pop(\"gridlines\")\n            self._draw_gridlines(gridline_style)\n\n        # The rest of the kwargs are assumed to be for vector features.\n        remaining_kwargs = self._draw_features(**kwargs)\n\n        return remaining_kwargs\n\n    def _set_extent(self, extent: tuple[float, float, float, float] | None) -&gt; None:\n        \"\"\"Set the geographic extent of the map.\n\n        Parameters\n        ----------\n        extent : tuple[float, float, float, float] | None\n            The extent of the map as a tuple of (x_min, x_max, y_min, y_max).\n            If None, the extent is not changed.\n        \"\"\"\n        if extent is not None:\n            self.ax.set_extent(extent)\n\n    def _draw_features(self, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Draw vector features on the map.\n\n        This is the primary feature-drawing loop, responsible for adding\n        elements like coastlines, states, and borders.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Keyword arguments controlling the features to add and their\n            styles.\n\n        Returns\n        -------\n        dict[str, Any]\n            A dictionary of the keyword arguments that were not used for\n            adding features.\n        \"\"\"\n        resolution = kwargs.pop(\"resolution\", self.resolution)\n        feature_registry = self._get_feature_registry(resolution)\n\n        # If natural_earth is True, enable a standard set of features\n        if kwargs.pop(\"natural_earth\", False):\n            for feature in [\"ocean\", \"land\", \"lakes\", \"rivers\"]:\n                kwargs.setdefault(feature, True)\n\n        # Main feature-drawing loop\n        for key, feature_spec in feature_registry.items():\n            if key in kwargs:\n                style_arg = kwargs.pop(key)\n                self._draw_single_feature(style_arg, feature_spec)\n\n        return kwargs\n\n    def _draw_gridlines(self, style: bool | dict[str, Any]) -&gt; None:\n        \"\"\"Draw gridlines on the map.\n\n        Parameters\n        ----------\n        style : bool or dict[str, Any]\n            The style for the gridlines. If True, use defaults. If a dict,\n            use it as keyword arguments. If False, do nothing.\n        \"\"\"\n        if not style:\n            return\n\n        gridline_defaults = {\n            \"draw_labels\": True,\n            \"linestyle\": \"--\",\n            \"color\": \"gray\",\n        }\n        gridline_kwargs = self._get_style(style, gridline_defaults)\n        self.ax.gridlines(**gridline_kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialPlot.__init__","title":"<code>__init__(*, projection=ccrs.PlateCarree(), fig=None, ax=None, figsize=None, subplot_kw=None, **kwargs)</code>","text":"<p>Initialize the spatial plot and draw map features.</p> <p>This constructor sets up the matplotlib Figure and cartopy GeoAxes, and provides a single interface to draw common map features like coastlines and states.</p>"},{"location":"api/#monet_plots.plots.SpatialPlot.__init__--parameters","title":"Parameters","text":"<p>projection : ccrs.Projection, optional     The cartopy projection for the map, by default ccrs.PlateCarree(). fig : plt.Figure | None, optional     An existing matplotlib Figure object. If None, a new one is     created, by default None. ax : plt.Axes | None, optional     An existing matplotlib Axes object. If None, a new one is created,     by default None. figsize : tuple[float, float] | None, optional      Width, height in inches. If not provided, the matplotlib default      will be used. subplot_kw : dict[str, Any] | None, optional     Keyword arguments passed to <code>fig.add_subplot</code>, by default None.     The 'projection' is added to these keywords automatically. **kwargs : Any     Keyword arguments for map features, passed to <code>add_features</code>.     Common options include <code>coastlines</code>, <code>states</code>, <code>countries</code>,     <code>ocean</code>, <code>land</code>, <code>lakes</code>, <code>rivers</code>, <code>borders</code>, <code>gridlines</code>,     <code>extent</code>, and <code>resolution</code>.</p>"},{"location":"api/#monet_plots.plots.SpatialPlot.__init__--attributes","title":"Attributes","text":"<p>fig : plt.Figure     The matplotlib Figure object. ax : plt.Axes     The matplotlib Axes (or GeoAxes) object. resolution : str     The default resolution for cartopy features.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def __init__(\n    self,\n    *,\n    projection: ccrs.Projection = ccrs.PlateCarree(),\n    fig: matplotlib.figure.Figure | None = None,\n    ax: matplotlib.axes.Axes | None = None,\n    figsize: tuple[float, float] | None = None,\n    subplot_kw: dict[str, Any] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize the spatial plot and draw map features.\n\n    This constructor sets up the matplotlib Figure and cartopy GeoAxes,\n    and provides a single interface to draw common map features like\n    coastlines and states.\n\n    Parameters\n    ----------\n    projection : ccrs.Projection, optional\n        The cartopy projection for the map, by default ccrs.PlateCarree().\n    fig : plt.Figure | None, optional\n        An existing matplotlib Figure object. If None, a new one is\n        created, by default None.\n    ax : plt.Axes | None, optional\n        An existing matplotlib Axes object. If None, a new one is created,\n        by default None.\n    figsize : tuple[float, float] | None, optional\n         Width, height in inches. If not provided, the matplotlib default\n         will be used.\n    subplot_kw : dict[str, Any] | None, optional\n        Keyword arguments passed to `fig.add_subplot`, by default None.\n        The 'projection' is added to these keywords automatically.\n    **kwargs : Any\n        Keyword arguments for map features, passed to `add_features`.\n        Common options include `coastlines`, `states`, `countries`,\n        `ocean`, `land`, `lakes`, `rivers`, `borders`, `gridlines`,\n        `extent`, and `resolution`.\n\n    Attributes\n    ----------\n    fig : plt.Figure\n        The matplotlib Figure object.\n    ax : plt.Axes\n        The matplotlib Axes (or GeoAxes) object.\n    resolution : str\n        The default resolution for cartopy features.\n    \"\"\"\n    # Ensure 'projection' is correctly passed to subplot creation.\n    current_subplot_kw = subplot_kw.copy() if subplot_kw else {}\n    current_subplot_kw[\"projection\"] = projection\n\n    self.resolution = kwargs.pop(\"resolution\", \"50m\")\n    style = kwargs.pop(\"style\", \"wiley\")\n\n    # Ensure coastlines are enabled by default if not specified.\n    if \"coastlines\" not in kwargs:\n        kwargs[\"coastlines\"] = True\n\n    # Initialize the base plot, which creates the figure and axes.\n    super().__init__(\n        fig=fig, ax=ax, figsize=figsize, style=style, subplot_kw=current_subplot_kw\n    )\n\n    # If BasePlot didn't create an axes (e.g. because fig was provided),\n    # create one now.\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1, **current_subplot_kw)\n\n    # If BasePlot didn't create an axes (e.g. because fig was provided),\n    # create one now.\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1, **current_subplot_kw)\n\n    # Add features from kwargs\n    self.add_features(**kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialPlot.add_features","title":"<code>add_features(**kwargs)</code>","text":"<p>Add and style cartopy features on the map axes.</p> <p>This method provides a flexible, data-driven interface to add common map features. Features can be enabled with a boolean flag (e.g., <code>coastlines=True</code>) or styled with a dictionary of keyword arguments (e.g., <code>states=dict(linewidth=2, edgecolor='red')</code>).</p> <p>The <code>extent</code> keyword is also supported to set the map boundaries.</p>"},{"location":"api/#monet_plots.plots.SpatialPlot.add_features--parameters","title":"Parameters","text":"<p>**kwargs : Any     Keyword arguments controlling the features to add and their     styles. Common options include <code>coastlines</code>, <code>states</code>,     <code>countries</code>, <code>ocean</code>, <code>land</code>, <code>lakes</code>, <code>rivers</code>, <code>borders</code>,     and <code>gridlines</code>.</p>"},{"location":"api/#monet_plots.plots.SpatialPlot.add_features--returns","title":"Returns","text":"<p>dict[str, Any]     A dictionary of the keyword arguments that were not used for     adding features. This can be useful for passing remaining     arguments to other functions.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def add_features(self, **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Add and style cartopy features on the map axes.\n\n    This method provides a flexible, data-driven interface to add common\n    map features. Features can be enabled with a boolean flag (e.g.,\n    `coastlines=True`) or styled with a dictionary of keyword arguments\n    (e.g., `states=dict(linewidth=2, edgecolor='red')`).\n\n    The `extent` keyword is also supported to set the map boundaries.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Keyword arguments controlling the features to add and their\n        styles. Common options include `coastlines`, `states`,\n        `countries`, `ocean`, `land`, `lakes`, `rivers`, `borders`,\n        and `gridlines`.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary of the keyword arguments that were not used for\n        adding features. This can be useful for passing remaining\n        arguments to other functions.\n    \"\"\"\n    # Note: The order of these calls is important.\n    # Extent must be set before gridlines are drawn to ensure labels\n    # are placed correctly.\n    if \"extent\" in kwargs:\n        extent = kwargs.pop(\"extent\")\n        self._set_extent(extent)\n\n    if \"gridlines\" in kwargs:\n        gridline_style = kwargs.pop(\"gridlines\")\n        self._draw_gridlines(gridline_style)\n\n    # The rest of the kwargs are assumed to be for vector features.\n    remaining_kwargs = self._draw_features(**kwargs)\n\n    return remaining_kwargs\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialTrack","title":"<code>SpatialTrack</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Plot a trajectory from an xarray.DataArray on a map.</p> <p>This class provides an xarray-native interface for visualizing paths, such as flight trajectories or pollutant tracks, where a variable (e.g., altitude, concentration) is plotted along the path.</p> <p>It inherits from :class:<code>SpatialPlot</code> to provide the underlying map canvas.</p>"},{"location":"api/#monet_plots.plots.SpatialTrack--attributes","title":"Attributes","text":"<p>data : xr.DataArray     The trajectory data being plotted. lon_coord : str     The name of the longitude coordinate in the DataArray. lat_coord : str     The name of the latitude coordinate in the DataArray.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>class SpatialTrack(SpatialPlot):\n    \"\"\"Plot a trajectory from an xarray.DataArray on a map.\n\n    This class provides an xarray-native interface for visualizing paths,\n    such as flight trajectories or pollutant tracks, where a variable\n    (e.g., altitude, concentration) is plotted along the path.\n\n    It inherits from :class:`SpatialPlot` to provide the underlying map canvas.\n\n    Attributes\n    ----------\n    data : xr.DataArray\n        The trajectory data being plotted.\n    lon_coord : str\n        The name of the longitude coordinate in the DataArray.\n    lat_coord : str\n        The name of the latitude coordinate in the DataArray.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: xr.DataArray,\n        *,\n        lon_coord: str = \"lon\",\n        lat_coord: str = \"lat\",\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize the SpatialTrack plot.\n\n        This constructor validates the input data and sets up the map canvas\n        by initializing the parent `SpatialPlot` and adding map features.\n\n        Parameters\n        ----------\n        data : xr.DataArray\n            The input trajectory data. Must be an xarray DataArray with\n            coordinates for longitude and latitude.\n        lon_coord : str, optional\n            Name of the longitude coordinate in the DataArray, by default 'lon'.\n        lat_coord : str, optional\n            Name of the latitude coordinate in the DataArray, by default 'lat'.\n        **kwargs : Any\n            Keyword arguments passed to :class:`SpatialPlot`. These control\n            the map projection, figure size, and cartopy features. For example:\n            `projection=ccrs.LambertConformal()`, `figsize=(10, 8)`,\n            `states=True`, `extent=[-125, -70, 25, 50]`.\n        \"\"\"\n        if not isinstance(data, xr.DataArray):\n            raise TypeError(\"Input 'data' must be an xarray.DataArray.\")\n        if lon_coord not in data.coords:\n            raise ValueError(\n                f\"Longitude coordinate '{lon_coord}' not found in DataArray.\"\n            )\n        if lat_coord not in data.coords:\n            raise ValueError(\n                f\"Latitude coordinate '{lat_coord}' not found in DataArray.\"\n            )\n\n        # Initialize the parent SpatialPlot, which creates the map canvas\n        # and draws features from the keyword arguments.\n        super().__init__(**kwargs)\n\n        # Set data and update history for provenance\n        self.data = data\n        self.lon_coord = lon_coord\n        self.lat_coord = lat_coord\n        history = self.data.attrs.get(\"history\", \"\")\n        self.data.attrs[\"history\"] = f\"Plotted with monet-plots.SpatialTrack; {history}\"\n\n    def plot(self, **kwargs: Any) -&gt; plt.Artist:\n        \"\"\"Plot the trajectory on the map.\n\n        The track is rendered as a scatter plot, where each point is colored\n        according to the `data` values.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Keyword arguments passed to `matplotlib.pyplot.scatter`.\n            Common options include `cmap`, `s` (size), and `alpha`.\n            A `transform` keyword (e.g., `transform=ccrs.PlateCarree()`)\n            is highly recommended for geospatial accuracy.\n            The `cmap` argument can be a string, a Colormap object, or a\n            (colormap, norm) tuple from the scaling tools in `colorbars.py`.\n            Map features (e.g., `coastlines=True`) can also be passed here.\n\n        Returns\n        -------\n        plt.Artist\n            The scatter plot artist created by `ax.scatter`.\n        \"\"\"\n        from ..plot_utils import get_plot_kwargs\n\n        # Automatically compute extent if not provided\n        if \"extent\" not in kwargs:\n            lon = self.data[self.lon_coord]\n            lat = self.data[self.lat_coord]\n            # Add a small buffer to the extent.\n            # Use dask.compute for efficient parallel calculation of min/max\n            # if the data is chunked.\n            import dask\n\n            lon_min, lon_max, lat_min, lat_max = dask.compute(\n                lon.min(), lon.max(), lat.min(), lat.max()\n            )\n            # Ensure they are scalar values (handles both numpy and dask returns)\n            lon_min, lon_max = float(lon_min), float(lon_max)\n            lat_min, lat_max = float(lat_min), float(lat_max)\n\n            lon_buf = (lon_max - lon_min) * 0.1 if lon_max &gt; lon_min else 1.0\n            lat_buf = (lat_max - lat_min) * 0.1 if lat_max &gt; lat_min else 1.0\n            kwargs[\"extent\"] = [\n                lon_min - lon_buf,\n                lon_max + lon_buf,\n                lat_min - lat_buf,\n                lat_max + lat_buf,\n            ]\n\n        # Add features and get remaining kwargs for scatter\n        scatter_kwargs = self.add_features(**kwargs)\n\n        scatter_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        # For coordinates and values, we pass the xarray objects directly.\n        # This allows Matplotlib to handle the conversion, maintaining\n        # compatibility with existing tests that check for lazy objects.\n        longitude = self.data[self.lon_coord]\n        latitude = self.data[self.lat_coord]\n\n        # Use get_plot_kwargs to handle (cmap, norm) tuples\n        final_kwargs = get_plot_kwargs(c=self.data, **scatter_kwargs)\n\n        sc = self.ax.scatter(longitude, latitude, **final_kwargs)\n        return sc\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialTrack.__init__","title":"<code>__init__(data, *, lon_coord='lon', lat_coord='lat', **kwargs)</code>","text":"<p>Initialize the SpatialTrack plot.</p> <p>This constructor validates the input data and sets up the map canvas by initializing the parent <code>SpatialPlot</code> and adding map features.</p>"},{"location":"api/#monet_plots.plots.SpatialTrack.__init__--parameters","title":"Parameters","text":"<p>data : xr.DataArray     The input trajectory data. Must be an xarray DataArray with     coordinates for longitude and latitude. lon_coord : str, optional     Name of the longitude coordinate in the DataArray, by default 'lon'. lat_coord : str, optional     Name of the latitude coordinate in the DataArray, by default 'lat'. **kwargs : Any     Keyword arguments passed to :class:<code>SpatialPlot</code>. These control     the map projection, figure size, and cartopy features. For example:     <code>projection=ccrs.LambertConformal()</code>, <code>figsize=(10, 8)</code>,     <code>states=True</code>, <code>extent=[-125, -70, 25, 50]</code>.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def __init__(\n    self,\n    data: xr.DataArray,\n    *,\n    lon_coord: str = \"lon\",\n    lat_coord: str = \"lat\",\n    **kwargs: Any,\n):\n    \"\"\"Initialize the SpatialTrack plot.\n\n    This constructor validates the input data and sets up the map canvas\n    by initializing the parent `SpatialPlot` and adding map features.\n\n    Parameters\n    ----------\n    data : xr.DataArray\n        The input trajectory data. Must be an xarray DataArray with\n        coordinates for longitude and latitude.\n    lon_coord : str, optional\n        Name of the longitude coordinate in the DataArray, by default 'lon'.\n    lat_coord : str, optional\n        Name of the latitude coordinate in the DataArray, by default 'lat'.\n    **kwargs : Any\n        Keyword arguments passed to :class:`SpatialPlot`. These control\n        the map projection, figure size, and cartopy features. For example:\n        `projection=ccrs.LambertConformal()`, `figsize=(10, 8)`,\n        `states=True`, `extent=[-125, -70, 25, 50]`.\n    \"\"\"\n    if not isinstance(data, xr.DataArray):\n        raise TypeError(\"Input 'data' must be an xarray.DataArray.\")\n    if lon_coord not in data.coords:\n        raise ValueError(\n            f\"Longitude coordinate '{lon_coord}' not found in DataArray.\"\n        )\n    if lat_coord not in data.coords:\n        raise ValueError(\n            f\"Latitude coordinate '{lat_coord}' not found in DataArray.\"\n        )\n\n    # Initialize the parent SpatialPlot, which creates the map canvas\n    # and draws features from the keyword arguments.\n    super().__init__(**kwargs)\n\n    # Set data and update history for provenance\n    self.data = data\n    self.lon_coord = lon_coord\n    self.lat_coord = lat_coord\n    history = self.data.attrs.get(\"history\", \"\")\n    self.data.attrs[\"history\"] = f\"Plotted with monet-plots.SpatialTrack; {history}\"\n</code></pre>"},{"location":"api/#monet_plots.plots.SpatialTrack.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Plot the trajectory on the map.</p> <p>The track is rendered as a scatter plot, where each point is colored according to the <code>data</code> values.</p>"},{"location":"api/#monet_plots.plots.SpatialTrack.plot--parameters","title":"Parameters","text":"<p>**kwargs : Any     Keyword arguments passed to <code>matplotlib.pyplot.scatter</code>.     Common options include <code>cmap</code>, <code>s</code> (size), and <code>alpha</code>.     A <code>transform</code> keyword (e.g., <code>transform=ccrs.PlateCarree()</code>)     is highly recommended for geospatial accuracy.     The <code>cmap</code> argument can be a string, a Colormap object, or a     (colormap, norm) tuple from the scaling tools in <code>colorbars.py</code>.     Map features (e.g., <code>coastlines=True</code>) can also be passed here.</p>"},{"location":"api/#monet_plots.plots.SpatialTrack.plot--returns","title":"Returns","text":"<p>plt.Artist     The scatter plot artist created by <code>ax.scatter</code>.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; plt.Artist:\n    \"\"\"Plot the trajectory on the map.\n\n    The track is rendered as a scatter plot, where each point is colored\n    according to the `data` values.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Keyword arguments passed to `matplotlib.pyplot.scatter`.\n        Common options include `cmap`, `s` (size), and `alpha`.\n        A `transform` keyword (e.g., `transform=ccrs.PlateCarree()`)\n        is highly recommended for geospatial accuracy.\n        The `cmap` argument can be a string, a Colormap object, or a\n        (colormap, norm) tuple from the scaling tools in `colorbars.py`.\n        Map features (e.g., `coastlines=True`) can also be passed here.\n\n    Returns\n    -------\n    plt.Artist\n        The scatter plot artist created by `ax.scatter`.\n    \"\"\"\n    from ..plot_utils import get_plot_kwargs\n\n    # Automatically compute extent if not provided\n    if \"extent\" not in kwargs:\n        lon = self.data[self.lon_coord]\n        lat = self.data[self.lat_coord]\n        # Add a small buffer to the extent.\n        # Use dask.compute for efficient parallel calculation of min/max\n        # if the data is chunked.\n        import dask\n\n        lon_min, lon_max, lat_min, lat_max = dask.compute(\n            lon.min(), lon.max(), lat.min(), lat.max()\n        )\n        # Ensure they are scalar values (handles both numpy and dask returns)\n        lon_min, lon_max = float(lon_min), float(lon_max)\n        lat_min, lat_max = float(lat_min), float(lat_max)\n\n        lon_buf = (lon_max - lon_min) * 0.1 if lon_max &gt; lon_min else 1.0\n        lat_buf = (lat_max - lat_min) * 0.1 if lat_max &gt; lat_min else 1.0\n        kwargs[\"extent\"] = [\n            lon_min - lon_buf,\n            lon_max + lon_buf,\n            lat_min - lat_buf,\n            lat_max + lat_buf,\n        ]\n\n    # Add features and get remaining kwargs for scatter\n    scatter_kwargs = self.add_features(**kwargs)\n\n    scatter_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    # For coordinates and values, we pass the xarray objects directly.\n    # This allows Matplotlib to handle the conversion, maintaining\n    # compatibility with existing tests that check for lazy objects.\n    longitude = self.data[self.lon_coord]\n    latitude = self.data[self.lat_coord]\n\n    # Use get_plot_kwargs to handle (cmap, norm) tuples\n    final_kwargs = get_plot_kwargs(c=self.data, **scatter_kwargs)\n\n    sc = self.ax.scatter(longitude, latitude, **final_kwargs)\n    return sc\n</code></pre>"},{"location":"api/#monet_plots.plots.SpreadSkillPlot","title":"<code>SpreadSkillPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a spread-skill plot to evaluate ensemble forecast reliability.</p> <p>This plot compares the standard deviation of the ensemble spread to the root mean squared error (RMSE) of the ensemble mean. A reliable ensemble should have a spread that is proportional to the forecast error.</p> Source code in <code>src/monet_plots/plots/ensemble.py</code> <pre><code>class SpreadSkillPlot(BasePlot):\n    \"\"\"Create a spread-skill plot to evaluate ensemble forecast reliability.\n\n    This plot compares the standard deviation of the ensemble spread to the\n    root mean squared error (RMSE) of the ensemble mean. A reliable ensemble\n    should have a spread that is proportional to the forecast error.\n    \"\"\"\n\n    def __init__(self, spread, skill, *args, **kwargs):\n        \"\"\"\n        Initialize the plot with spread and skill data.\n\n        Args:\n            spread (array-like): The standard deviation of the ensemble forecast.\n            skill (array-like): The root mean squared error of the ensemble mean.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.spread = np.asarray(spread)\n        self.skill = np.asarray(skill)\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the spread-skill plot.\n\n        Additional keyword arguments are passed to the scatter plot.\n        \"\"\"\n        # Plot the spread-skill pairs\n        self.ax.scatter(self.spread, self.skill, **kwargs)\n\n        # Add a 1:1 reference line\n        max_val = max(np.max(self.spread), np.max(self.skill))\n        self.ax.plot([0, max_val], [0, max_val], \"k--\")\n\n        # Set labels and title\n        self.ax.set_xlabel(\"Ensemble Spread (Standard Deviation)\")\n        self.ax.set_ylabel(\"Ensemble Error (RMSE)\")\n        self.ax.set_title(\"Spread-Skill Plot\")\n\n        # Ensure aspect ratio is equal\n        self.ax.set_aspect(\"equal\", \"box\")\n\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.SpreadSkillPlot.__init__","title":"<code>__init__(spread, skill, *args, **kwargs)</code>","text":"<p>Initialize the plot with spread and skill data.</p> <p>Parameters:</p> Name Type Description Default <code>spread</code> <code>array - like</code> <p>The standard deviation of the ensemble forecast.</p> required <code>skill</code> <code>array - like</code> <p>The root mean squared error of the ensemble mean.</p> required Source code in <code>src/monet_plots/plots/ensemble.py</code> <pre><code>def __init__(self, spread, skill, *args, **kwargs):\n    \"\"\"\n    Initialize the plot with spread and skill data.\n\n    Args:\n        spread (array-like): The standard deviation of the ensemble forecast.\n        skill (array-like): The root mean squared error of the ensemble mean.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.spread = np.asarray(spread)\n    self.skill = np.asarray(skill)\n</code></pre>"},{"location":"api/#monet_plots.plots.SpreadSkillPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spread-skill plot.</p> <p>Additional keyword arguments are passed to the scatter plot.</p> Source code in <code>src/monet_plots/plots/ensemble.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the spread-skill plot.\n\n    Additional keyword arguments are passed to the scatter plot.\n    \"\"\"\n    # Plot the spread-skill pairs\n    self.ax.scatter(self.spread, self.skill, **kwargs)\n\n    # Add a 1:1 reference line\n    max_val = max(np.max(self.spread), np.max(self.skill))\n    self.ax.plot([0, max_val], [0, max_val], \"k--\")\n\n    # Set labels and title\n    self.ax.set_xlabel(\"Ensemble Spread (Standard Deviation)\")\n    self.ax.set_ylabel(\"Ensemble Error (RMSE)\")\n    self.ax.set_title(\"Spread-Skill Plot\")\n\n    # Ensure aspect ratio is equal\n    self.ax.set_aspect(\"equal\", \"box\")\n\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.StickPlot","title":"<code>StickPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Vertical stick plot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>class StickPlot(BasePlot):\n    \"\"\"Vertical stick plot.\"\"\"\n\n    def __init__(self, u, v, y, *args, **kwargs):\n        \"\"\"\n        Initialize the stick plot.\n        Args:\n            u (np.ndarray, pd.Series, xr.DataArray): U-component of the vector.\n            v (np.ndarray, pd.Series, xr.DataArray): V-component of the vector.\n            y (np.ndarray, pd.Series, xr.DataArray): Vertical coordinate.\n            **kwargs: Additional keyword arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.u = u\n        self.v = v\n        self.y = y\n        self.x = np.zeros_like(self.y)\n\n    def plot(self, **kwargs: t.Any) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        **kwargs\n            Keyword arguments passed to `matplotlib.pyplot.quiver`.\n        \"\"\"\n        if self.ax is None:\n            if self.fig is None:\n                self.fig = plt.figure()\n            self.ax = self.fig.add_subplot()\n\n        return self.ax.quiver(self.x, self.y, self.u, self.v, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.StickPlot.__init__","title":"<code>__init__(u, v, y, *args, **kwargs)</code>","text":"<p>Initialize the stick plot. Args:     u (np.ndarray, pd.Series, xr.DataArray): U-component of the vector.     v (np.ndarray, pd.Series, xr.DataArray): V-component of the vector.     y (np.ndarray, pd.Series, xr.DataArray): Vertical coordinate.     **kwargs: Additional keyword arguments passed to BasePlot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def __init__(self, u, v, y, *args, **kwargs):\n    \"\"\"\n    Initialize the stick plot.\n    Args:\n        u (np.ndarray, pd.Series, xr.DataArray): U-component of the vector.\n        v (np.ndarray, pd.Series, xr.DataArray): V-component of the vector.\n        y (np.ndarray, pd.Series, xr.DataArray): Vertical coordinate.\n        **kwargs: Additional keyword arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.u = u\n    self.v = v\n    self.y = y\n    self.x = np.zeros_like(self.y)\n</code></pre>"},{"location":"api/#monet_plots.plots.StickPlot.plot","title":"<code>plot(**kwargs)</code>","text":""},{"location":"api/#monet_plots.plots.StickPlot.plot--parameters","title":"Parameters","text":"<p>**kwargs     Keyword arguments passed to <code>matplotlib.pyplot.quiver</code>.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def plot(self, **kwargs: t.Any) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    **kwargs\n        Keyword arguments passed to `matplotlib.pyplot.quiver`.\n    \"\"\"\n    if self.ax is None:\n        if self.fig is None:\n            self.fig = plt.figure()\n        self.ax = self.fig.add_subplot()\n\n    return self.ax.quiver(self.x, self.y, self.u, self.v, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.TaylorDiagramPlot","title":"<code>TaylorDiagramPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a DataFrame-based Taylor diagram.</p> <p>A convenience wrapper for easily creating Taylor diagrams from DataFrames.</p> Source code in <code>src/monet_plots/plots/taylor_diagram.py</code> <pre><code>class TaylorDiagramPlot(BasePlot):\n    \"\"\"Create a DataFrame-based Taylor diagram.\n\n    A convenience wrapper for easily creating Taylor diagrams from DataFrames.\n    \"\"\"\n\n    def __init__(\n        self,\n        df: Any,\n        col1: str = \"obs\",\n        col2: Union[str, List[str]] = \"model\",\n        label1: str = \"OBS\",\n        scale: float = 1.5,\n        dia=None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and diagram settings.\n\n        Args:\n            df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with observation and model data.\n            col1 (str): Column name for observations.\n            col2 (str or list): Column name(s) for model predictions.\n            label1 (str): Label for observations.\n            scale (float): Scale factor for diagram.\n            dia (TaylorDiagram, optional): Existing diagram to add to.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.col1 = col1\n        if isinstance(col2, str):\n            self.col2 = [col2]\n        else:\n            self.col2 = col2\n\n        # Ensure all specified columns exist before proceeding\n        required_cols = [self.col1] + self.col2\n        self.df = to_dataframe(df).dropna(subset=required_cols)\n\n        self.label1 = label1\n        self.scale = scale\n        self.dia = dia\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the Taylor diagram.\"\"\"\n        # If no diagram is provided, create a new one\n        if self.dia is None:\n            obsstd = self.df[self.col1].std()\n\n            # Remove the default axes created by BasePlot to avoid an extra empty plot\n            if hasattr(self, \"ax\") and self.ax is not None:\n                self.fig.delaxes(self.ax)\n\n            # Use self.fig which is created in BasePlot.__init__\n            self.dia = td.TaylorDiagram(\n                obsstd, scale=self.scale, fig=self.fig, rect=111, label=self.label1\n            )\n            # Update self.ax to the one created by TaylorDiagram\n            self.ax = self.dia._ax\n\n            # Add contours for the new diagram\n            contours = self.dia.add_contours(colors=\"0.5\")\n            plt.clabel(contours, inline=1, fontsize=10)\n\n        # Loop through each model column and add it to the diagram\n        for model_col in self.col2:\n            model_std = self.df[model_col].std()\n            cc = corrcoef(self.df[self.col1].values, self.df[model_col].values)[0, 1]\n            self.dia.add_sample(model_std, cc, label=model_col, **kwargs)\n\n        self.fig.legend(\n            self.dia.samplePoints,\n            [p.get_label() for p in self.dia.samplePoints],\n            numpoints=1,\n            loc=\"upper right\",\n        )\n        self.fig.tight_layout()\n        return self.dia\n</code></pre>"},{"location":"api/#monet_plots.plots.TaylorDiagramPlot.__init__","title":"<code>__init__(df, col1='obs', col2='model', label1='OBS', scale=1.5, dia=None, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and diagram settings.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>DataFrame with observation and model data.</p> required <code>col1</code> <code>str</code> <p>Column name for observations.</p> <code>'obs'</code> <code>col2</code> <code>str or list</code> <p>Column name(s) for model predictions.</p> <code>'model'</code> <code>label1</code> <code>str</code> <p>Label for observations.</p> <code>'OBS'</code> <code>scale</code> <code>float</code> <p>Scale factor for diagram.</p> <code>1.5</code> <code>dia</code> <code>TaylorDiagram</code> <p>Existing diagram to add to.</p> <code>None</code> Source code in <code>src/monet_plots/plots/taylor_diagram.py</code> <pre><code>def __init__(\n    self,\n    df: Any,\n    col1: str = \"obs\",\n    col2: Union[str, List[str]] = \"model\",\n    label1: str = \"OBS\",\n    scale: float = 1.5,\n    dia=None,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and diagram settings.\n\n    Args:\n        df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with observation and model data.\n        col1 (str): Column name for observations.\n        col2 (str or list): Column name(s) for model predictions.\n        label1 (str): Label for observations.\n        scale (float): Scale factor for diagram.\n        dia (TaylorDiagram, optional): Existing diagram to add to.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.col1 = col1\n    if isinstance(col2, str):\n        self.col2 = [col2]\n    else:\n        self.col2 = col2\n\n    # Ensure all specified columns exist before proceeding\n    required_cols = [self.col1] + self.col2\n    self.df = to_dataframe(df).dropna(subset=required_cols)\n\n    self.label1 = label1\n    self.scale = scale\n    self.dia = dia\n</code></pre>"},{"location":"api/#monet_plots.plots.TaylorDiagramPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the Taylor diagram.</p> Source code in <code>src/monet_plots/plots/taylor_diagram.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the Taylor diagram.\"\"\"\n    # If no diagram is provided, create a new one\n    if self.dia is None:\n        obsstd = self.df[self.col1].std()\n\n        # Remove the default axes created by BasePlot to avoid an extra empty plot\n        if hasattr(self, \"ax\") and self.ax is not None:\n            self.fig.delaxes(self.ax)\n\n        # Use self.fig which is created in BasePlot.__init__\n        self.dia = td.TaylorDiagram(\n            obsstd, scale=self.scale, fig=self.fig, rect=111, label=self.label1\n        )\n        # Update self.ax to the one created by TaylorDiagram\n        self.ax = self.dia._ax\n\n        # Add contours for the new diagram\n        contours = self.dia.add_contours(colors=\"0.5\")\n        plt.clabel(contours, inline=1, fontsize=10)\n\n    # Loop through each model column and add it to the diagram\n    for model_col in self.col2:\n        model_std = self.df[model_col].std()\n        cc = corrcoef(self.df[self.col1].values, self.df[model_col].values)[0, 1]\n        self.dia.add_sample(model_std, cc, label=model_col, **kwargs)\n\n    self.fig.legend(\n        self.dia.samplePoints,\n        [p.get_label() for p in self.dia.samplePoints],\n        numpoints=1,\n        loc=\"upper right\",\n    )\n    self.fig.tight_layout()\n    return self.dia\n</code></pre>"},{"location":"api/#monet_plots.plots.TimeSeriesPlot","title":"<code>TimeSeriesPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a timeseries plot with shaded error bounds.</p> <p>This function groups the data by time, plots the mean values, and adds shading for \u00b11 standard deviation around the mean.</p> Source code in <code>src/monet_plots/plots/timeseries.py</code> <pre><code>class TimeSeriesPlot(BasePlot):\n    \"\"\"Create a timeseries plot with shaded error bounds.\n\n    This function groups the data by time, plots the mean values, and adds\n    shading for \u00b11 standard deviation around the mean.\n    \"\"\"\n\n    def __init__(\n        self,\n        df: Any,\n        x: str = \"time\",\n        y: str = \"obs\",\n        plotargs: dict = {},\n        fillargs: dict = None,\n        title: str = \"\",\n        ylabel: Optional[str] = None,\n        label: Optional[str] = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and plot settings.\n\n        Args:\n            df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray):\n                DataFrame with the data to plot.\n            x (str): Column name for the x-axis (time).\n            y (str): Column name for the y-axis (values).\n            plotargs (dict): Arguments for the plot.\n            fillargs (dict): Arguments for fill_between.\n            title (str): Title for the plot.\n            ylabel (str, optional): Y-axis label.\n            label (str, optional): Label for the plotted line.\n            *args, **kwargs: Arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1)\n\n        self.df = normalize_data(df)\n        self.x = x\n        self.y = y\n        self.plotargs = plotargs\n        self.fillargs = fillargs if fillargs is not None else {\"alpha\": 0.2}\n        self.title = title\n        self.ylabel = ylabel\n        self.label = label\n\n    def plot(self, **kwargs: Any) -&gt; plt.Axes:\n        \"\"\"\n        Generate the timeseries plot.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Overrides for plot settings (x, y, title, ylabel, label, etc.).\n\n        Returns\n        -------\n        plt.Axes\n            The matplotlib axes object containing the plot.\n\n        Examples\n        --------\n        &gt;&gt;&gt; plot = TimeSeriesPlot(df, x='time', y='obs')\n        &gt;&gt;&gt; ax = plot.plot(title='Observation Over Time')\n        \"\"\"\n        # Update attributes from kwargs if provided\n        for attr in [\"x\", \"y\", \"title\", \"ylabel\", \"label\"]:\n            if attr in kwargs:\n                setattr(self, attr, kwargs.pop(attr))\n\n        import xarray as xr\n\n        # Handle xarray objects differently from pandas DataFrames\n        if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n            return self._plot_xarray(**kwargs)\n        else:\n            return self._plot_dataframe(**kwargs)\n\n    def _plot_dataframe(self, **kwargs: Any) -&gt; plt.Axes:\n        \"\"\"\n        Generate the timeseries plot from pandas DataFrame.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Additional plotting arguments.\n\n        Returns\n        -------\n        plt.Axes\n            The matplotlib axes object.\n\n        Examples\n        --------\n        &gt;&gt;&gt; plot._plot_dataframe()\n        \"\"\"\n        df = self.df.copy()\n        df.index = df[self.x]\n        # Keep only numeric columns for grouping, but make sure self.y is there\n        df = df.reset_index(drop=True)\n        # We need to preserve self.x for grouping if it's not the index\n        m = self.df.groupby(self.x).mean(numeric_only=True)\n        e = self.df.groupby(self.x).std(numeric_only=True)\n\n        variable = self.y\n        unit = \"None\"\n        if \"units\" in self.df.columns:\n            unit = str(self.df[\"units\"].iloc[0])\n\n        upper = m[self.y] + e[self.y]\n        lower = m[self.y] - e[self.y]\n        # lower.loc[lower &lt; 0] = 0 # Not always desired for all variables\n        lower_vals = lower.values\n        upper_vals = upper.values\n\n        if self.label is not None:\n            plot_label = self.label\n        else:\n            plot_label = self.y\n\n        m[self.y].plot(ax=self.ax, label=plot_label, **self.plotargs)\n        self.ax.fill_between(m.index, lower_vals, upper_vals, **self.fillargs)\n\n        if self.ylabel is None:\n            self.ax.set_ylabel(f\"{variable} ({unit})\")\n        else:\n            self.ax.set_ylabel(self.ylabel)\n\n        self.ax.set_xlabel(self.x)\n        self.ax.legend()\n        self.ax.set_title(self.title)\n        self.fig.tight_layout()\n        return self.ax\n\n    def _plot_xarray(self, **kwargs: Any) -&gt; plt.Axes:\n        \"\"\"\n        Generate the timeseries plot from xarray DataArray or Dataset.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Additional plotting arguments.\n\n        Returns\n        -------\n        plt.Axes\n            The matplotlib axes object.\n\n        Examples\n        --------\n        &gt;&gt;&gt; plot._plot_xarray()\n        \"\"\"\n        import xarray as xr\n\n        # Ensure we have the right data structure\n        if isinstance(self.df, xr.DataArray):\n            data = (\n                self.df.to_dataset(name=self.y)\n                if self.df.name is None\n                else self.df.to_dataset()\n            )\n            if self.df.name is not None:\n                self.y = self.df.name\n        else:\n            data = self.df\n\n        # Calculate mean and std along other dimensions if any\n        # If it's already a 1D time series, mean/std won't do much\n        dims_to_reduce = [d for d in data[self.y].dims if d != self.x]\n\n        if dims_to_reduce:\n            mean_data = data[self.y].mean(dim=dims_to_reduce)\n            std_data = data[self.y].std(dim=dims_to_reduce)\n        else:\n            mean_data = data[self.y]\n            std_data = xr.zeros_like(mean_data)\n\n        plot_label = self.label if self.label is not None else self.y\n        mean_data.plot(ax=self.ax, label=plot_label, **self.plotargs)\n\n        upper = mean_data + std_data\n        lower = mean_data - std_data\n\n        self.ax.fill_between(\n            mean_data[self.x].values, lower.values, upper.values, **self.fillargs\n        )\n\n        unit = data[self.y].attrs.get(\"units\", \"None\")\n\n        if self.ylabel is None:\n            self.ax.set_ylabel(f\"{self.y} ({unit})\")\n        else:\n            self.ax.set_ylabel(self.ylabel)\n\n        self.ax.set_xlabel(self.x)\n        self.ax.legend()\n        self.ax.set_title(self.title)\n        self.fig.tight_layout()\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.TimeSeriesPlot.__init__","title":"<code>__init__(df, x='time', y='obs', plotargs={}, fillargs=None, title='', ylabel=None, label=None, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and plot settings.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>DataFrame with the data to plot.</p> required <code>x</code> <code>str</code> <p>Column name for the x-axis (time).</p> <code>'time'</code> <code>y</code> <code>str</code> <p>Column name for the y-axis (values).</p> <code>'obs'</code> <code>plotargs</code> <code>dict</code> <p>Arguments for the plot.</p> <code>{}</code> <code>fillargs</code> <code>dict</code> <p>Arguments for fill_between.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>Y-axis label.</p> <code>None</code> <code>label</code> <code>str</code> <p>Label for the plotted line.</p> <code>None</code> <code>*args, **kwargs</code> <p>Arguments passed to BasePlot.</p> required Source code in <code>src/monet_plots/plots/timeseries.py</code> <pre><code>def __init__(\n    self,\n    df: Any,\n    x: str = \"time\",\n    y: str = \"obs\",\n    plotargs: dict = {},\n    fillargs: dict = None,\n    title: str = \"\",\n    ylabel: Optional[str] = None,\n    label: Optional[str] = None,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and plot settings.\n\n    Args:\n        df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray):\n            DataFrame with the data to plot.\n        x (str): Column name for the x-axis (time).\n        y (str): Column name for the y-axis (values).\n        plotargs (dict): Arguments for the plot.\n        fillargs (dict): Arguments for fill_between.\n        title (str): Title for the plot.\n        ylabel (str, optional): Y-axis label.\n        label (str, optional): Label for the plotted line.\n        *args, **kwargs: Arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1)\n\n    self.df = normalize_data(df)\n    self.x = x\n    self.y = y\n    self.plotargs = plotargs\n    self.fillargs = fillargs if fillargs is not None else {\"alpha\": 0.2}\n    self.title = title\n    self.ylabel = ylabel\n    self.label = label\n</code></pre>"},{"location":"api/#monet_plots.plots.TimeSeriesPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the timeseries plot.</p>"},{"location":"api/#monet_plots.plots.TimeSeriesPlot.plot--parameters","title":"Parameters","text":"<p>**kwargs : Any     Overrides for plot settings (x, y, title, ylabel, label, etc.).</p>"},{"location":"api/#monet_plots.plots.TimeSeriesPlot.plot--returns","title":"Returns","text":"<p>plt.Axes     The matplotlib axes object containing the plot.</p>"},{"location":"api/#monet_plots.plots.TimeSeriesPlot.plot--examples","title":"Examples","text":"<p>plot = TimeSeriesPlot(df, x='time', y='obs') ax = plot.plot(title='Observation Over Time')</p> Source code in <code>src/monet_plots/plots/timeseries.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; plt.Axes:\n    \"\"\"\n    Generate the timeseries plot.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Overrides for plot settings (x, y, title, ylabel, label, etc.).\n\n    Returns\n    -------\n    plt.Axes\n        The matplotlib axes object containing the plot.\n\n    Examples\n    --------\n    &gt;&gt;&gt; plot = TimeSeriesPlot(df, x='time', y='obs')\n    &gt;&gt;&gt; ax = plot.plot(title='Observation Over Time')\n    \"\"\"\n    # Update attributes from kwargs if provided\n    for attr in [\"x\", \"y\", \"title\", \"ylabel\", \"label\"]:\n        if attr in kwargs:\n            setattr(self, attr, kwargs.pop(attr))\n\n    import xarray as xr\n\n    # Handle xarray objects differently from pandas DataFrames\n    if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n        return self._plot_xarray(**kwargs)\n    else:\n        return self._plot_dataframe(**kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.TrajectoryPlot","title":"<code>TrajectoryPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Plot a trajectory on a map and a timeseries of a variable.</p> Source code in <code>src/monet_plots/plots/trajectory.py</code> <pre><code>class TrajectoryPlot(BasePlot):\n    \"\"\"Plot a trajectory on a map and a timeseries of a variable.\"\"\"\n\n    def __init__(\n        self,\n        longitude: t.Any,\n        latitude: t.Any,\n        data: t.Any,\n        time: t.Any,\n        ts_data: t.Any,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the trajectory plot.\n        Args:\n            longitude: Longitude values for the spatial track.\n            latitude: Latitude values for the spatial track.\n            data: Data to use for coloring the track.\n            time: Time values for the timeseries or a DataFrame.\n            ts_data: Data for the timeseries or column name if time is a DataFrame.\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        if \"fig\" not in kwargs and \"ax\" not in kwargs:\n            kwargs[\"fig\"] = plt.figure()\n        super().__init__(*args, **kwargs)\n        self.longitude = longitude\n        self.latitude = latitude\n        self.data = data\n        self.time = time\n        self.ts_data = ts_data\n\n    def plot(self, **kwargs: t.Any) -&gt; None:\n        \"\"\"Plot the trajectory and timeseries.\n\n        Args:\n            **kwargs: Keyword arguments passed to the plot methods.\n        \"\"\"\n        if self.fig is None:\n            self.fig = plt.figure(figsize=kwargs.get(\"figsize\", (12, 6)))\n\n        # Ensure constrained_layout to help with alignment\n        self.fig.set_constrained_layout(True)\n\n        gs = self.fig.add_gridspec(2, 1, height_ratios=[3, 1])\n\n        # Spatial track plot\n        import cartopy.crs as ccrs\n\n        proj = kwargs.get(\"projection\", ccrs.PlateCarree())\n        ax0 = self.fig.add_subplot(gs[0, 0], projection=proj)\n\n        # Set adjustable to 'datalim' to allow the map to fill the horizontal\n        # space while maintaining equal aspect ratio by expanding the limits.\n        ax0.set_adjustable(\"datalim\")\n\n        # Create an xarray.DataArray for the trajectory data\n        lon = np.asarray(self.longitude)\n        lat = np.asarray(self.latitude)\n        values = np.asarray(self.data)\n        time_dim = np.arange(len(lon))\n        coords = {\"time\": time_dim, \"lon\": (\"time\", lon), \"lat\": (\"time\", lat)}\n        track_da = xr.DataArray(values, dims=[\"time\"], coords=coords, name=\"track_data\")\n\n        # Pass the DataArray to SpatialTrack\n        plot_kwargs = kwargs.get(\"spatial_track_kwargs\", {})\n        spatial_track = SpatialTrack(data=track_da, ax=ax0)\n        spatial_track.plot(**plot_kwargs)\n\n        # Timeseries plot\n        ax1 = self.fig.add_subplot(gs[1, 0])\n\n        timeseries_kwargs = kwargs.get(\"timeseries_kwargs\", {}).copy()\n\n        if isinstance(self.time, pd.DataFrame):\n            # Already a DataFrame\n            timeseries = TimeSeriesPlot(\n                df=self.time, y=self.ts_data, ax=ax1, fig=self.fig\n            )\n        else:\n            # Assume arrays\n            ts_df = pd.DataFrame({\"time\": self.time, \"value\": np.asarray(self.ts_data)})\n            timeseries = TimeSeriesPlot(\n                df=ts_df, x=\"time\", y=\"value\", ax=ax1, fig=self.fig\n            )\n\n        timeseries.plot(**timeseries_kwargs)\n\n        self.ax = [ax0, ax1]\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.TrajectoryPlot.__init__","title":"<code>__init__(longitude, latitude, data, time, ts_data, *args, **kwargs)</code>","text":"<p>Initialize the trajectory plot. Args:     longitude: Longitude values for the spatial track.     latitude: Latitude values for the spatial track.     data: Data to use for coloring the track.     time: Time values for the timeseries or a DataFrame.     ts_data: Data for the timeseries or column name if time is a DataFrame.     args: Additional positional arguments.     *kwargs: Additional keyword arguments.</p> Source code in <code>src/monet_plots/plots/trajectory.py</code> <pre><code>def __init__(\n    self,\n    longitude: t.Any,\n    latitude: t.Any,\n    data: t.Any,\n    time: t.Any,\n    ts_data: t.Any,\n    *args: t.Any,\n    **kwargs: t.Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the trajectory plot.\n    Args:\n        longitude: Longitude values for the spatial track.\n        latitude: Latitude values for the spatial track.\n        data: Data to use for coloring the track.\n        time: Time values for the timeseries or a DataFrame.\n        ts_data: Data for the timeseries or column name if time is a DataFrame.\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    if \"fig\" not in kwargs and \"ax\" not in kwargs:\n        kwargs[\"fig\"] = plt.figure()\n    super().__init__(*args, **kwargs)\n    self.longitude = longitude\n    self.latitude = latitude\n    self.data = data\n    self.time = time\n    self.ts_data = ts_data\n</code></pre>"},{"location":"api/#monet_plots.plots.TrajectoryPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Plot the trajectory and timeseries.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments passed to the plot methods.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/trajectory.py</code> <pre><code>def plot(self, **kwargs: t.Any) -&gt; None:\n    \"\"\"Plot the trajectory and timeseries.\n\n    Args:\n        **kwargs: Keyword arguments passed to the plot methods.\n    \"\"\"\n    if self.fig is None:\n        self.fig = plt.figure(figsize=kwargs.get(\"figsize\", (12, 6)))\n\n    # Ensure constrained_layout to help with alignment\n    self.fig.set_constrained_layout(True)\n\n    gs = self.fig.add_gridspec(2, 1, height_ratios=[3, 1])\n\n    # Spatial track plot\n    import cartopy.crs as ccrs\n\n    proj = kwargs.get(\"projection\", ccrs.PlateCarree())\n    ax0 = self.fig.add_subplot(gs[0, 0], projection=proj)\n\n    # Set adjustable to 'datalim' to allow the map to fill the horizontal\n    # space while maintaining equal aspect ratio by expanding the limits.\n    ax0.set_adjustable(\"datalim\")\n\n    # Create an xarray.DataArray for the trajectory data\n    lon = np.asarray(self.longitude)\n    lat = np.asarray(self.latitude)\n    values = np.asarray(self.data)\n    time_dim = np.arange(len(lon))\n    coords = {\"time\": time_dim, \"lon\": (\"time\", lon), \"lat\": (\"time\", lat)}\n    track_da = xr.DataArray(values, dims=[\"time\"], coords=coords, name=\"track_data\")\n\n    # Pass the DataArray to SpatialTrack\n    plot_kwargs = kwargs.get(\"spatial_track_kwargs\", {})\n    spatial_track = SpatialTrack(data=track_da, ax=ax0)\n    spatial_track.plot(**plot_kwargs)\n\n    # Timeseries plot\n    ax1 = self.fig.add_subplot(gs[1, 0])\n\n    timeseries_kwargs = kwargs.get(\"timeseries_kwargs\", {}).copy()\n\n    if isinstance(self.time, pd.DataFrame):\n        # Already a DataFrame\n        timeseries = TimeSeriesPlot(\n            df=self.time, y=self.ts_data, ax=ax1, fig=self.fig\n        )\n    else:\n        # Assume arrays\n        ts_df = pd.DataFrame({\"time\": self.time, \"value\": np.asarray(self.ts_data)})\n        timeseries = TimeSeriesPlot(\n            df=ts_df, x=\"time\", y=\"value\", ax=ax1, fig=self.fig\n        )\n\n    timeseries.plot(**timeseries_kwargs)\n\n    self.ax = [ax0, ax1]\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.VerticalBoxPlot","title":"<code>VerticalBoxPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Vertical box plot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>class VerticalBoxPlot(BasePlot):\n    \"\"\"Vertical box plot.\"\"\"\n\n    def __init__(self, data, y, thresholds, *args, **kwargs):\n        \"\"\"\n        Initialize the vertical box plot.\n        Args:\n            data (np.ndarray, pd.Series, xr.DataArray): Data to plot.\n            y (np.ndarray, pd.Series, xr.DataArray): Vertical coordinate.\n            thresholds (list): List of thresholds to bin the data.\n            **kwargs: Additional keyword arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.data = data\n        self.y = y\n        self.thresholds = thresholds\n\n    def plot(self, **kwargs: t.Any) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        **kwargs\n            Keyword arguments passed to `matplotlib.pyplot.boxplot`.\n        \"\"\"\n        if self.ax is None:\n            if self.fig is None:\n                self.fig = plt.figure()\n            self.ax = self.fig.add_subplot()\n\n        output_list = tools.split_by_threshold(self.data, self.y, self.thresholds)\n        position_list_1 = self.thresholds[:-1]\n        position_list_2 = self.thresholds[1:]\n        position_list_mid = [\n            (p1 + p2) / 2 for p1, p2 in zip(position_list_1, position_list_2)\n        ]\n\n        return self.ax.boxplot(\n            output_list, vert=False, positions=position_list_mid, **kwargs\n        )\n</code></pre>"},{"location":"api/#monet_plots.plots.VerticalBoxPlot.__init__","title":"<code>__init__(data, y, thresholds, *args, **kwargs)</code>","text":"<p>Initialize the vertical box plot. Args:     data (np.ndarray, pd.Series, xr.DataArray): Data to plot.     y (np.ndarray, pd.Series, xr.DataArray): Vertical coordinate.     thresholds (list): List of thresholds to bin the data.     **kwargs: Additional keyword arguments passed to BasePlot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def __init__(self, data, y, thresholds, *args, **kwargs):\n    \"\"\"\n    Initialize the vertical box plot.\n    Args:\n        data (np.ndarray, pd.Series, xr.DataArray): Data to plot.\n        y (np.ndarray, pd.Series, xr.DataArray): Vertical coordinate.\n        thresholds (list): List of thresholds to bin the data.\n        **kwargs: Additional keyword arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.data = data\n    self.y = y\n    self.thresholds = thresholds\n</code></pre>"},{"location":"api/#monet_plots.plots.VerticalBoxPlot.plot","title":"<code>plot(**kwargs)</code>","text":""},{"location":"api/#monet_plots.plots.VerticalBoxPlot.plot--parameters","title":"Parameters","text":"<p>**kwargs     Keyword arguments passed to <code>matplotlib.pyplot.boxplot</code>.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def plot(self, **kwargs: t.Any) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    **kwargs\n        Keyword arguments passed to `matplotlib.pyplot.boxplot`.\n    \"\"\"\n    if self.ax is None:\n        if self.fig is None:\n            self.fig = plt.figure()\n        self.ax = self.fig.add_subplot()\n\n    output_list = tools.split_by_threshold(self.data, self.y, self.thresholds)\n    position_list_1 = self.thresholds[:-1]\n    position_list_2 = self.thresholds[1:]\n    position_list_mid = [\n        (p1 + p2) / 2 for p1, p2 in zip(position_list_1, position_list_2)\n    ]\n\n    return self.ax.boxplot(\n        output_list, vert=False, positions=position_list_mid, **kwargs\n    )\n</code></pre>"},{"location":"api/#monet_plots.plots.VerticalSlice","title":"<code>VerticalSlice</code>","text":"<p>               Bases: <code>ProfilePlot</code></p> <p>Vertical cross-section plot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>class VerticalSlice(ProfilePlot):\n    \"\"\"Vertical cross-section plot.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize the vertical slice plot.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n    def plot(self, **kwargs: t.Any) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        **kwargs\n            Keyword arguments passed to `matplotlib.pyplot.contourf`.\n        \"\"\"\n        if self.ax is None:\n            if self.fig is None:\n                self.fig = plt.figure()\n            self.ax = self.fig.add_subplot()\n\n        self.ax.contourf(self.x, self.y, self.z, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.VerticalSlice.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the vertical slice plot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Initialize the vertical slice plot.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.VerticalSlice.plot","title":"<code>plot(**kwargs)</code>","text":""},{"location":"api/#monet_plots.plots.VerticalSlice.plot--parameters","title":"Parameters","text":"<p>**kwargs     Keyword arguments passed to <code>matplotlib.pyplot.contourf</code>.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def plot(self, **kwargs: t.Any) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    **kwargs\n        Keyword arguments passed to `matplotlib.pyplot.contourf`.\n    \"\"\"\n    if self.ax is None:\n        if self.fig is None:\n            self.fig = plt.figure()\n        self.ax = self.fig.add_subplot()\n\n    self.ax.contourf(self.x, self.y, self.z, **kwargs)\n</code></pre>"},{"location":"api/#monet_plots.plots.WindBarbsPlot","title":"<code>WindBarbsPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a barbs plot of wind on a map.</p> <p>This plot shows wind speed and direction using barbs.</p> Source code in <code>src/monet_plots/plots/wind_barbs.py</code> <pre><code>class WindBarbsPlot(SpatialPlot):\n    \"\"\"Create a barbs plot of wind on a map.\n\n    This plot shows wind speed and direction using barbs.\n    \"\"\"\n\n    def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n            wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n            gridobj (object): Object with LAT and LON variables.\n            **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.ws = np.asarray(ws)\n        self.wdir = np.asarray(wdir)\n        self.gridobj = gridobj\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the wind barbs plot.\"\"\"\n        barb_kwargs = self.add_features(**kwargs)\n        barb_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n        lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n        u, v = tools.wsdir2uv(self.ws, self.wdir)\n        # Subsample the data for clarity\n        skip = barb_kwargs.pop(\"skip\", 15)\n        self.ax.barbs(\n            lon[::skip, ::skip],\n            lat[::skip, ::skip],\n            u[::skip, ::skip],\n            v[::skip, ::skip],\n            **barb_kwargs,\n        )\n        return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.WindBarbsPlot.__init__","title":"<code>__init__(ws, wdir, gridobj, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>ws</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind speeds.</p> required <code>wdir</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind directions.</p> required <code>gridobj</code> <code>object</code> <p>Object with LAT and LON variables.</p> required <code>**kwargs</code> <p>Keyword arguments passed to SpatialPlot for projection and features.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/wind_barbs.py</code> <pre><code>def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n        wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n        gridobj (object): Object with LAT and LON variables.\n        **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.ws = np.asarray(ws)\n    self.wdir = np.asarray(wdir)\n    self.gridobj = gridobj\n</code></pre>"},{"location":"api/#monet_plots.plots.WindBarbsPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the wind barbs plot.</p> Source code in <code>src/monet_plots/plots/wind_barbs.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the wind barbs plot.\"\"\"\n    barb_kwargs = self.add_features(**kwargs)\n    barb_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n    lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n    u, v = tools.wsdir2uv(self.ws, self.wdir)\n    # Subsample the data for clarity\n    skip = barb_kwargs.pop(\"skip\", 15)\n    self.ax.barbs(\n        lon[::skip, ::skip],\n        lat[::skip, ::skip],\n        u[::skip, ::skip],\n        v[::skip, ::skip],\n        **barb_kwargs,\n    )\n    return self.ax\n</code></pre>"},{"location":"api/#monet_plots.plots.WindQuiverPlot","title":"<code>WindQuiverPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a quiver plot of wind vectors on a map.</p> <p>This plot shows wind speed and direction using arrows.</p> Source code in <code>src/monet_plots/plots/wind_quiver.py</code> <pre><code>class WindQuiverPlot(SpatialPlot):\n    \"\"\"Create a quiver plot of wind vectors on a map.\n\n    This plot shows wind speed and direction using arrows.\n    \"\"\"\n\n    def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n            wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n            gridobj (object): Object with LAT and LON variables.\n            **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.ws = np.asarray(ws)\n        self.wdir = np.asarray(wdir)\n        self.gridobj = gridobj\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the wind quiver plot.\"\"\"\n        quiver_kwargs = self.add_features(**kwargs)\n        quiver_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n        lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n        u, v = tools.wsdir2uv(self.ws, self.wdir)\n        # Subsample the data for clarity\n        quiv = self.ax.quiver(\n            lon[::15, ::15],\n            lat[::15, ::15],\n            u[::15, ::15],\n            v[::15, ::15],\n            **quiver_kwargs,\n        )\n        return quiv\n</code></pre>"},{"location":"api/#monet_plots.plots.WindQuiverPlot.__init__","title":"<code>__init__(ws, wdir, gridobj, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>ws</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind speeds.</p> required <code>wdir</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind directions.</p> required <code>gridobj</code> <code>object</code> <p>Object with LAT and LON variables.</p> required <code>**kwargs</code> <p>Keyword arguments passed to SpatialPlot for projection and features.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/wind_quiver.py</code> <pre><code>def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n        wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n        gridobj (object): Object with LAT and LON variables.\n        **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.ws = np.asarray(ws)\n    self.wdir = np.asarray(wdir)\n    self.gridobj = gridobj\n</code></pre>"},{"location":"api/#monet_plots.plots.WindQuiverPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the wind quiver plot.</p> Source code in <code>src/monet_plots/plots/wind_quiver.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the wind quiver plot.\"\"\"\n    quiver_kwargs = self.add_features(**kwargs)\n    quiver_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n    lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n    u, v = tools.wsdir2uv(self.ws, self.wdir)\n    # Subsample the data for clarity\n    quiv = self.ax.quiver(\n        lon[::15, ::15],\n        lat[::15, ::15],\n        u[::15, ::15],\n        v[::15, ::15],\n        **quiver_kwargs,\n    )\n    return quiv\n</code></pre>"},{"location":"api/#monet_plots.style.get_available_styles","title":"<code>get_available_styles()</code>","text":"<p>Returns a list of available style context names.</p>"},{"location":"api/#monet_plots.style.get_available_styles--returns","title":"Returns","text":"<p>list[str]     List of style names.</p> Source code in <code>src/monet_plots/style.py</code> <pre><code>def get_available_styles() -&gt; list[str]:\n    \"\"\"\n    Returns a list of available style context names.\n\n    Returns\n    -------\n    list[str]\n        List of style names.\n    \"\"\"\n    return list(_styles.keys())\n</code></pre>"},{"location":"api/#monet_plots.style.get_style_setting","title":"<code>get_style_setting(key, default=None)</code>","text":"<p>Retrieves a style setting from the currently active style. Looks in both standard rcParams and custom style settings.</p>"},{"location":"api/#monet_plots.style.get_style_setting--parameters","title":"Parameters","text":"<p>key : str     The name of the style setting. default : Any, optional     The default value if the key is not found, by default None.</p>"},{"location":"api/#monet_plots.style.get_style_setting--returns","title":"Returns","text":"<p>Any     The style setting value.</p> Source code in <code>src/monet_plots/style.py</code> <pre><code>def get_style_setting(key: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Retrieves a style setting from the currently active style.\n    Looks in both standard rcParams and custom style settings.\n\n    Parameters\n    ----------\n    key : str\n        The name of the style setting.\n    default : Any, optional\n        The default value if the key is not found, by default None.\n\n    Returns\n    -------\n    Any\n        The style setting value.\n    \"\"\"\n    # First check current style's dictionary (includes custom keys)\n    style_dict = _styles.get(_current_style_name, {})\n    if key in style_dict:\n        return style_dict[key]\n\n    # Fallback to general rcParams\n    return plt.rcParams.get(key, default)\n</code></pre>"},{"location":"api/#monet_plots.style.set_style","title":"<code>set_style(context='wiley')</code>","text":"<p>Set the plotting style based on a predefined context.</p>"},{"location":"api/#monet_plots.style.set_style--parameters","title":"Parameters","text":"<p>context : str, optional     The name of the style context to apply.     Available contexts: \"wiley\", \"presentation\", \"paper\", \"web\", \"pivotal_weather\", \"default\".     Defaults to \"wiley\".</p>"},{"location":"api/#monet_plots.style.set_style--raises","title":"Raises","text":"<p>ValueError     If an unknown context name is provided.</p> Source code in <code>src/monet_plots/style.py</code> <pre><code>def set_style(context: str = \"wiley\"):\n    \"\"\"\n    Set the plotting style based on a predefined context.\n\n    Parameters\n    ----------\n    context : str, optional\n        The name of the style context to apply.\n        Available contexts: \"wiley\", \"presentation\", \"paper\", \"web\", \"pivotal_weather\", \"default\".\n        Defaults to \"wiley\".\n\n    Raises\n    ------\n    ValueError\n        If an unknown context name is provided.\n    \"\"\"\n    global _current_style_name\n\n    if context not in _styles:\n        raise ValueError(\n            f\"Unknown style context: '{context}'. \"\n            f\"Available contexts are: {', '.join(_styles.keys())}\"\n        )\n\n    style_dict = _styles[context]\n\n    # Separate standard rcParams from custom ones\n    standard_rc = {k: v for k, v in style_dict.items() if k in plt.rcParams}\n\n    if context == \"default\":\n        plt.style.use(\"default\")\n    else:\n        plt.style.use(standard_rc)\n\n    _current_style_name = context\n</code></pre>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram","title":"<code>TaylorDiagram</code>","text":"<p>:no-index:</p> <p>Taylor diagram for visualizing model performance metrics.</p> <p>The Taylor diagram displays multiple statistical metrics in a single plot: - The radial distance from the origin represents the standard deviation - The azimuthal position represents the correlation coefficient - The distance from the reference point represents the root-mean-square (RMS) difference</p> <p>This class creates a Taylor diagram in a polar plot, where: - r = standard deviation - \u03b8 = arccos(correlation coefficient)</p> <p>This provides a comprehensive view of how well a model pattern matches observations.</p> Source code in <code>src/monet_plots/taylordiagram.py</code> <pre><code>class TaylorDiagram:\n    \"\"\"\n    :no-index:\n\n    Taylor diagram for visualizing model performance metrics.\n\n    The Taylor diagram displays multiple statistical metrics in a single plot:\n    - The radial distance from the origin represents the standard deviation\n    - The azimuthal position represents the correlation coefficient\n    - The distance from the reference point represents the root-mean-square (RMS) difference\n\n    This class creates a Taylor diagram in a polar plot, where:\n    - r = standard deviation\n    - \u03b8 = arccos(correlation coefficient)\n\n    This provides a comprehensive view of how well a model pattern matches observations.\n    \"\"\"\n\n    @_sns_context\n    def __init__(self, refstd, scale=1.5, fig=None, rect=111, label=\"_\"):\n        \"\"\"Initialize the Taylor diagram.\n\n        Parameters\n        ----------\n        refstd : float\n            The reference standard deviation (e.g., from observations or a reference model)\n            that other models will be compared against.\n        scale : float, default 1.5\n            The maximum standard deviation shown on the plot, as a multiple of refstd.\n            For example, if refstd=2 and scale=1.5, the maximum standard deviation\n            displayed will be 3.0.\n        fig : matplotlib.figure.Figure, optional\n            Figure to use. If None, a new figure will be created.\n        rect : int or tuple, default 111\n            Subplot specification (nrows, ncols, index) or 3-digit integer where\n            the digits represent nrows, ncols, and index in order.\n        label : str, default \"_\"\n            Label for the reference point. An underscore prefix makes the label not\n            appear in the legend.\n        \"\"\"\n\n        import mpl_toolkits.axisartist.floating_axes as FA\n        import mpl_toolkits.axisartist.grid_finder as GF\n        from matplotlib.projections import PolarAxes\n\n        self.refstd = refstd  # Reference standard deviation\n\n        tr = PolarAxes.PolarTransform(apply_theta_transforms=False)\n\n        # Correlation labels\n        rlocs = np.concatenate((np.arange(10) / 10.0, [0.95, 0.99]))\n        tlocs = np.arccos(rlocs)  # Conversion to polar angles\n        gl1 = GF.FixedLocator(tlocs)  # Positions\n        tf1 = GF.DictFormatter(dict(list(zip(tlocs, list(map(str, rlocs))))))\n\n        # Standard deviation axis extent\n        self.smin = 0\n        self.smax = scale * self.refstd\n        ghelper = FA.GridHelperCurveLinear(\n            tr,\n            extremes=(0, np.pi / 2, self.smin, self.smax),\n            grid_locator1=gl1,\n            tick_formatter1=tf1,\n        )  # 1st quadrant\n\n        if fig is None:\n            fig = plt.figure()\n\n        ax = FA.FloatingSubplot(fig, rect, grid_helper=ghelper)\n        fig.add_subplot(ax)\n\n        # Adjust axes\n        ax.axis[\"top\"].set_axis_direction(\"bottom\")  # \"Angle axis\"\n        ax.axis[\"top\"].toggle(ticklabels=True, label=True)\n        ax.axis[\"top\"].major_ticklabels.set_axis_direction(\"top\")\n        ax.axis[\"top\"].label.set_axis_direction(\"top\")\n        ax.axis[\"top\"].label.set_text(\"Correlation\")\n\n        ax.axis[\"left\"].set_axis_direction(\"bottom\")  # \"X axis\"\n        ax.axis[\"left\"].label.set_text(\"Standard deviation\")\n\n        ax.axis[\"right\"].set_axis_direction(\"top\")  # \"Y axis\"\n        ax.axis[\"right\"].toggle(ticklabels=True)\n        ax.axis[\"right\"].major_ticklabels.set_axis_direction(\"left\")\n\n        ax.axis[\"bottom\"].set_visible(False)  # Useless\n\n        # Contours along standard deviations\n        ax.grid(False)\n\n        self._ax = ax  # Graphical axes\n        self.ax = ax.get_aux_axes(tr)  # Polar coordinates\n\n        # Add reference point and stddev contour\n        print(\"Reference std:\", self.refstd)\n        (line,) = self.ax.plot(\n            [0], self.refstd, \"r*\", ls=\"\", ms=14, label=label, zorder=10\n        )\n        t = np.linspace(0, np.pi / 2)\n        r = np.zeros_like(t) + self.refstd\n        self.ax.plot(t, r, \"k--\", label=\"_\")\n\n        # Collect sample points for latter use (e.g. legend)\n        self.samplePoints = [line]\n\n    @property\n    def samples(self):\n        \"\"\"Property to provide compatibility with tests expecting 'samples' attribute.\"\"\"\n        return self.samplePoints\n\n    @_sns_context\n    def add_sample(self, stddev, corrcoef, *args, **kwargs):\n        \"\"\"Add a sample point to the Taylor diagram.\n\n        Parameters\n        ----------\n        stddev : float\n            Standard deviation of the sample to add.\n        corrcoef : float\n            Correlation coefficient between the sample and reference (-1 to 1).\n        *args\n            Additional positional arguments passed to matplotlib's plot function.\n        **kwargs\n            Additional keyword arguments passed to matplotlib's plot function.\n            Common options include 'marker', 'markersize', 'color', and 'label'.\n\n        Returns\n        -------\n        matplotlib.lines.Line2D\n            The line object representing the sample in the plot.\n\n        Notes\n        -----\n        Points closer to the reference point indicate better agreement with\n        the reference dataset.\n        \"\"\"\n        (line,) = self.ax.plot(\n            np.arccos(corrcoef), stddev, *args, **kwargs\n        )  # (theta,radius)\n        self.samplePoints.append(line)\n\n        return line\n\n    @_sns_context\n    def add_contours(self, levels=5, **kwargs):\n        \"\"\"Add constant RMS difference contours to the Taylor diagram.\n\n        Parameters\n        ----------\n        levels : int or array-like, default 5\n            If an integer, it defines the number of equally-spaced contour levels.\n            If array-like, it explicitly defines the contour levels.\n        **kwargs\n            Additional keyword arguments passed to matplotlib's contour function.\n            Common options include 'colors', 'linewidths', and 'linestyles'.\n\n        Returns\n        -------\n        matplotlib.contour.QuadContourSet\n            The contour set created by the function.\n\n        Notes\n        -----\n        These contours represent lines of constant RMS difference between the\n        reference and sample datasets. They help visualize the combined effect\n        of differences in standard deviation and correlation.\n        \"\"\"\n\n        rs, ts = np.meshgrid(\n            np.linspace(self.smin, self.smax), np.linspace(0, np.pi / 2)\n        )\n        # Compute centered RMS difference\n        rms = np.sqrt(self.refstd**2 + rs**2 - 2 * self.refstd * rs * np.cos(ts))\n\n        contours = self.ax.contour(ts, rs, rms, levels, **kwargs)\n\n        return contours\n</code></pre>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.samples","title":"<code>samples</code>  <code>property</code>","text":"<p>Property to provide compatibility with tests expecting 'samples' attribute.</p>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.__init__","title":"<code>__init__(refstd, scale=1.5, fig=None, rect=111, label='_')</code>","text":"<p>Initialize the Taylor diagram.</p>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.__init__--parameters","title":"Parameters","text":"<p>refstd : float     The reference standard deviation (e.g., from observations or a reference model)     that other models will be compared against. scale : float, default 1.5     The maximum standard deviation shown on the plot, as a multiple of refstd.     For example, if refstd=2 and scale=1.5, the maximum standard deviation     displayed will be 3.0. fig : matplotlib.figure.Figure, optional     Figure to use. If None, a new figure will be created. rect : int or tuple, default 111     Subplot specification (nrows, ncols, index) or 3-digit integer where     the digits represent nrows, ncols, and index in order. label : str, default \"_\"     Label for the reference point. An underscore prefix makes the label not     appear in the legend.</p> Source code in <code>src/monet_plots/taylordiagram.py</code> <pre><code>@_sns_context\ndef __init__(self, refstd, scale=1.5, fig=None, rect=111, label=\"_\"):\n    \"\"\"Initialize the Taylor diagram.\n\n    Parameters\n    ----------\n    refstd : float\n        The reference standard deviation (e.g., from observations or a reference model)\n        that other models will be compared against.\n    scale : float, default 1.5\n        The maximum standard deviation shown on the plot, as a multiple of refstd.\n        For example, if refstd=2 and scale=1.5, the maximum standard deviation\n        displayed will be 3.0.\n    fig : matplotlib.figure.Figure, optional\n        Figure to use. If None, a new figure will be created.\n    rect : int or tuple, default 111\n        Subplot specification (nrows, ncols, index) or 3-digit integer where\n        the digits represent nrows, ncols, and index in order.\n    label : str, default \"_\"\n        Label for the reference point. An underscore prefix makes the label not\n        appear in the legend.\n    \"\"\"\n\n    import mpl_toolkits.axisartist.floating_axes as FA\n    import mpl_toolkits.axisartist.grid_finder as GF\n    from matplotlib.projections import PolarAxes\n\n    self.refstd = refstd  # Reference standard deviation\n\n    tr = PolarAxes.PolarTransform(apply_theta_transforms=False)\n\n    # Correlation labels\n    rlocs = np.concatenate((np.arange(10) / 10.0, [0.95, 0.99]))\n    tlocs = np.arccos(rlocs)  # Conversion to polar angles\n    gl1 = GF.FixedLocator(tlocs)  # Positions\n    tf1 = GF.DictFormatter(dict(list(zip(tlocs, list(map(str, rlocs))))))\n\n    # Standard deviation axis extent\n    self.smin = 0\n    self.smax = scale * self.refstd\n    ghelper = FA.GridHelperCurveLinear(\n        tr,\n        extremes=(0, np.pi / 2, self.smin, self.smax),\n        grid_locator1=gl1,\n        tick_formatter1=tf1,\n    )  # 1st quadrant\n\n    if fig is None:\n        fig = plt.figure()\n\n    ax = FA.FloatingSubplot(fig, rect, grid_helper=ghelper)\n    fig.add_subplot(ax)\n\n    # Adjust axes\n    ax.axis[\"top\"].set_axis_direction(\"bottom\")  # \"Angle axis\"\n    ax.axis[\"top\"].toggle(ticklabels=True, label=True)\n    ax.axis[\"top\"].major_ticklabels.set_axis_direction(\"top\")\n    ax.axis[\"top\"].label.set_axis_direction(\"top\")\n    ax.axis[\"top\"].label.set_text(\"Correlation\")\n\n    ax.axis[\"left\"].set_axis_direction(\"bottom\")  # \"X axis\"\n    ax.axis[\"left\"].label.set_text(\"Standard deviation\")\n\n    ax.axis[\"right\"].set_axis_direction(\"top\")  # \"Y axis\"\n    ax.axis[\"right\"].toggle(ticklabels=True)\n    ax.axis[\"right\"].major_ticklabels.set_axis_direction(\"left\")\n\n    ax.axis[\"bottom\"].set_visible(False)  # Useless\n\n    # Contours along standard deviations\n    ax.grid(False)\n\n    self._ax = ax  # Graphical axes\n    self.ax = ax.get_aux_axes(tr)  # Polar coordinates\n\n    # Add reference point and stddev contour\n    print(\"Reference std:\", self.refstd)\n    (line,) = self.ax.plot(\n        [0], self.refstd, \"r*\", ls=\"\", ms=14, label=label, zorder=10\n    )\n    t = np.linspace(0, np.pi / 2)\n    r = np.zeros_like(t) + self.refstd\n    self.ax.plot(t, r, \"k--\", label=\"_\")\n\n    # Collect sample points for latter use (e.g. legend)\n    self.samplePoints = [line]\n</code></pre>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.add_contours","title":"<code>add_contours(levels=5, **kwargs)</code>","text":"<p>Add constant RMS difference contours to the Taylor diagram.</p>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.add_contours--parameters","title":"Parameters","text":"<p>levels : int or array-like, default 5     If an integer, it defines the number of equally-spaced contour levels.     If array-like, it explicitly defines the contour levels. **kwargs     Additional keyword arguments passed to matplotlib's contour function.     Common options include 'colors', 'linewidths', and 'linestyles'.</p>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.add_contours--returns","title":"Returns","text":"<p>matplotlib.contour.QuadContourSet     The contour set created by the function.</p>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.add_contours--notes","title":"Notes","text":"<p>These contours represent lines of constant RMS difference between the reference and sample datasets. They help visualize the combined effect of differences in standard deviation and correlation.</p> Source code in <code>src/monet_plots/taylordiagram.py</code> <pre><code>@_sns_context\ndef add_contours(self, levels=5, **kwargs):\n    \"\"\"Add constant RMS difference contours to the Taylor diagram.\n\n    Parameters\n    ----------\n    levels : int or array-like, default 5\n        If an integer, it defines the number of equally-spaced contour levels.\n        If array-like, it explicitly defines the contour levels.\n    **kwargs\n        Additional keyword arguments passed to matplotlib's contour function.\n        Common options include 'colors', 'linewidths', and 'linestyles'.\n\n    Returns\n    -------\n    matplotlib.contour.QuadContourSet\n        The contour set created by the function.\n\n    Notes\n    -----\n    These contours represent lines of constant RMS difference between the\n    reference and sample datasets. They help visualize the combined effect\n    of differences in standard deviation and correlation.\n    \"\"\"\n\n    rs, ts = np.meshgrid(\n        np.linspace(self.smin, self.smax), np.linspace(0, np.pi / 2)\n    )\n    # Compute centered RMS difference\n    rms = np.sqrt(self.refstd**2 + rs**2 - 2 * self.refstd * rs * np.cos(ts))\n\n    contours = self.ax.contour(ts, rs, rms, levels, **kwargs)\n\n    return contours\n</code></pre>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.add_sample","title":"<code>add_sample(stddev, corrcoef, *args, **kwargs)</code>","text":"<p>Add a sample point to the Taylor diagram.</p>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.add_sample--parameters","title":"Parameters","text":"<p>stddev : float     Standard deviation of the sample to add. corrcoef : float     Correlation coefficient between the sample and reference (-1 to 1). args     Additional positional arguments passed to matplotlib's plot function. *kwargs     Additional keyword arguments passed to matplotlib's plot function.     Common options include 'marker', 'markersize', 'color', and 'label'.</p>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.add_sample--returns","title":"Returns","text":"<p>matplotlib.lines.Line2D     The line object representing the sample in the plot.</p>"},{"location":"api/#monet_plots.taylordiagram.TaylorDiagram.add_sample--notes","title":"Notes","text":"<p>Points closer to the reference point indicate better agreement with the reference dataset.</p> Source code in <code>src/monet_plots/taylordiagram.py</code> <pre><code>@_sns_context\ndef add_sample(self, stddev, corrcoef, *args, **kwargs):\n    \"\"\"Add a sample point to the Taylor diagram.\n\n    Parameters\n    ----------\n    stddev : float\n        Standard deviation of the sample to add.\n    corrcoef : float\n        Correlation coefficient between the sample and reference (-1 to 1).\n    *args\n        Additional positional arguments passed to matplotlib's plot function.\n    **kwargs\n        Additional keyword arguments passed to matplotlib's plot function.\n        Common options include 'marker', 'markersize', 'color', and 'label'.\n\n    Returns\n    -------\n    matplotlib.lines.Line2D\n        The line object representing the sample in the plot.\n\n    Notes\n    -----\n    Points closer to the reference point indicate better agreement with\n    the reference dataset.\n    \"\"\"\n    (line,) = self.ax.plot(\n        np.arccos(corrcoef), stddev, *args, **kwargs\n    )  # (theta,radius)\n    self.samplePoints.append(line)\n\n    return line\n</code></pre>"},{"location":"api/#monet_plots.tools.split_by_threshold","title":"<code>split_by_threshold(data_list, alt_list, threshold_list)</code>","text":"<p>Splits data into bins based on altitude thresholds.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list</code> <p>List of data values.</p> required <code>alt_list</code> <code>list</code> <p>List of altitude values corresponding to the data.</p> required <code>threshold_list</code> <code>list</code> <p>List of altitude thresholds to bin the data.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of arrays, where each array contains the data values   within an altitude bin.</p> Source code in <code>src/monet_plots/tools.py</code> <pre><code>def split_by_threshold(data_list, alt_list, threshold_list):\n    \"\"\"\n    Splits data into bins based on altitude thresholds.\n\n    Args:\n        data_list (list): List of data values.\n        alt_list (list): List of altitude values corresponding to the data.\n        threshold_list (list): List of altitude thresholds to bin the data.\n\n    Returns:\n        list: A list of arrays, where each array contains the data values\n              within an altitude bin.\n    \"\"\"\n    df = pd.DataFrame(data={\"data\": data_list, \"alt\": alt_list})\n    output_list = []\n    for i in range(1, len(threshold_list)):\n        df_here = df.data.loc[\n            (df.alt &gt; threshold_list[i - 1]) &amp; (df.alt &lt;= threshold_list[i])\n        ]\n        output_list.append(df_here.values)\n    return output_list\n</code></pre>"},{"location":"api/#monet_plots.tools.uv2wsdir","title":"<code>uv2wsdir(u, v)</code>","text":"<p>Converts u and v components to wind speed and direction.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray</code> <p>The u component of the wind.</p> required <code>v</code> <code>ndarray</code> <p>The v component of the wind.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the wind speed and direction.</p> Source code in <code>src/monet_plots/tools.py</code> <pre><code>def uv2wsdir(u, v):\n    \"\"\"Converts u and v components to wind speed and direction.\n\n    Args:\n        u (numpy.ndarray): The u component of the wind.\n        v (numpy.ndarray): The v component of the wind.\n\n    Returns:\n        tuple: A tuple containing the wind speed and direction.\n    \"\"\"\n    ws = np.sqrt(u**2 + v**2)\n    wdir = 180 + (180 / np.pi) * np.arctan2(u, v)\n    return ws, wdir\n</code></pre>"},{"location":"api/#monet_plots.tools.wsdir2uv","title":"<code>wsdir2uv(ws, wdir)</code>","text":"<p>Converts wind speed and direction to u and v components.</p> <p>Parameters:</p> Name Type Description Default <code>ws</code> <code>ndarray</code> <p>The wind speed.</p> required <code>wdir</code> <code>ndarray</code> <p>The wind direction.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the u and v components of the wind.</p> Source code in <code>src/monet_plots/tools.py</code> <pre><code>def wsdir2uv(ws, wdir):\n    \"\"\"Converts wind speed and direction to u and v components.\n\n    Args:\n        ws (numpy.ndarray): The wind speed.\n        wdir (numpy.ndarray): The wind direction.\n\n    Returns:\n        tuple: A tuple containing the u and v components of the wind.\n    \"\"\"\n    rad = np.pi / 180.0\n    u = -ws * np.sin(wdir * rad)\n    v = -ws * np.cos(wdir * rad)\n    return u, v\n</code></pre>"},{"location":"api/base/","title":"Base Plot Module","text":"<p>The <code>monet_plots.base</code> module provides the foundational classes and functionality for all plot types in MONET Plots.</p>"},{"location":"api/base/#baseplot-class","title":"BasePlot Class","text":"<p><code>BasePlot</code> is the abstract base class that all plot types inherit from. It provides common functionality for plot creation, customization, and management.</p>"},{"location":"api/base/#class-signature","title":"Class Signature","text":"<pre><code>class BasePlot:\n    \"\"\"Abstract base class for all plot types in MONET Plots.\"\"\"\n\n\n    def __init__(self, figsize=(8, 6), dpi=100, **kwargs):\n        \"\"\"Initialize a BasePlot instance.\n\n\n        Args:\n            figsize (tuple): Figure size (width, height) in inches\n            dpi (int): Dots per inch for the figure\n            **kwargs: Additional keyword arguments\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/base/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Default Description <code>figsize</code> <code>tuple</code> <code>(8, 6)</code> Figure size in inches (width, height) <code>dpi</code> <code>int</code> <code>100</code> Resolution of the figure in dots per inch <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional matplotlib figure parameters"},{"location":"api/base/#public-methods","title":"Public Methods","text":""},{"location":"api/base/#plotdata-kwargs","title":"<code>plot(data, **kwargs)</code>","text":"<p>Main plotting method that must be implemented by subclasses.</p> <pre><code>def plot(self, data, **kwargs):\n    \"\"\"Main plotting method.\n\n\n    Args:\n        data: Input data to plot\n        **kwargs: Additional plotting parameters\n\n\n    Returns:\n        None\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement plot method\")\n</code></pre>"},{"location":"api/base/#savefilename-dpinone-kwargs","title":"<code>save(filename, dpi=None, **kwargs)</code>","text":"<p>Save the current plot to a file.</p> <pre><code>def save(self, filename, dpi=None, **kwargs):\n    \"\"\"Save the plot to a file.\n\n\n    Args:\n        filename (str): Output filename\n        dpi (int, optional): DPI for saved image. Defaults to Figure DPI\n        **kwargs: Additional savefig parameters\n\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre> <p>Example: <pre><code>plot = SpatialPlot()\nplot.plot(data)\nplot.save('output.png', dpi=300)  # High resolution output\n</code></pre></p>"},{"location":"api/base/#close","title":"<code>close()</code>","text":"<p>Close the plot and free memory.</p> <pre><code>def close(self):\n    \"\"\"Close the plot and free resources.\n\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre> <p>Example: <pre><code>plot = SpatialPlot()\nplot.plot(data)\nplot.save('output.png')\nplot.close()  # Free memory\n</code></pre></p>"},{"location":"api/base/#titletext-fontsize14-kwargs","title":"<code>title(text, fontsize=14, **kwargs)</code>","text":"<p>Set the plot title.</p> <pre><code>def title(self, text, fontsize=14, **kwargs):\n    \"\"\"Set the plot title.\n\n\n    Args:\n        text (str): Title text\n        fontsize (int, optional): Font size. Defaults to 14\n        **kwargs: Additional title parameters\n\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    pass\n</code></pre> <p>Example: <pre><code>plot = SpatialPlot()\nplot.plot(data)\nplot.title(\"My Plot Title\", fontsize=16, pad=20)\n</code></pre></p>"},{"location":"api/base/#xlabeltext-fontsize12-kwargs","title":"<code>xlabel(text, fontsize=12, **kwargs)</code>","text":"<p>Set the x-axis label.</p> <pre><code>def xlabel(self, text, fontsize=12, **kwargs):\n    \"\"\"Set the x-axis label.\n\n\n    Args:\n        text (str): X-axis label text\n        fontsize (int, optional): Font size. Defaults to 12\n        **kwargs: Additional label parameters\n\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    pass\n</code></pre> <p>Example: <pre><code>plot = TimeSeriesPlot()\nplot.plot(df, x='time', y='value')\nplot.xlabel(\"Date\", fontsize=12)\n</code></pre></p>"},{"location":"api/base/#ylabeltext-fontsize12-kwargs","title":"<code>ylabel(text, fontsize=12, **kwargs)</code>","text":"<p>Set the y-axis label.</p> <pre><code>def ylabel(self, text, fontsize=12, **kwargs):\n    \"\"\"Set the y-axis label.\n\n\n    Args:\n        text (str): Y-axis label text\n        fontsize (int, optional): Font size. Defaults to 12\n        **kwargs: Additional label parameters\n\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    pass\n</code></pre> <p>Example: <pre><code>plot = TimeSeriesPlot()\nplot.plot(df, x='time', y='value')\nplot.ylabel(\"Temperature (\u00b0C)\")\n</code></pre></p>"},{"location":"api/base/#legendargs-kwargs","title":"<code>legend(*args, **kwargs)</code>","text":"<p>Add a legend to the plot.</p> <pre><code>def legend(self, *args, **kwargs):\n    \"\"\"Add a legend to the plot.\n\n\n    Args:\n        *args: Legend labels\n        **kwargs: Additional legend parameters\n\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    pass\n</code></pre> <p>Example: <pre><code>plot = ScatterPlot()\nplot.plot(data1, label='Model 1')\nplot.plot(data2, label='Model 2')\nplot.legend(loc='upper right', fontsize=10)\n</code></pre></p>"},{"location":"api/base/#gridshowtrue-kwargs","title":"<code>grid(show=True, **kwargs)</code>","text":"<p>Toggle plot grid.</p> <pre><code>def grid(self, show=True, **kwargs):\n    \"\"\"Toggle plot grid.\n\n\n    Args:\n        show (bool): Whether to show grid. Defaults to True\n        **kwargs: Additional grid parameters\n\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    pass\n</code></pre> <p>Example: <pre><code>plot = ScatterPlot()\nplot.plot(data)\nplot.grid(show=True, linestyle='--', alpha=0.5)\n</code></pre></p>"},{"location":"api/base/#properties","title":"Properties","text":""},{"location":"api/base/#figure","title":"<code>figure</code>","text":"<p>Access the underlying matplotlib Figure object.</p> <pre><code>@property\ndef figure(self):\n    \"\"\"Get the matplotlib Figure object.\"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/base/#axes","title":"<code>axes</code>","text":"<p>Access the matplotlib Axes object(s).</p> <pre><code>@property\ndef axes(self):\n    \"\"\"Get the matplotlib Axes object(s).\"\"\"\n    return self._axes\n</code></pre>"},{"location":"api/base/#method-chaining","title":"Method Chaining","text":"<p>All setter methods return <code>self</code>, allowing method chaining:</p> <pre><code>plot = SpatialPlot()\nplot.plot(data)\\\n   .title(\"My Plot\")\\\n   .xlabel(\"X-axis\")\\\n   .ylabel(\"Y-axis\")\\\n   .legend()\\\n   .save(\"output.png\")\n</code></pre>"},{"location":"api/base/#subclass-implementation","title":"Subclass Implementation","text":"<p>When creating custom plot classes, inherit from <code>BasePlot</code> and implement the <code>plot()</code> method:</p> <pre><code>from monet_plots.base import BasePlot\nimport matplotlib.pyplot as plt\n\nclass CustomPlot(BasePlot):\n    def plot(self, data, **kwargs):\n        \"\"\"Implement custom plotting logic.\"\"\"\n        # Your plotting code here\n        plt.plot(data, **kwargs)\n        return self\n</code></pre>"},{"location":"api/base/#error-handling","title":"Error Handling","text":"<p>The base class includes automatic error handling for common issues:</p> <ul> <li>Invalid filenames: Raises <code>ValueError</code> for invalid file paths</li> <li>Missing dependencies: Provides helpful error messages</li> <li>Memory management: Automatic resource cleanup when possible</li> </ul>"},{"location":"api/base/#debug-mode","title":"Debug Mode","text":"<p>Enable debug output for troubleshooting:</p> <pre><code>plot = SpatialPlot(debug=True)\nplot.plot(data)\n</code></pre>"},{"location":"api/base/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Always call <code>close()</code> when done with plots to free memory</li> <li>Reuse plot objects when possible instead of creating new ones</li> <li>Use appropriate DPI values for your output needs</li> </ul> <p>Related Resources:</p> <ul> <li>Plot Types API - Specific plot type implementations</li> <li>Style Configuration - Customizing plot appearance</li> <li>Examples - Practical usage examples</li> </ul>"},{"location":"api/colorbars/","title":"Colorbars Module","text":"<p>The <code>monet_plots.colorbars</code> module provides utilities for creating and customizing colorbars in scientific plots. These utilities are designed to work seamlessly with MONET Plots and matplotlib.</p>"},{"location":"api/colorbars/#overview","title":"Overview","text":"<p>Colorbars are essential for interpreting spatial and statistical plots. This module provides advanced colorbar creation functionality including indexed colorbars, custom tick labels, and colormap manipulation.</p>"},{"location":"api/colorbars/#functions","title":"Functions","text":""},{"location":"api/colorbars/#colorbar_indexncolors-cmap-minvalnone-maxvalnone-dtypeint-basemapnone","title":"<code>colorbar_index(ncolors, cmap, minval=None, maxval=None, dtype=\"int\", basemap=None)</code>","text":"<p>Create a colorbar with discrete colors and custom tick labels.</p> <pre><code>from monet_plots import colorbar_index\n\n# Create indexed colorbar\ncbar, cmap = colorbar_index(\n    ncolors=10,\n    cmap='viridis',\n    minval=0,\n    maxval=100\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>ncolors</code> <code>int</code> Required Number of discrete colors to use <code>cmap</code> <code>str</code> or <code>Colormap</code> Required Colormap name or object <code>minval</code> <code>float</code> <code>None</code> Minimum value for tick labels <code>maxval</code> <code>float</code> <code>None</code> Maximum value for tick labels <code>dtype</code> <code>str</code> or <code>type</code> <code>\"int\"</code> Data type for tick labels <code>basemap</code> <code>Basemap</code> <code>None</code> Basemap instance (optional) <p>Returns: - <code>colorbar</code>: matplotlib.colorbar.Colorbar instance - <code>discretized_cmap</code>: Discretized colormap</p> <p>Example: <pre><code>import numpy as np\nfrom monet_plots import SpatialPlot, colorbar_index\n\n# Create spatial plot\nplot = SpatialPlot(figsize=(10, 8))\n\n# Generate sample data\ndata = np.random.random((50, 100)) * 100\n\n# Plot with indexed colorbar\nim = plot.ax.imshow(data, cmap='viridis')\n\n# Create indexed colorbar\ncbar, cmap = colorbar_index(\n    ncolors=10,\n    cmap='viridis',\n    minval=0,\n    maxval=100,\n    dtype=int\n)\n\n# Use the discretized colormap for the plot\nim.set_cmap(cmap)\nplot.save('indexed_colorbar.png')\n</code></pre></p>"},{"location":"api/colorbars/#cmap_discretizecmap-n","title":"<code>cmap_discretize(cmap, N)</code>","text":"<p>Return a discrete colormap from a continuous colormap.</p> <pre><code>from monet_plots import cmap_discretize\n\n# Discretize continuous colormap\ndiscrete_cmap = cmap_discretize('viridis', 5)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>cmap</code> <code>str</code> or <code>Colormap</code> Required Colormap name or object to discretize <code>N</code> <code>int</code> Required Number of discrete colors <p>Returns: - <code>matplotlib.colors.LinearSegmentedColormap</code>: Discretized colormap</p> <p>Example: <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots import cmap_discretize, SpatialPlot\n\n# Create discretized colormap\ndiscrete_cmap = cmap_discretize('plasma', 7)\n\n# Use in plot\nplot = SpatialPlot()\ndata = np.random.random((30, 50))\nplot.plot(data, cmap=discrete_cmap, title=\"Discrete Colormap\")\nplot.save('discrete_colormap.png')\n</code></pre></p>"},{"location":"api/colorbars/#colorbar_from_cmapcmap-vminnone-vmaxnone-kwargs","title":"<code>colorbar_from_cmap(cmap, vmin=None, vmax=None, **kwargs)</code>","text":"<p>Create a colorbar directly from a colormap.</p> <pre><code>from monet_plots import colorbar_from_cmap\n\n# Create colorbar from colormap\ncbar = colorbar_from_cmap('viridis', vmin=0, vmax=1)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>cmap</code> <code>str</code> or <code>Colormap</code> Required Colormap name or object <code>vmin</code> <code>float</code> <code>None</code> Minimum value for colorbar <code>vmax</code> <code>float</code> <code>None</code> Maximum value for colorbar <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional colorbar parameters <p>Returns: - <code>matplotlib.colorbar.Colorbar</code>: Colorbar object</p> <p>Example: <pre><code>from monet_plots import colorbar_from_cmap, SpatialPlot\n\nplot = SpatialPlot()\ndata = np.random.random((40, 60))\n\n# Create plot with custom colorbar\nim = plot.ax.imshow(data, cmap='RdBu_r', vmin=-1, vmax=1)\n\n# Add colorbar\ncbar = colorbar_from_cmap(\n    'RdBu_r',\n    vmin=-1,\n    vmax=1,\n    label='Temperature Anomaly'\n)\n\nplot.save('custom_colorbar.png')\n</code></pre></p>"},{"location":"api/colorbars/#add_colorbarax-im-label-kwargs","title":"<code>add_colorbar(ax, im, label='', **kwargs)</code>","text":"<p>Add a colorbar to an existing axes object.</p> <pre><code>from monet_plots import add_colorbar\n\n# Add colorbar to existing plot\ncbar = add_colorbar(plot.ax, im, label='Value')\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>ax</code> <code>matplotlib.axes.Axes</code> Required Axes object to add colorbar to <code>im</code> <code>matplotlib.image.AxesImage</code> Required Image object to create colorbar from <code>label</code> <code>str</code> <code>''</code> Colorbar label <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional colorbar parameters <p>Returns: - <code>matplotlib.colorbar.Colorbar</code>: Colorbar object</p> <p>Example: <pre><code>import numpy as np\nfrom monet_plots import SpatialPlot, add_colorbar\n\nplot = SpatialPlot()\ndata = np.random.random((35, 55))\n\n# Create image\nim = plot.ax.imshow(data, cmap='coolwarm')\n\n# Add colorbar with custom formatting\ncbar = add_colorbar(\n    plot.ax,\n    im,\n    label='Concentration (ppb)',\n    orientation='horizontal',\n    shrink=0.8\n)\n\nplot.save('horizontal_colorbar.png')\n</code></pre></p>"},{"location":"api/colorbars/#create_diverging_cmapn_colors256-center0-kwargs","title":"<code>create_diverging_cmap(n_colors=256, center=0, **kwargs)</code>","text":"<p>Create a diverging colormap centered at a specific value.</p> <pre><code>from monet_plots import create_diverging_cmap\n\n# Create custom diverging colormap\ndiv_cmap = create_diverging_cmap(n_colors=256, center=0.5)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>n_colors</code> <code>int</code> <code>256</code> Number of colors in colormap <code>center</code> <code>float</code> <code>0</code> Center value for divergence <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional colormap parameters <p>Returns: - <code>matplotlib.colors.LinearSegmentedColormap</code>: Diverging colormap</p> <p>Example: <pre><code>import numpy as np\nfrom monet_plots import SpatialPlot, create_diverging_cmap\n\nplot = SpatialPlot()\ndata = np.random.normal(0, 1, (40, 60))\n\n# Create diverging colormap\ndiv_cmap = create_diverging_cmap(\n    n_colors=128,\n    center=0,\n    name='custom_diverging'\n)\n\n# Plot with diverging colormap\nplot.plot(data, cmap=div_cmap, title=\"Diverging Colormap\")\nplot.save('diverging_colormap.png')\n</code></pre></p>"},{"location":"api/colorbars/#advanced-colorbar-techniques","title":"Advanced Colorbar Techniques","text":""},{"location":"api/colorbars/#custom-tick-labels","title":"Custom Tick Labels","text":"<pre><code>from monet_plots import colorbar_index\nimport numpy as np\n\n# Create colorbar with custom labels\ncbar, cmap = colorbar_index(\n    ncolors=5,\n    cmap='YlOrRd',\n    minval=0,\n    maxval=50,\n    dtype=float\n)\n\n# Customize tick labels manually\ncbar.set_ticks([0, 10, 20, 30, 40, 50])\ncbar.set_ticklabels(['Low', 'Low-Med', 'Medium', 'Med-High', 'High'])\n</code></pre>"},{"location":"api/colorbars/#colorbar-with-scientific-notation","title":"Colorbar with Scientific Notation","text":"<pre><code>from monet_plots import colorbar_from_cmap\nimport matplotlib.ticker as ticker\n\n# Create colorbar with scientific notation\ncbar = colorbar_from_cmap('viridis', vmin=1e-6, vmax=1e2)\n\n# Format ticks with scientific notation\nformatter = ticker.ScalarFormatter(useMathText=True)\nformatter.set_powerlimits((-3, 3))\ncbar.ax.yaxis.set_major_formatter(formatter)\n</code></pre>"},{"location":"api/colorbars/#colorbar-with-multiple-levels","title":"Colorbar with Multiple Levels","text":"<pre><code>from monet_plots import colorbar_index, cmap_discretize\n\n# Create multi-level colorbar\nlevels = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nn_colors = len(levels) - 1\n\ncbar, cmap = colorbar_index(\n    ncolors=n_colors,\n    cmap='RdYlBu_r',\n    minval=levels[0],\n    maxval=levels[-1],\n    dtype=int\n)\n\n# Set custom tick positions\ncbar.set_ticks(levels)\n</code></pre>"},{"location":"api/colorbars/#common-use-cases","title":"Common Use Cases","text":""},{"location":"api/colorbars/#spatial-plots","title":"Spatial Plots","text":"<pre><code>import numpy as np\nfrom monet_plots import SpatialPlot, colorbar_index\n\n# Create spatial plot with indexed colorbar\nplot = SpatialPlot(figsize=(10, 8))\ndata = np.random.random((50, 100)) * 150\n\n# Plot data\nim = plot.ax.imshow(data, cmap='viridis')\n\n# Create indexed colorbar\ncbar, cmap = colorbar_index(\n    ncolors=15,\n    cmap='viridis',\n    minval=0,\n    maxval=150,\n    dtype=int\n)\n\n# Update plot colormap\nim.set_cmap(cmap)\n\n# Add labels and title\nplot.title(\"Spatial Distribution\", fontsize=14)\nplot.xlabel(\"Longitude\")\nplot.ylabel(\"Latitude\")\n\nplot.save(\"spatial_with_colorbar.png\")\n</code></pre>"},{"location":"api/colorbars/#statistical-plots","title":"Statistical Plots","text":"<pre><code>import numpy as np\nfrom monet_plots import colorbar_from_cmap, ScatterPlot\n\n# Create scatter plot with custom colorbar\nplot = ScatterPlot()\nx = np.random.normal(0, 1, 1000)\ny = np.random.normal(0, 1, 1000)\ncolors = np.random.uniform(0, 100, 1000)\n\nscatter = plot.ax.scatter(x, y, c=colors, cmap='plasma', alpha=0.6)\n\n# Add colorbar\ncbar = colorbar_from_cmap(\n    'plasma',\n    vmin=0,\n    vmax=100,\n    label='Confidence Level'\n)\n\nplot.title(\"Scatter Plot with Color Mapping\")\nplot.xlabel(\"X Variable\")\nplot.ylabel(\"Y Variable\")\n\nplot.save(\"scatter_with_colorbar.png\")\n</code></pre>"},{"location":"api/colorbars/#time-series-plots","title":"Time Series Plots","text":"<pre><code>import numpy as np\nimport pandas as pd\nfrom monet_plots import TimeSeriesPlot, colorbar_index\n\n# Create time series data\ndates = pd.date_range('2023-01-01', periods=365, freq='D')\ndata = pd.DataFrame({\n    'date': dates,\n    'temperature': 15 + 10 * np.sin(np.arange(365) * 0.1) + np.random.normal(0, 2, 365),\n    'confidence': np.random.uniform(0.8, 1.0, 365)\n})\n\n# Create time series plot with colored confidence bands\nplot = TimeSeriesPlot(figsize=(12, 6))\n\n# Plot temperature with confidence-based coloring\nfor i in range(len(data) - 1):\n    color_value = data['confidence'].iloc[i]\n    plot.ax.plot(\n        data['date'].iloc[i:i+2],\n        data['temperature'].iloc[i:i+2],\n        color=plt.cm.RdYlGn(color_value),\n        linewidth=2\n    )\n\n# Add colorbar for confidence\ncbar, cmap = colorbar_index(\n    ncolors=10,\n    cmap='RdYlGn',\n    minval=0.8,\n    maxval=1.0,\n    dtype=float\n)\n\nplot.title(\"Temperature with Confidence Bands\")\nplot.xlabel(\"Date\")\nplot.ylabel(\"Temperature (\u00b0C)\")\n\nplot.save(\"timeseries_with_colorbar.png\")\n</code></pre>"},{"location":"api/colorbars/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Reuse colorbars: Create colorbars once and reuse when possible</li> <li>Limit discrete levels: Use reasonable numbers of discrete colors (5-20)</li> <li>Cache colormaps: Store discretized colormaps for repeated use</li> </ul>"},{"location":"api/colorbars/#error-handling","title":"Error Handling","text":"<p>The module includes automatic error handling for common issues:</p> <ul> <li>Invalid colormaps: Provides helpful error messages for unknown colormap names</li> <li>Invalid parameters: Validates input ranges and data types</li> <li>Missing dependencies: Graceful handling of missing matplotlib components</li> </ul>"},{"location":"api/colorbars/#troubleshooting","title":"Troubleshooting","text":""},{"location":"api/colorbars/#colorbar-not-visible","title":"Colorbar Not Visible","text":"<pre><code># Ensure colorbar is properly attached\ncbar = plt.colorbar(im, ax=plot.ax)  # Explicitly specify axes\n</code></pre>"},{"location":"api/colorbars/#incorrect-tick-labels","title":"Incorrect Tick Labels","text":"<pre><code># Manually set tick labels\ncbar.set_ticks([0, 25, 50, 75, 100])\ncbar.set_ticklabels(['Min', 'Q1', 'Median', 'Q3', 'Max'])\n</code></pre>"},{"location":"api/colorbars/#colorbar-alignment-issues","title":"Colorbar Alignment Issues","text":"<pre><code># Adjust colorbar position\ncbar.ax.set_position([0.92, 0.15, 0.02, 0.7])  # [left, bottom, width, height]\n</code></pre> <p>Related Resources:</p> <ul> <li>Style Configuration - Plot styling and themes</li> <li>Plot Types API - Specific plot implementations</li> <li>Examples - Practical usage examples</li> </ul>"},{"location":"api/module_monet_plots/","title":"Main Package - monet_plots","text":"<p>The <code>monet_plots</code> package is the main entry point for the MONET Plots library. It provides convenient imports for all plot classes, style configurations, and utilities.</p>"},{"location":"api/module_monet_plots/#package-overview","title":"Package Overview","text":"<pre><code>import monet_plots\n\n# Check version\nprint(monet_plots.__version__)\nprint(monet_plots.__author__)\nprint(monet_plots.__email__)\n</code></pre>"},{"location":"api/module_monet_plots/#package-contents","title":"Package Contents","text":""},{"location":"api/module_monet_plots/#plot-classes","title":"Plot Classes","text":"Plot Type Class Description Spatial <code>SpatialPlot</code> Geospatial plots with cartopy support Time Series <code>TimeSeriesPlot</code> Time series with statistical bands Scatter <code>ScatterPlot</code> Scatter plots with regression lines Taylor Diagram <code>TaylorDiagramPlot</code> Model evaluation diagrams KDE <code>KDEPlot</code> Kernel density estimation plots Wind Quiver <code>WindQuiverPlot</code> Wind vector plots Wind Barbs <code>WindBarbsPlot</code> Wind barb plots Facet Grid <code>FacetGridPlot</code> Multi-panel figure layouts Soccer <code>SoccerPlot</code> Model bias vs error plots Curtain <code>CurtainPlot</code> Vertical cross-section plots Diurnal Error <code>DiurnalErrorPlot</code> Heat maps of error by hour Fingerprint <code>FingerprintPlot</code> Heat maps for temporal patterns Polar <code>BivariatePolarPlot</code> Concentration vs wind speed/direction Conditional Quantile <code>ConditionalQuantilePlot</code> Quantiles conditioned on observations"},{"location":"api/module_monet_plots/#style-configuration","title":"Style Configuration","text":"Component Description <code>wiley_style</code> Default Wiley-compliant style <code>aps_style</code> APS journal style <code>nature_style</code> Nature journal style <code>science_style</code> Science journal style"},{"location":"api/module_monet_plots/#utilities","title":"Utilities","text":"Module Description <code>colorbars</code> Colorbar creation utilities <code>taylordiagram</code> Taylor diagram functionality <code>plot_utils</code> Common plotting utilities <code>cartopy_utils</code> Cartopy integration utilities"},{"location":"api/module_monet_plots/#package-attributes","title":"Package Attributes","text":""},{"location":"api/module_monet_plots/#version-information","title":"Version Information","text":"<pre><code>print(monet_plots.__version__)      # Version string\nprint(monet_plots.__author__)       # Author name\nprint(monet_plots.__email__)        # Contact email\nprint(monet_plots.__description__)  # Package description\nprint(monet_plots.__url__)          # Project URL\n</code></pre>"},{"location":"api/module_monet_plots/#dependencies","title":"Dependencies","text":"<pre><code># Check required dependencies\nprint(monet_plots.__dependencies__)\nprint(monet_plots.__optional_dependencies__)\n\n# Check if optional dependencies are available\nprint(monet_plots.has_cartopy)      # True if cartopy is installed\nprint(monet_plots.has_seaborn)     # True if seaborn is installed\nprint(monet_plots.has_xarray)       # True if xarray is installed\n</code></pre>"},{"location":"api/module_monet_plots/#style-configuration_1","title":"Style Configuration","text":""},{"location":"api/module_monet_plots/#wiley_style","title":"<code>wiley_style</code>","text":"<p>The default Wiley-compliant style for scientific publications.</p> <pre><code>import monet_plots\nimport matplotlib.pyplot as plt\n\n# Apply Wiley style\nplt.style.use(monet_plots.wiley_style)\n</code></pre> <p>Style Configuration:</p> <pre><code>wiley_style = {\n    # Font settings\n    'font.family': 'serif',\n    'font.serif': 'Times New Roman',\n    'font.size': 10,\n\n    # Axes settings\n    'axes.labelsize': 10,\n    'axes.titlesize': 12,\n    'axes.grid': True,\n    'grid.linestyle': ':',\n    'grid.color': 'gray',\n\n    # Line settings\n    'lines.linewidth': 1.5,\n    'lines.markersize': 5,\n\n    # Legend settings\n    'legend.fontsize': 9,\n    'legend.frameon': False,\n\n    # Figure settings\n    'figure.figsize': (6, 4),\n    'figure.dpi': 300,\n    'savefig.dpi': 300,\n    'savefig.format': 'tiff',\n    'savefig.bbox': 'tight',\n}\n</code></pre>"},{"location":"api/module_monet_plots/#aps_style","title":"<code>aps_style</code>","text":"<p>American Physical Society (APS) compliant style.</p> <pre><code>import matplotlib.pyplot as plt\nplt.style.use(monet_plots.aps_style)\n</code></pre>"},{"location":"api/module_monet_plots/#nature_style","title":"<code>nature_style</code>","text":"<p>Nature journal compliant style.</p> <pre><code>import matplotlib.pyplot as plt\nplt.style.use(monet_plots.nature_style)\n</code></pre>"},{"location":"api/module_monet_plots/#science_style","title":"<code>science_style</code>","text":"<p>Science journal compliant style.</p> <pre><code>import matplotlib.pyplot as plt\nplt.style.use(monet_plots.science_style)\n</code></pre>"},{"location":"api/module_monet_plots/#usage-examples","title":"Usage Examples","text":""},{"location":"api/module_monet_plots/#basic-import-and-usage","title":"Basic Import and Usage","text":"<pre><code>import monet_plots\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Apply default style\nplt.style.use(monet_plots.wiley_style)\n\n# Create spatial plot\nplot = monet_plots.SpatialPlot(figsize=(10, 8))\ndata = np.random.random((50, 100))\nplot.plot(data, title=\"Basic Spatial Plot\")\nplot.save('basic_plot.png')\n</code></pre>"},{"location":"api/module_monet_plots/#working-with-different-plot-types","title":"Working with Different Plot Types","text":"<pre><code>import monet_plots\nimport pandas as pd\nimport numpy as np\n\n# Create sample data\ndates = pd.date_range('2023-01-01', periods=100, freq='D')\ndata = pd.DataFrame({\n    'time': dates,\n    'observed': np.random.normal(0, 1, 100),\n    'modeled': np.random.normal(0.1, 1.1, 100)\n})\n\n# Create different plot types\nspatial_plot = monet_plots.SpatialPlot()\ntimeseries_plot = monet_plots.TimeSeriesPlot()\nscatter_plot = monet_plots.ScatterPlot()\n\n# Plot data\nspatial_plot.plot(np.random.random((30, 50)), title=\"Spatial Data\")\ntimeseries_plot.plot(data, x='time', y='observed', title=\"Time Series\")\nscatter_plot.plot(data, x='observed', y='modeled', title=\"Scatter Plot\")\n\n# Save plots\nspatial_plot.save('spatial.png')\ntimeseries_plot.save('timeseries.png')\nscatter_plot.save('scatter.png')\n\n# Clean up\nspatial_plot.close()\ntimeseries_plot.close()\nscatter_plot.close()\n</code></pre>"},{"location":"api/module_monet_plots/#style-customization","title":"Style Customization","text":"<pre><code>import monet_plots\nimport matplotlib.pyplot as plt\n\n# Create custom presentation style\npresentation_style = monet_plots.custom_style(\n    base_style='wiley',\n    font_size=14,\n    figure_size=(12, 8),\n    grid_alpha=0.3\n)\n\nplt.style.use(presentation_style)\n\n# Create plots with custom style\nplot = monet_plots.SpatialPlot(figsize=(14, 10))\nplot.plot(data, title=\"Presentation Style Plot\")\nplot.save('presentation_plot.png')\n</code></pre>"},{"location":"api/module_monet_plots/#conditional-import-handling","title":"Conditional Import Handling","text":"<pre><code>import monet_plots\n\n# Safe import with optional dependencies\ntry:\n    import cartopy\n    print(\"Cartopy is available for geospatial plotting\")\n    plot = monet_plots.SpatialPlot()\nexcept ImportError:\n    print(\"Cartopy not available, using basic matplotlib\")\n    from matplotlib import pyplot as plt\n    fig, ax = plt.subplots()\n    ax.imshow(np.random.random((50, 100)))\n    plt.savefig('fallback_plot.png')\n</code></pre>"},{"location":"api/module_monet_plots/#package-configuration","title":"Package Configuration","text":""},{"location":"api/module_monet_plots/#environment-variables","title":"Environment Variables","text":"<pre><code>import os\nimport monet_plots\n\n# Set custom style directory\nos.environ['MONET_PLOTS_STYLE_DIR'] = '/path/to/custom/styles'\n\n# Set default figure size\nos.environ['MONET_PLOTS_DEFAULT_FIGSIZE'] = '10,8'\n\n# Set output directory\nos.environ['MONET_PLOTS_OUTPUT_DIR'] = './plots'\n</code></pre>"},{"location":"api/module_monet_plots/#configuration-file","title":"Configuration File","text":"<p>Create a configuration file at <code>~/.monet_plots_config.json</code>:</p> <pre><code>{\n  \"default_style\": \"wiley\",\n  \"figure_size\": [10, 8],\n  \"dpi\": 300,\n  \"save_format\": \"png\",\n  \"grid\": true,\n  \"legend\": true,\n  \"font_size\": 12,\n  \"color_palette\": \"viridis\"\n}\n</code></pre>"},{"location":"api/module_monet_plots/#programmatic-configuration","title":"Programmatic Configuration","text":"<pre><code>import monet_plots\n\n# Set global configuration\nmonet_plots.set_config(\n    default_style='aps',\n    figure_size=(12, 9),\n    dpi=300,\n    save_format='pdf'\n)\n\n# Get current configuration\nconfig = monet_plots.get_config()\nprint(f\"Current DPI: {config['dpi']}\")\nprint(f\"Default style: {config['default_style']}\")\n</code></pre>"},{"location":"api/module_monet_plots/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/module_monet_plots/#plugin-system","title":"Plugin System","text":"<pre><code>import monet_plots\n\n# Register custom plot types\nclass CustomPlot(monet_plots.BasePlot):\n    def plot(self, data, **kwargs):\n        # Custom plotting logic\n        pass\n\nmonet_plots.register_plot_type('custom', CustomPlot)\n\n# Use custom plot\nplot = monet_plots.create_plot('custom')\nplot.plot(data)\n</code></pre>"},{"location":"api/module_monet_plots/#batch-processing","title":"Batch Processing","text":"<pre><code>import monet_plots\nimport glob\n\n# Process multiple files\nfiles = glob.glob('data/*.nc')\n\nfor file in files:\n    # Load data\n    data = load_data(file)\n\n    # Create plot\n    plot = monet_plots.SpatialPlot()\n    plot.plot(data, title=f\"Data from {file}\")\n\n    # Save with consistent naming\n    filename = file.replace('.nc', '.png').replace('data/', 'plots/')\n    plot.save(filename)\n    plot.close()\n</code></pre>"},{"location":"api/module_monet_plots/#export-and-import","title":"Export and Import","text":"<pre><code>import monet_plots\n\n# Export style configuration\nstyle_config = monet_plots.export_style('wiley')\nwith open('wiley_style.json', 'w') as f:\n    json.dump(style_config, f, indent=2)\n\n# Import style configuration\nwith open('custom_style.json', 'r') as f:\n    custom_style = json.load(f)\nmonet_plots.import_style('custom', custom_style)\n</code></pre>"},{"location":"api/module_monet_plots/#error-handling","title":"Error Handling","text":"<p>The package includes comprehensive error handling and user-friendly messages:</p> <pre><code>import monet_plots\n\ntry:\n    # This will raise ImportError if cartopy is not available\n    plot = monet_plots.SpatialPlot()\nexcept ImportError as e:\n    print(f\"Missing dependency: {e}\")\n    print(\"Install with: pip install cartopy\")\nexcept ValueError as e:\n    print(f\"Invalid data: {e}\")\nexcept Exception as e:\n    print(f\"Plotting error: {e}\")\n</code></pre>"},{"location":"api/module_monet_plots/#performance-optimization","title":"Performance Optimization","text":"<pre><code>import monet_plots\nimport matplotlib.pyplot as plt\n\n# Enable performance mode\nmonet_plots.enable_performance_mode()\n\n# Create plots with optimized settings\nplot = monet_plots.SpatialPlot(\n    figsize=(8, 6),\n    dpi=100,  # Lower DPI for faster rendering\n    optimize=True\n)\n\n# Disable interactive features for batch processing\nplt.ioff()  # Turn off interactive mode\n\n# Process multiple plots efficiently\nplots = []\nfor data in data_list:\n    plot = monet_plots.SpatialPlot()\n    plot.plot(data)\n    plots.append(plot)\n\n# Save all plots at once\nmonet_plots.batch_save(plots, output_dir='./plots')\n\n# Clean up\nmonet_plots.cleanup()\n</code></pre>"},{"location":"api/module_monet_plots/#debug-mode","title":"Debug Mode","text":"<pre><code>import monet_plots\n\n# Enable debug mode\nmonet_plots.enable_debug_mode()\n\n# Create plot with debug output\nplot = monet_plots.SpatialPlot(debug=True)\nplot.plot(data)  # Will show debug information\n\n# Get debug information\ndebug_info = monet_plots.get_debug_info()\nprint(f\"Memory usage: {debug_info['memory_mb']:.2f} MB\")\nprint(f\"Render time: {debug_info['render_time']:.3f} seconds\")\n</code></pre> <p>Related Resources:</p> <ul> <li>Base API - Core plotting functionality</li> <li>Style Configuration - Detailed style documentation</li> <li>Plot Types - Specific plot implementations</li> <li>Examples - Practical usage examples</li> </ul>"},{"location":"api/plot_utils/","title":"Plot Utils Module","text":"<p>The <code>monet_plots.plot_utils</code> module provides utility functions for common plotting tasks that are used across multiple plot types. These utilities help maintain consistency and provide convenience functions for complex operations.</p>"},{"location":"api/plot_utils/#overview","title":"Overview","text":"<p>This module contains helper functions for formatting axes, managing figures, and performing common plotting operations that are shared across different plot types.</p>"},{"location":"api/plot_utils/#functions","title":"Functions","text":""},{"location":"api/plot_utils/#add_colorbarax-im-label-orientationvertical-fraction015-pad004-kwargs","title":"<code>add_colorbar(ax, im, label='', orientation='vertical', fraction=0.15, pad=0.04, **kwargs)</code>","text":"<p>Add a colorbar to an existing axes.</p> <pre><code>from monet_plots.plot_utils import add_colorbar\n\n# Add colorbar to existing plot\ncbar = add_colorbar(plot.ax, im, label='Temperature', orientation='horizontal')\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>ax</code> <code>matplotlib.axes.Axes</code> Required Axes object to add colorbar to <code>im</code> <code>matplotlib.image.AxesImage</code> Required Image object <code>label</code> <code>str</code> <code>''</code> Colorbar label <code>orientation</code> <code>str</code> <code>'vertical'</code> Colorbar orientation <code>fraction</code> <code>float</code> <code>0.15</code> Fraction of figure size <code>pad</code> <code>float</code> <code>0.04</code> Padding between axes and colorbar <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional colorbar parameters <p>Returns: - <code>matplotlib.colorbar.Colorbar</code>: Colorbar object</p> <p>Example: <pre><code>import numpy as np\nfrom monet_plots import SpatialPlot\nfrom monet_plots.plot_utils import add_colorbar\n\nplot = SpatialPlot(figsize=(10, 8))\ndata = np.random.random((50, 100))\n\n# Create image\nim = plot.ax.imshow(data, cmap='viridis')\n\n# Add colorbar with custom formatting\ncbar = add_colorbar(\n    plot.ax,\n    im,\n    label='Concentration (ppb)',\n    orientation='vertical',\n    fraction=0.12,\n    pad=0.02,\n    shrink=0.8\n)\n\nplot.save('colorbar_example.png')\n</code></pre></p>"},{"location":"api/plot_utils/#format_date_axisax-date_formaty-m-d-rotation0-kwargs","title":"<code>format_date_axis(ax, date_format='%Y-%m-%d', rotation=0, **kwargs)</code>","text":"<p>Format date axis labels.</p> <pre><code>from monet_plots.plot_utils import format_date_axis\n\n# Format date axis\nformat_date_axis(plot.ax, date_format='%b %Y', rotation=45)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>ax</code> <code>matplotlib.axes.Axes</code> Required Axes object to format <code>date_format</code> <code>str</code> <code>'%Y-%m-%d'</code> Date format string <code>rotation</code> <code>int</code> <code>0</code> Label rotation angle <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional formatting parameters <p>Returns: - <code>matplotlib.axes.Axes</code>: Formatted axes object</p> <p>Example: <pre><code>import pandas as pd\nfrom monet_plots import TimeSeriesPlot\nfrom monet_plots.plot_utils import format_date_axis\n\n# Create time series plot\nplot = TimeSeriesPlot()\ndates = pd.date_range('2023-01-01', periods=365, freq='D')\ndata = pd.DataFrame({\n    'date': dates,\n    'value': np.random.normal(0, 1, 365)\n})\n\nplot.plot(data, x='date', y='value', title='Formatted Date Axis')\n\n# Format date axis\nformat_date_axis(\n    plot.ax,\n    date_format='%b %Y',\n    rotation=45,\n    ha='right'\n)\n\nplot.save('formatted_dates.png')\n</code></pre></p>"},{"location":"api/plot_utils/#save_figurefig-filename-dpi300-bbox_inchestight-kwargs","title":"<code>save_figure(fig, filename, dpi=300, bbox_inches='tight', **kwargs)</code>","text":"<p>Save a matplotlib figure with consistent parameters.</p> <pre><code>from monet_plots.plot_utils import save_figure\n\n# Save figure with consistent formatting\nsave_figure(plot.fig, 'output.png', dpi=600, format='png')\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>fig</code> <code>matplotlib.figure.Figure</code> Required Figure to save <code>filename</code> <code>str</code> Required Output filename <code>dpi</code> <code>int</code> <code>300</code> Resolution in dots per inch <code>bbox_inches</code> <code>str</code> <code>'tight'</code> Bounding box mode <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional save parameters <p>Returns: - None</p> <p>Example: <pre><code>from monet_plots import SpatialPlot\nfrom monet_plots.plot_utils import save_figure\n\nplot = SpatialPlot()\nplot.plot(data)\nplot.title(\"High Quality Plot\")\n\n# Save with high quality settings\nsave_figure(\n    plot.fig,\n    'high_quality_plot.png',\n    dpi=600,\n    format='png',\n    quality=95,\n    optimize=True\n)\n</code></pre></p>"},{"location":"api/plot_utils/#add_gridax-showtrue-linestyle-alpha05-kwargs","title":"<code>add_grid(ax, show=True, linestyle=':', alpha=0.5, **kwargs)</code>","text":"<p>Add grid to axes with consistent styling.</p> <pre><code>from monet_plots.plot_utils import add_grid\n\n# Add styled grid\nadd_grid(plot.ax, show=True, linestyle='--', alpha=0.3)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>ax</code> <code>matplotlib.axes.Axes</code> Required Axes to add grid to <code>show</code> <code>bool</code> <code>True</code> Whether to show grid <code>linestyle</code> <code>str</code> <code>':'</code> Grid line style <code>alpha</code> <code>float</code> <code>0.5</code> Grid transparency <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional grid parameters <p>Returns: - <code>matplotlib.axes.Axes</code>: Axes with grid</p> <p>Example: <pre><code>from monet_plots import ScatterPlot\nfrom monet_plots.plot_utils import add_grid\n\nplot = ScatterPlot()\nplot.plot(data, x='x', y='y')\n\n# Add custom grid\nadd_grid(\n    plot.ax,\n    show=True,\n    linestyle='--',\n    alpha=0.3,\n    color='gray',\n    linewidth=0.5\n)\n\nplot.save('grid_example.png')\n</code></pre></p>"},{"location":"api/plot_utils/#create_figurenrows1-ncols1-figsize8-6-kwargs","title":"<code>create_figure(nrows=1, ncols=1, figsize=(8, 6), **kwargs)</code>","text":"<p>Create a matplotlib figure with MONET Plots defaults.</p> <pre><code>from monet_plots.plot_utils import create_figure\n\n# Create figure with defaults\nfig, axes = create_figure(nrows=2, ncols=2, figsize=(12, 10))\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>nrows</code> <code>int</code> <code>1</code> Number of rows <code>ncols</code> <code>int</code> <code>1</code> Number of columns <code>figsize</code> <code>tuple</code> <code>(8, 6)</code> Figure size <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional figure parameters <p>Returns: - <code>tuple</code>: (figure, axes) objects</p> <p>Example: <pre><code>from monet_plots.plot_utils import create_figure\n\n# Create multi-panel figure\nfig, axes = create_figure(\n    nrows=2,\n    ncols=2,\n    figsize=(14, 10),\n    sharex=True,\n    sharey=True\n)\n\n# Plot on each subplot\nfor i, ax in enumerate(axes.flat):\n    ax.plot(np.random.random(100) + i, label=f'Dataset {i+1}')\n    ax.legend()\n    ax.set_title(f'Panel {i+1}')\n\nplt.tight_layout()\nsave_figure(fig, 'multi_panel_plot.png')\n</code></pre></p>"},{"location":"api/plot_utils/#validate_datadata-required_columnsnone-data_typenone","title":"<code>validate_data(data, required_columns=None, data_type=None)</code>","text":"<p>Validate input data for plotting functions.</p> <pre><code>from monet_plots.plot_utils import validate_data\n\n# Validate DataFrame\nvalidate_data(df, required_columns=['time', 'value'], data_type='pandas')\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>data</code> <code>any</code> Required Data to validate <code>required_columns</code> <code>list</code> <code>None</code> Required column names <code>data_type</code> <code>str</code> <code>None</code> Expected data type <p>Returns: - <code>bool</code>: True if valid, raises ValueError if invalid</p> <p>Example: <pre><code>import pandas as pd\nfrom monet_plots.plot_utils import validate_data\n\n# Create valid data\ndf = pd.DataFrame({\n    'time': pd.date_range('2023-01-01', periods=100),\n    'value': np.random.normal(0, 1, 100)\n})\n\n# Validate data\ntry:\n    validate_data(df, required_columns=['time', 'value'], data_type='pandas')\n    print(\"Data is valid!\")\nexcept ValueError as e:\n    print(f\"Data validation failed: {e}\")\n</code></pre></p>"},{"location":"api/plot_utils/#create_subplot_layoutn_plots-max_cols3-figsizenone-kwargs","title":"<code>create_subplot_layout(n_plots, max_cols=3, figsize=None, **kwargs)</code>","text":"<p>Create optimal subplot layout for multiple plots.</p> <pre><code>from monet_plots.plot_utils import create_subplot_layout\n\n# Create layout for 7 plots\nfig, axes = create_subplot_layout(7, max_cols=3, figsize=(15, 10))\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>n_plots</code> <code>int</code> Required Number of plots to create <code>max_cols</code> <code>int</code> <code>3</code> Maximum number of columns <code>figsize</code> <code>tuple</code> <code>None</code> Figure size (auto-calculated if None) <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional parameters <p>Returns: - <code>tuple</code>: (figure, axes) objects</p> <p>Example: <pre><code>from monet_plots.plot_utils import create_subplot_layout\n\n# Create layout for multiple time series\nn_plots = 8\nfig, axes = create_subplot_layout(n_plots, max_cols=4, figsize=(16, 12))\n\n# Plot data on each subplot\nfor i, ax in enumerate(axes.flat):\n    dates = pd.date_range('2023-01-01', periods=365)\n    data = np.random.normal(i, 0.5, 365).cumsum()\n    ax.plot(dates, data, label=f'Series {i+1}')\n    ax.legend()\n    ax.set_title(f'Series {i+1}')\n\n# Format all date axes\nfor ax in axes.flat:\n    format_date_axis(ax, date_format='%b', rotation=45)\n\nplt.tight_layout()\nsave_figure(fig, 'multi_series_plot.png')\n</code></pre></p>"},{"location":"api/plot_utils/#add_legendax-labelsnone-locationbest-kwargs","title":"<code>add_legend(ax, labels=None, location='best', **kwargs)</code>","text":"<p>Add legend with MONET Plots defaults.</p> <pre><code>from monet_plots.plot_utils import add_legend\n\n# Add custom legend\nadd_legend(plot.ax, ['Model A', 'Model B'], location='upper right')\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>ax</code> <code>matplotlib.axes.Axes</code> Required Axes to add legend to <code>labels</code> <code>list</code> <code>None</code> Legend labels <code>location</code> <code>str</code> <code>'best'</code> Legend location <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional legend parameters <p>Returns: - <code>matplotlib.legend.Legend</code>: Legend object</p> <p>Example: <pre><code>from monet_plots import ScatterPlot\nfrom monet_plots.plot_utils import add_legend\n\nplot = ScatterPlot()\n\n# Plot multiple datasets\nplot.ax.scatter(x1, y1, alpha=0.7, label='Dataset 1')\nplot.ax.scatter(x2, y2, alpha=0.7, label='Dataset 2')\n\n# Add custom legend\nlegend = add_legend(\n    plot.ax,\n    location='upper left',\n    fontsize=10,\n    framealpha=0.8,\n    title='Data Groups'\n)\n\nplot.title(\"Plot with Custom Legend\")\nplot.save('legend_example.png')\n</code></pre></p>"},{"location":"api/plot_utils/#apply_wiley_styleaxnone-style_kwargs","title":"<code>apply_wiley_style(ax=None, **style_kwargs)</code>","text":"<p>Apply Wiley style to axes or entire plot.</p> <pre><code>from monet_plots.plot_utils import apply_wiley_style\n\n# Apply Wiley style to specific axes\napply_wiley_style(plot.ax, fontsize=12)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>ax</code> <code>matplotlib.axes.Axes</code> <code>None</code> Axes to style (None for all) <code>**style_kwargs</code> <code>dict</code> <code>{}</code> Style parameters <p>Returns: - None</p> <p>Example: <pre><code>from monet_plots import SpatialPlot\nfrom monet_plots.plot_utils import apply_wiley_style\n\nplot = SpatialPlot()\n\n# Apply custom Wiley style\napply_wiley_style(\n    plot.ax,\n    fontsize=11,\n    grid_alpha=0.3,\n    linewidth=1.2\n)\n\nplot.plot(data)\nplot.title(\"Custom Styled Plot\")\nplot.save('styled_plot.png')\n</code></pre></p>"},{"location":"api/plot_utils/#helper-classes","title":"Helper Classes","text":""},{"location":"api/plot_utils/#plotconfig","title":"<code>PlotConfig</code>","text":"<p>Configuration class for plot settings.</p> <pre><code>from monet_plots.plot_utils import PlotConfig\n\n# Create plot configuration\nconfig = PlotConfig(\n    figsize=(10, 8),\n    dpi=300,\n    style='wiley',\n    grid=True,\n    legend=True\n)\n\n# Use configuration\nplot = SpatialPlot(**config.figure_kwargs)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>figsize</code> <code>tuple</code> <code>(8, 6)</code> Figure size <code>dpi</code> <code>int</code> <code>100</code> Resolution <code>style</code> <code>str</code> <code>'wiley'</code> Style name <code>grid</code> <code>bool</code> <code>True</code> Show grid <code>legend</code> <code>bool</code> <code>False</code> Show legend <p>Methods: - <code>to_dict()</code>: Convert to dictionary - <code>update(**kwargs)</code>: Update configuration</p>"},{"location":"api/plot_utils/#datavalidator","title":"<code>DataValidator</code>","text":"<p>Data validation utility class.</p> <pre><code>from monet_plots.plot_utils import DataValidator\n\n# Create validator\nvalidator = DataValidator(\n    required_columns=['time', 'value'],\n    data_type='pandas'\n)\n\n# Validate data\ntry:\n    validator.validate(df)\n    print(\"Data is valid for plotting!\")\nexcept ValueError as e:\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"api/plot_utils/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/plot_utils/#custom-plot-pipeline","title":"Custom Plot Pipeline","text":"<pre><code>from monet_plots.plot_utils import (\n    create_figure, add_grid, apply_wiley_style,\n    save_figure, add_legend\n)\n\ndef create_custom_plot(data, title=\"\", filename=\"output.png\"):\n    \"\"\"Create a custom plot with consistent styling.\"\"\"\n\n\n    # Create figure with defaults\n    fig, ax = create_figure(figsize=(10, 6))\n\n\n    # Apply styling\n    apply_wiley_style(ax, fontsize=11)\n\n\n    # Plot data\n    ax.plot(data, linewidth=2, label='Data')\n\n\n    # Add grid and legend\n    add_grid(ax, linestyle='--', alpha=0.3)\n    add_legend(ax, location='upper right')\n\n\n    # Add title\n    ax.set_title(title, fontsize=14, pad=20)\n\n\n    # Save figure\n    save_figure(fig, filename, dpi=300)\n\n\n    return fig, ax\n\n# Usage\ndata = np.random.random(100) + np.arange(100) * 0.1\ncreate_custom_plot(data, title=\"Custom Plot Example\", filename=\"custom_plot.png\")\n</code></pre>"},{"location":"api/plot_utils/#batch-processing-multiple-plots","title":"Batch Processing Multiple Plots","text":"<pre><code>from monet_plots.plot_utils import create_subplot_layout, format_date_axis\nimport matplotlib.pyplot as plt\n\ndef create_batch_plots(data_dict, output_dir=\"plots/\"):\n    \"\"\"Create multiple plots in a batch.\"\"\"\n\n\n    n_plots = len(data_dict)\n    fig, axes = create_subplot_layout(n_plots, max_cols=2, figsize=(14, 10))\n\n\n    for (title, data), ax in zip(data_dict.items(), axes.flat):\n        ax.plot(data, linewidth=2)\n        ax.set_title(title, fontsize=12)\n        ax.grid(True, alpha=0.3)\n\n\n    # Format date axes if applicable\n    for ax in axes.flat:\n        format_date_axis(ax, rotation=45)\n\n\n    plt.tight_layout()\n    save_figure(fig, f\"{output_dir}batch_plots.png\", dpi=300)\n\n# Usage\ndata_dict = {\n    'Temperature': np.random.normal(20, 5, 365),\n    'Humidity': np.random.normal(60, 10, 365),\n    'Pressure': np.random.normal(1013, 10, 365),\n    'Wind Speed': np.random.gamma(2, 3, 365)\n}\n\ncreate_batch_plots(data_dict)\n</code></pre>"},{"location":"api/plot_utils/#performance-tips","title":"Performance Tips","text":"<ol> <li>Reuse figures: Use <code>create_figure()</code> for consistent figure creation</li> <li>Validate data early: Use <code>validate_data()</code> to catch issues early</li> <li>Batch operations: Use <code>create_subplot_layout()</code> for multiple plots</li> <li>Consistent styling: Use <code>apply_wiley_style()</code> for consistent appearance</li> </ol>"},{"location":"api/plot_utils/#error-handling","title":"Error Handling","text":"<p>The module includes comprehensive error handling:</p> <pre><code>try:\n    # Validate data before plotting\n    validate_data(data, required_columns=['time', 'value'])\n\n\n    # Create plot\n    plot = SpatialPlot()\n    plot.plot(data)\n\n\n    # Save with error handling\n    save_figure(plot.fig, 'output.png')\n\n\nexcept ValueError as e:\n    print(f\"Data error: {e}\")\nexcept Exception as e:\n    print(f\"Plotting error: {e}\")\n</code></pre> <p>Related Resources:</p> <ul> <li>Style Configuration - Plot styling and themes</li> <li>Base API - Core plotting functionality</li> <li>Examples - Practical usage examples</li> </ul>"},{"location":"api/style/","title":"Style Module","text":"<p>The <code>monet_plots.style</code> module provides pre-configured styling options for creating publication-quality plots. All styles are designed to be consistent and professional.</p>"},{"location":"api/style/#overview","title":"Overview","text":"<p>MONET Plots includes several built-in styles that can be applied to your plots using matplotlib's style system. These styles ensure consistent appearance across different plot types and publications.</p>"},{"location":"api/style/#available-styles","title":"Available Styles","text":""},{"location":"api/style/#wiley_style","title":"<code>wiley_style</code>","text":"<p>The default Wiley-compliant style for scientific publications.</p> <pre><code>from monet_plots import style\n\n# Apply Wiley style\nimport matplotlib.pyplot as plt\nplt.style.use(style.wiley_style)\n</code></pre> <p>Style Configuration:</p> <pre><code>wiley_style = {\n    # Font settings\n    'font.family': 'serif',\n    'font.serif': 'Times New Roman',\n    'font.size': 10,\n\n    # Axes settings\n    'axes.labelsize': 10,\n    'axes.titlesize': 12,\n    'axes.grid': True,\n    'grid.linestyle': ':',\n    'grid.color': 'gray',\n\n    # Line settings\n    'lines.linewidth': 1.5,\n    'lines.markersize': 5,\n\n    # Legend settings\n    'legend.fontsize': 9,\n    'legend.frameon': False,\n\n    # Figure settings\n    'figure.figsize': (6, 4),\n    'figure.dpi': 300,\n    'savefig.dpi': 300,\n    'savefig.format': 'tiff',\n    'savefig.bbox': 'tight',\n}\n</code></pre>"},{"location":"api/style/#aps_style","title":"<code>aps_style</code>","text":"<p>American Physical Society (APS) compliant style for physics journals.</p> <pre><code>import matplotlib.pyplot as plt\nplt.style.use(style.aps_style)\n</code></pre> <p>Style Configuration:</p> <pre><code>aps_style = {\n    # Font settings - APS uses Helvetica\n    'font.family': 'sans-serif',\n    'font.sans-serif': ['Helvetica', 'Arial', 'DejaVu Sans'],\n    'font.size': 10,\n\n    # Axes settings\n    'axes.labelsize': 10,\n    'axes.titlesize': 12,\n    'axes.grid': False,\n\n    # Line settings\n    'lines.linewidth': 1.5,\n    'lines.markersize': 6,\n\n    # Legend settings\n    'legend.fontsize': 9,\n    'legend.framealpha': 0.8,\n\n    # Figure settings\n    'figure.figsize': (5, 4),\n    'figure.dpi': 600,\n    'savefig.dpi': 600,\n    'savefig.format': 'pdf',\n}\n</code></pre>"},{"location":"api/style/#nature_style","title":"<code>nature_style</code>","text":"<p>Nature journal compliant style.</p> <pre><code>import matplotlib.pyplot as plt\nplt.style.use(style.nature_style)\n</code></pre>"},{"location":"api/style/#science_style","title":"<code>science_style</code>","text":"<p>Science journal compliant style.</p> <pre><code>import matplotlib.pyplot as plt\nplt.style.use(style.science_style)\n</code></pre>"},{"location":"api/style/#custom-style-creation","title":"Custom Style Creation","text":""},{"location":"api/style/#custom_stylekwargs","title":"<code>custom_style(**kwargs)</code>","text":"<p>Create a custom style by modifying an existing style or creating a new one.</p> <pre><code>from monet_plots import style\n\n# Create custom style from Wiley style\ncustom = style.custom_style(\n    font_size=12,\n    figure_size=(10, 8),\n    grid_style='--',\n    grid_alpha=0.3\n)\n\nimport matplotlib.pyplot as plt\nplt.style.use(custom)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>base_style</code> <code>str</code> Base style to modify ('wiley', 'aps', 'nature', 'science') <code>font_size</code> <code>int</code> Base font size <code>figure_size</code> <code>tuple</code> Default figure size (width, height) <code>font_family</code> <code>str</code> Font family ('serif', 'sans-serif', etc.) <code>grid_style</code> <code>str</code> Grid line style ('-', '--', ':', etc.) <code>grid_alpha</code> <code>float</code> Grid transparency (0-1) <code>save_format</code> <code>str</code> Default save format ('png', 'pdf', 'tiff', etc.) <code>dpi</code> <code>int</code> Default DPI for saving <code>**kwargs</code> <code>dict</code> Additional style parameters"},{"location":"api/style/#example-creating-custom-styles","title":"Example: Creating Custom Styles","text":"<pre><code>from monet_plots import style\n\n# Modify existing style\npresentation_style = style.custom_style(\n    base_style='wiley',\n    font_size=14,\n    figure_size=(12, 8),\n    grid_alpha=0.5\n)\n\n# Create completely new style\ndark_style = style.custom_style(\n    font_family='sans-serif',\n    figure.facecolor='#1a1a1a',\n    axes.facecolor='#1a1a1a',\n    text.color='white',\n    axes.edgecolor='white',\n    axes.labelcolor='white',\n    xtick.color='white',\n    ytick.color='white',\n    grid_color='#666666'\n)\n</code></pre>"},{"location":"api/style/#style-application","title":"Style Application","text":""},{"location":"api/style/#global-style-application","title":"Global Style Application","text":"<pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import style\n\n# Apply style globally\nplt.style.use(style.wiley_style)\n\n# All subsequent plots will use this style\nplot1 = SpatialPlot()\nplot2 = TimeSeriesPlot()\n</code></pre>"},{"location":"api/style/#context-manager-for-temporary-style","title":"Context Manager for Temporary Style","text":"<pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import style\n\n# Use style temporarily\nwith plt.style.context(style.aps_style):\n    plot = SpatialPlot()\n    plot.plot(data)\n    plot.save('aps_style.png')\n\n# Style is automatically reverted\n</code></pre>"},{"location":"api/style/#per-plot-style-application","title":"Per-Plot Style Application","text":"<pre><code>from monet_plots import SpatialPlot, style\n\n# Create plot with custom style\nplot = SpatialPlot()\nplot.plot(data)\nplt.style.use(style.nature_style)  # Affects only this plot\nplot.save('nature_style.png')\n</code></pre>"},{"location":"api/style/#style-parameters-reference","title":"Style Parameters Reference","text":""},{"location":"api/style/#font-settings","title":"Font Settings","text":"Parameter Default Description <code>font.family</code> 'serif' Font family <code>font.serif</code> 'Times New Roman' Serif font family <code>font.sans-serif</code> ['Arial', 'Helvetica'] Sans-serif font options <code>font.monospace</code> ['Courier New'] Monospace font options <code>font.size</code> 10 Base font size in points <code>axes.labelsize</code> 10 Axis label font size <code>axes.titlesize</code> 12 Axis title font size <code>legend.fontsize</code> 9 Legend font size <code>xtick.labelsize</code> 9 X-axis tick label size <code>ytick.labelsize</code> 9 Y-axis tick label size"},{"location":"api/style/#axes-settings","title":"Axes Settings","text":"Parameter Default Description <code>axes.grid</code> True Whether to show grid <code>grid.linestyle</code> ':' Grid line style <code>grid.color</code> 'gray' Grid line color <code>grid.alpha</code> 0.5 Grid transparency <code>axes.facecolor</code> 'white' Axis background color <code>axes.edgecolor</code> 'black' Axis edge color <code>axes.spines.color</code> 'black' Spine color"},{"location":"api/style/#line-and-marker-settings","title":"Line and Marker Settings","text":"Parameter Default Description <code>lines.linewidth</code> 1.5 Default line width <code>lines.markersize</code> 5 Default marker size <code>lines.markeredgewidth</code> 1 Marker edge width"},{"location":"api/style/#figure-settings","title":"Figure Settings","text":"Parameter Default Description <code>figure.figsize</code> (6, 4) Default figure size <code>figure.dpi</code> 100 Display DPI <code>savefig.dpi</code> 300 Save DPI <code>savefig.format</code> 'tiff' Default save format <code>savefig.bbox</code> 'tight' Save bounding box mode"},{"location":"api/style/#legend-settings","title":"Legend Settings","text":"Parameter Default Description <code>legend.frameon</code> False Whether to show legend frame <code>legend.framealpha</code> 1.0 Frame transparency <code>legend.fancybox</code> False Rounded legend frame <code>legend.shadow</code> False Legend shadow"},{"location":"api/style/#style-best-practices","title":"Style Best Practices","text":""},{"location":"api/style/#choosing-the-right-style","title":"Choosing the Right Style","text":"<ol> <li>Publications: Use journal-specific styles when available</li> <li>Presentations: Increase font sizes and figure dimensions</li> <li>Web: Use high-contrast styles for better readability</li> <li>Data Exploration: Use minimal grid and clear labels</li> </ol>"},{"location":"api/style/#customization-guidelines","title":"Customization Guidelines","text":"<pre><code># Good: Modify existing style incrementally\ncustom_wiley = style.custom_style(\n    base_style='wiley',\n    font_size=11,  # Slight modification\n    grid_alpha=0.3  # Subtle grid\n)\n\n# Avoid: Completely overriding styles\nbad_style = {\n    'font.size': 12,  # Missing many other parameters\n    'figure.figsize': (8, 6)\n}\n</code></pre>"},{"location":"api/style/#consistency-across-plots","title":"Consistency Across Plots","text":"<pre><code># Set style at the beginning of your script\nimport matplotlib.pyplot as plt\nfrom monet_plots import style\n\nplt.style.use(style.wiley_style)\n\n# Create all plots with consistent style\nplot1 = SpatialPlot()\nplot2 = TimeSeriesPlot()\nplot3 = ScatterPlot()\n</code></pre>"},{"location":"api/style/#style-troubleshooting","title":"Style Troubleshooting","text":""},{"location":"api/style/#common-issues","title":"Common Issues","text":"<p>Style Not Applied: <pre><code># Wrong: Style applied after plot creation\nplot = SpatialPlot()\nplt.style.use(style.wiley_style)  # Too late!\nplot.plot(data)\n\n# Correct: Apply style before creating plot\nplt.style.use(style.wiley_style)\nplot = SpatialPlot()\nplot.plot(data)\n</code></pre></p> <p>Missing Fonts: <pre><code># Install missing fonts\nimport matplotlib.pyplot as plt\nplt.rcParams['font.family'] = ['Arial', 'Helvetica', 'sans-serif']\n</code></pre></p> <p>Style Conflicts: <pre><code># Reset matplotlib style before applying new one\nplt.style.use('default')  # Reset to defaults\nplt.style.use(style.aps_style)  # Apply new style\n</code></pre></p>"},{"location":"api/style/#style-templates","title":"Style Templates","text":""},{"location":"api/style/#presentation-templates","title":"Presentation Templates","text":"<pre><code># Large format presentation\npresentation_style = style.custom_style(\n    base_style='wiley',\n    font_size=16,\n    figure_size=(14, 10),\n    grid_alpha=0.3\n)\n\n# Small format presentation\nsmall_presentation = style.custom_style(\n    base_style='wiley',\n    font_size=12,\n    figure_size=(8, 6),\n    grid_alpha=0.2\n)\n</code></pre>"},{"location":"api/style/#publication-templates","title":"Publication Templates","text":"<pre><code># Two-column journal\ntwo_column_style = style.custom_style(\n    base_style='wiley',\n    figure_size=(3.5, 2.5),  # Two-column width\n    font_size=9\n)\n\n# Full-page figure\nfull_page_style = style.custom_style(\n    base_style='wiley',\n    figure_size=(7, 9),  # Full page\n    font_size=10\n)\n</code></pre> <p>Related Resources:</p> <ul> <li>Base Plot API - Core plotting functionality</li> <li>Colorbars API - Colorbar customization</li> <li>Examples - Style usage examples</li> </ul>"},{"location":"api/taylordiagram/","title":"Taylor Diagram Module","text":"<p>The <code>monet_plots.taylordiagram</code> module provides functionality for creating Taylor diagrams, which are commonly used in meteorology and climate science to evaluate model performance against observations.</p>"},{"location":"api/taylordiagram/#overview","title":"Overview","text":"<p>Taylor diagrams display the standard deviation and correlation coefficient between model predictions and observations, providing a comprehensive view of model performance in a single plot.</p>"},{"location":"api/taylordiagram/#taylordiagram-class","title":"TaylorDiagram Class","text":"<pre><code>class TaylorDiagram:\n    \"\"\"Create a Taylor diagram for model evaluation.\"\"\"\n\n\n    def __init__(self, obsstd, scale=1.5, fig=None, rect=111, label='OBS', **kwargs):\n        \"\"\"Initialize a Taylor diagram.\n\n\n        Args:\n            obsstd (float): Standard deviation of observations\n            scale (float): Scale factor for the diagram\n            fig (matplotlib.figure.Figure, optional): Figure to use\n            rect (tuple or int): Position and size of subplot\n            label (str): Label for observations\n            **kwargs: Additional parameters\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/taylordiagram/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Default Description <code>obsstd</code> <code>float</code> Required Standard deviation of observations <code>scale</code> <code>float</code> <code>1.5</code> Scale factor for diagram size <code>fig</code> <code>matplotlib.figure.Figure</code> <code>None</code> Existing figure to use <code>rect</code> <code>tuple</code> or <code>int</code> <code>111</code> Subplot position and size <code>label</code> <code>str</code> <code>'OBS'</code> Label for observations <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional parameters"},{"location":"api/taylordiagram/#public-methods","title":"Public Methods","text":""},{"location":"api/taylordiagram/#add_samplestddev-corrcoef-markero-label-kwargs","title":"<code>add_sample(stddev, corrcoef, marker='o', label='', **kwargs)</code>","text":"<p>Add a model sample to the Taylor diagram.</p> <pre><code>td = TaylorDiagram(obsstd=1.0)\ntd.add_sample(stddev=0.8, corrcoef=0.9, marker='s', label='Model 1')\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>stddev</code> <code>float</code> Required Standard deviation of the model <code>corrcoef</code> <code>float</code> Required Correlation coefficient <code>marker</code> <code>str</code> <code>'o'</code> Marker style <code>label</code> <code>str</code> <code>''</code> Model label <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional plot parameters <p>Example: <pre><code>from monet_plots import taylordiagram\n\n# Create Taylor diagram\ntd = taylordiagram.TaylorDiagram(obsstd=1.2, scale=2.0, label='Observations')\n\n# Add model samples\ntd.add_sample(stddev=1.1, corrcoef=0.95, marker='o', label='Model A', color='red')\ntd.add_sample(stddev=1.3, corrcoef=0.88, marker='s', label='Model B', color='blue')\ntd.add_sample(stddev=0.9, corrcoef=0.92, marker='^', label='Model C', color='green')\n\n# Add contours and legend\ntd.add_contours(levels=[0.5, 0.8, 0.9, 0.95])\ntd.finish_plot()\n</code></pre></p>"},{"location":"api/taylordiagram/#add_contourslevelsnone-kwargs","title":"<code>add_contours(levels=None, **kwargs)</code>","text":"<p>Add contour lines to the Taylor diagram.</p> <pre><code>td.add_contours(levels=[0.5, 0.8, 0.9, 0.95], colors='gray', linestyles='--')\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>levels</code> <code>list</code> <code>None</code> Contour levels (correlation coefficients) <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional contour parameters <p>Example: <pre><code># Add custom contours\ntd.add_contours(\n    levels=[0.6, 0.7, 0.8, 0.9, 0.95],\n    colors='gray',\n    linestyles=['-', '--', ':', '-.', (0, (3, 1, 1, 1))],\n    linewidths=1.5,\n    alpha=0.7\n)\n</code></pre></p>"},{"location":"api/taylordiagram/#finish_plot","title":"<code>finish_plot()</code>","text":"<p>Finalize the plot by adding legend and adjusting layout.</p> <pre><code>td.finish_plot()\ntd.save('taylor_diagram.png')\n</code></pre> <p>Parameters: - None</p> <p>Example: <pre><code>td = taylordiagram.TaylorDiagram(obsstd=1.0)\ntd.add_sample(0.8, 0.9, 'o', 'Model 1')\ntd.add_contours([0.5, 0.8, 0.9])\n\n# Finalize and save\ntd.finish_plot()\ntd.fig.savefig('taylor_diagram.png', dpi=300, bbox_inches='tight')\n</code></pre></p>"},{"location":"api/taylordiagram/#set_xlabellabel-kwargs","title":"<code>set_xlabel(label, **kwargs)</code>","text":"<p>Set the x-axis label.</p> <pre><code>td.set_xlabel('Standard Deviation', fontsize=12)\n</code></pre>"},{"location":"api/taylordiagram/#set_ylabellabel-kwargs","title":"<code>set_ylabel(label, **kwargs)</code>","text":"<p>Set the y-axis label.</p> <pre><code>td.set_ylabel('Standard Deviation', fontsize=12)\n</code></pre>"},{"location":"api/taylordiagram/#set_titletitle-kwargs","title":"<code>set_title(title, **kwargs)</code>","text":"<p>Set the plot title.</p> <pre><code>td.set_title('Model Performance Comparison', fontsize=14, pad=20)\n</code></pre>"},{"location":"api/taylordiagram/#properties","title":"Properties","text":""},{"location":"api/taylordiagram/#figure","title":"<code>figure</code>","text":"<p>Access the underlying matplotlib Figure object.</p> <pre><code>@property\ndef figure(self):\n    \"\"\"Get the matplotlib Figure object.\"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/taylordiagram/#axes","title":"<code>axes</code>","text":"<p>Access the matplotlib Axes object.</p> <pre><code>@property\ndef axes(self):\n    \"\"\"Get the matplotlib Axes object.\"\"\"\n    return self._axes\n</code></pre>"},{"location":"api/taylordiagram/#usage-examples","title":"Usage Examples","text":""},{"location":"api/taylordiagram/#basic-taylor-diagram","title":"Basic Taylor Diagram","text":"<pre><code>import numpy as np\nfrom monet_plots import taylordiagram\n\n# Create sample data\nobs_std = 1.2\nmodel_data = [\n    (1.1, 0.95, 'Model A'),\n    (1.3, 0.88, 'Model B'),\n    (0.9, 0.92, 'Model C'),\n    (1.0, 0.97, 'Model D')\n]\n\n# Create Taylor diagram\ntd = taylordiagram.TaylorDiagram(\n    obsstd=obs_std,\n    scale=1.8,\n    label='Observations'\n)\n\n# Add model samples\nfor stddev, corrcoef, label in model_data:\n    td.add_sample(\n        stddev=stddev,\n        corrcoef=corrcoef,\n        marker='o',\n        label=label\n    )\n\n# Add contours and finalize\ntd.add_contours(levels=[0.5, 0.8, 0.9, 0.95])\ntd.finish_plot()\n\n# Save the plot\ntd.save('basic_taylor_diagram.png')\n</code></pre>"},{"location":"api/taylordiagram/#advanced-taylor-diagram-with-custom-styling","title":"Advanced Taylor Diagram with Custom Styling","text":"<pre><code>import numpy as np\nfrom monet_plots import taylordiagram\n\n# Create Taylor diagram with custom styling\ntd = taylordiagram.TaylorDiagram(\n    obsstd=2.5,\n    scale=2.2,\n    label='Reference Observations'\n)\n\n# Add multiple model categories\n# High-performance models\nhigh_perf_models = [\n    (2.4, 0.97, 'Advanced Model', 'red', 'o'),\n    (2.6, 0.95, 'Optimized Model', 'darkred', 's')\n]\n\n# Medium-performance models\nmed_perf_models = [\n    (2.8, 0.88, 'Standard Model', 'blue', '^'),\n    (2.3, 0.85, 'Baseline Model', 'lightblue', 'v')\n]\n\n# Poor-performance models\npoor_perf_models = [\n    (3.2, 0.72, 'Experimental Model', 'orange', 'D'),\n    (3.5, 0.68, 'Prototype Model', 'darkorange', '*')\n]\n\n# Add models with different colors and markers\nfor models, color in [(high_perf_models, 'red'),\n                      (med_perf_models, 'blue'),\nfor models, color in [(high_perf_models, 'red'),\n                      (med_perf_models, 'blue'),\n                      (poor_perf_models, 'orange')]:\n    for stddev, corrcoef, label, c, marker in models:\n        td.add_sample(\n            stddev=stddev,\n            corrcoef=corrcoef,\n            marker=marker,\n            label=label,\n            color=c,\n            markersize=8,\n            zorder=10\n        )\n\n# Add custom contours\ncustom_levels = [0.5, 0.7, 0.8, 0.9, 0.95, 0.98]\ntd.add_contours(\n    levels=custom_levels,\n    colors='gray',\n    linestyles=['-', '--', ':', '-.', (0, (3, 1, 1, 1)), (0, (5, 5))],\n    linewidths=1,\n    alpha=0.6\n)\n\n# Customize plot appearance\ntd.set_title('Comprehensive Model Performance Analysis', fontsize=16, pad=25)\ntd.set_xlabel('Standard Deviation', fontsize=12)\ntd.set_ylabel('Standard Deviation', fontsize=12)\n\n# Add legend and finalize\ntd.finish_plot()\n\n# Save high-resolution plot\ntd.fig.savefig('advanced_taylor_diagram.png', dpi=600, bbox_inches='tight')\n</code></pre>"},{"location":"api/taylordiagram/#integration-with-monet-plots","title":"Integration with MONET Plots","text":"<pre><code>from monet_plots import TaylorDiagramPlot\nimport pandas as pd\n\n# Load model evaluation data\ndata = pd.DataFrame({\n    'model': ['Model A', 'Model B', 'Model C', 'Model D'],\n    'stddev': [1.1, 1.3, 0.9, 1.0],\n    'corrcoef': [0.95, 0.88, 0.92, 0.97],\n    'obs_std': 1.2  # Reference standard deviation\n})\n\n# Create Taylor diagram using MONET Plots\nplot = TaylorDiagramPlot(\n    obsstd=data['obs_std'].iloc[0],\n    scale=1.5,\n    label='Observations'\n)\n\n# Add all models\nfor _, row in data.iterrows():\n    plot.add_sample(\n        df=pd.DataFrame({'obs': [1], 'model': [1]}),  # Dummy data for corrcoef\n        col1='obs',\n        col2='model',\n        marker='o',\n        label=row['model']\n    )\n\n# Update standard deviations manually\nplot.dia.samples[-1].set_stddev(row['stddev'])\nplot.dia.samples[-1].set_corrcoef(row['corrcoef'])\n\n# Add contours and finish\nplot.add_contours([0.5, 0.8, 0.9, 0.95])\nplot.finish_plot()\n\nplot.save('monet_taylor_diagram.png')\n</code></pre>"},{"location":"api/taylordiagram/#advanced-features","title":"Advanced Features","text":""},{"location":"api/taylordiagram/#custom-contour-styling","title":"Custom Contour Styling","text":"<pre><code># Create gradient contour colors\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LinearSegmentedColormap\n\n# Create custom colormap\ncolors = ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026']\nn_bins = 100\ncmap = LinearSegmentedColormap.from_list('custom', colors, N=n_bins)\n\n# Add styled contours\ntd.add_contours(\n    levels=[0.5, 0.7, 0.8, 0.9, 0.95, 0.98],\n    cmap=cmap,\n    linewidths=2,\n    alpha=0.8\n)\n</code></pre>"},{"location":"api/taylordiagram/#interactive-taylor-diagrams","title":"Interactive Taylor Diagrams","text":"<pre><code># Enable interactive features\nimport matplotlib.pyplot as plt\nplt.ion()  # Turn on interactive mode\n\ntd = taylordiagram.TaylorDiagram(obsstd=1.0)\ntd.add_sample(0.8, 0.9, 'o', 'Interactive Model')\n\n# Add click interaction\ndef on_click(event):\n    if event.inaxes == td.axes:\n        # Add model at clicked position\n        x, y = event.xdata, event.ydata\n        r = np.sqrt(x**2 + y**2)\n        if r &gt; 0:\n            corrcoef = y / r\n            td.add_sample(x, corrcoef, 'x', f'Clicked Model {len(td.dia.samples)}')\n            td.fig.canvas.draw()\n\ntd.fig.canvas.mpl_connect('button_press_event', on_click)\n</code></pre>"},{"location":"api/taylordiagram/#data-requirements","title":"Data Requirements","text":""},{"location":"api/taylordiagram/#input-data-format","title":"Input Data Format","text":"<p>Taylor diagrams require two key metrics for each model:</p> <ol> <li>Standard Deviation: The RMS difference between model and observations</li> <li>Correlation Coefficient: The temporal correlation between model and observations</li> </ol>"},{"location":"api/taylordiagram/#calculation-example","title":"Calculation Example","text":"<pre><code>import numpy as np\nfrom scipy import stats\n\ndef calculate_taylor_metrics(obs, model):\n    \"\"\"Calculate standard deviation and correlation for Taylor diagram.\n\n\n    Args:\n        obs (array-like): Observation data\n        model (array-like): Model data\n\n\n    Returns:\n        tuple: (stddev, corrcoef)\n    \"\"\"\n    # Calculate standard deviations\n    obs_std = np.std(obs, ddof=1)\n    model_std = np.std(model, ddof=1)\n\n\n    # Calculate correlation coefficient\n    corrcoef, _ = stats.pearsonr(obs, model)\n\n\n    return model_std, corrcoef\n\n# Example usage\nobs_data = np.random.normal(0, 1, 1000)\nmodel_data = np.random.normal(0.1, 1.1, 1000)\n\nstddev, corrcoef = calculate_taylor_metrics(obs_data, model_data)\nprint(f\"Standard Deviation: {stddev:.3f}\")\nprint(f\"Correlation Coefficient: {corrcoef:.3f}\")\n</code></pre>"},{"location":"api/taylordiagram/#best-practices","title":"Best Practices","text":""},{"location":"api/taylordiagram/#model-selection","title":"Model Selection","text":"<ol> <li>Include reference: Always include observations as the reference point</li> <li>Compare like-for-like: Ensure models are evaluated on the same dataset</li> <li>Statistical significance: Only include statistically significant correlations</li> </ol>"},{"location":"api/taylordiagram/#visual-design","title":"Visual Design","text":"<ol> <li>Color coding: Use colors to indicate model categories or performance levels</li> <li>Marker variety: Use different markers for different model types</li> <li>Clear labeling: Ensure all models are clearly labeled</li> <li>Contour levels: Choose appropriate contour levels based on your data range</li> </ol>"},{"location":"api/taylordiagram/#interpretation","title":"Interpretation","text":"<ol> <li>Center point: Models closer to the observation point are better</li> <li>Distance from center: Radial distance indicates overall skill</li> <li>Correlation: Higher correlation values are better</li> <li>Standard deviation: Values close to observation standard deviation are better</li> </ol>"},{"location":"api/taylordiagram/#common-use-cases","title":"Common Use Cases","text":""},{"location":"api/taylordiagram/#climate-model-evaluation","title":"Climate Model Evaluation","text":"<pre><code># Compare multiple climate models\nclimate_models = {\n    'GCM Model A': (1.05, 0.96),\n    'GCM Model B': (1.15, 0.92),\n    'GCM Model C': (0.95, 0.94),\n    'Regional Model': (1.25, 0.88),\n    'Statistical Model': (0.85, 0.91)\n}\n\ntd = taylordiagram.TaylorDiagram(obsstd=1.0, label='Reanalysis')\nfor name, (std, corr) in climate_models.items():\n    td.add_sample(std, corr, 'o', name)\n\ntd.add_contours([0.5, 0.8, 0.9, 0.95])\ntd.finish_plot()\n</code></pre>"},{"location":"api/taylordiagram/#weather-forecast-verification","title":"Weather Forecast Verification","text":"<pre><code># Compare different forecast lead times\nforecast_models = {\n    '24h Forecast': (0.8, 0.98),\n    '48h Forecast': (1.0, 0.94),\n    '72h Forecast': (1.2, 0.88),\n    '96h Forecast': (1.4, 0.82),\n    '120h Forecast': (1.6, 0.75)\n}\n\ntd = taylordiagram.TaylorDiagram(obsstd=1.0, label='Observations')\nfor name, (std, corr) in forecast_models.items():\n    td.add_sample(std, corr, 's', name)\n\ntd.add_contours([0.5, 0.8, 0.9, 0.95])\ntd.finish_plot()\n</code></pre> <p>Related Resources:</p> <ul> <li>Plot Types API - Other plot implementations</li> <li>Examples - Practical usage examples</li> <li>Base API - Core plotting functionality</li> </ul>"},{"location":"architecture/verification_plots/","title":"Verification Plots Architecture","text":"<p>This document outlines the high-level architecture, design principles, module responsibilities, and extensibility patterns for the verification plots system.</p>"},{"location":"architecture/verification_plots/#1-system-overview-and-design-principles","title":"1. System Overview and Design Principles","text":"<p>The verification plots system is built upon a clear Separation of Concerns principle, dividing responsibilities between statistical computation and visualization.</p> <p>Design Principles:</p> <ul> <li>Consistency: All plots inherit from <code>BasePlot</code> to enforce consistent styling (via <code>wiley_style</code>) and standard figure lifecycle management (<code>__init__</code>, <code>save</code>, <code>close</code>).</li> <li>Decoupling: Statistical calculation logic is entirely decoupled from visualization logic, residing in the utility module <code>verification_metrics.py</code>.</li> <li>Object-Oriented Visualization: Each specific plot type is realized as its own class, inheriting from <code>BasePlot</code>. This encapsulates the data processing and rendering specific to that plot type within a single object.</li> </ul>"},{"location":"architecture/verification_plots/#2-class-hierarchy-diagram","title":"2. Class Hierarchy Diagram","text":"<p>All verification plots extend the abstract base class <code>BasePlot</code>, providing standardized figure handling.</p> <pre><code>classDiagram\n    direction LR\n    class BasePlot {\n        +__init__(fig, ax, **kwargs)\n        +save(filename, **kwargs)\n        +close()\n    }\n    class BrierScoreDecompositionPlot\n    class ConditionalBiasPlot\n    class FacetGridPlot\n    class KDEPlot\n    class PerformanceDiagramPlot\n    class RankHistogramPlot\n    class ReliabilityDiagramPlot\n    class RelativeEconomicValuePlot\n    class ROCCurvePlot\n    class ScatterPlot\n    class ScorecardPlot\n    class SpatialBiasScatterPlot\n    class SpatialContourPlot\n    class SpatialPlot\n    class TaylorDiagramPlot\n    class TimeSeriesPlot\n    class WindBarbsPlot\n    class WindQuiverPlot\n    class XarraySpatialPlot\n\n    BasePlot &lt;|-- BrierScoreDecompositionPlot\n    BasePlot &lt;|-- ConditionalBiasPlot\n    BasePlot &lt;|-- FacetGridPlot\n    BasePlot &lt;|-- KDEPlot\n    BasePlot &lt;|-- PerformanceDiagramPlot\n    BasePlot &lt;|-- RankHistogramPlot\n    BasePlot &lt;|-- ReliabilityDiagramPlot\n    BasePlot &lt;|-- RelativeEconomicValuePlot\n    BasePlot &lt;|-- ROCCurvePlot\n    BasePlot &lt;|-- ScatterPlot\n    BasePlot &lt;|-- ScorecardPlot\n    BasePlot &lt;|-- SpatialBiasScatterPlot\n    BasePlot &lt;|-- SpatialContourPlot\n    BasePlot &lt;|-- SpatialPlot\n    BasePlot &lt;|-- TaylorDiagramPlot\n    BasePlot &lt;|-- TimeSeriesPlot\n    BasePlot &lt;|-- WindBarbsPlot\n    BasePlot &lt;|-- WindQuiverPlot\n    BasePlot &lt;|-- XarraySpatialPlot\n</code></pre>"},{"location":"architecture/verification_plots/#3-data-flow-diagram","title":"3. Data Flow Diagram","text":"<p>This diagram illustrates the general flow for verification plot generation, assuming input data is pre-loaded into a structure like a Pandas DataFrame.</p> <pre><code>flowchart TD\n    A[Input Data (DataFrame/xarray)] --&gt; B{Concrete Plot Class};\n    B -- Initial Setup/Style --&gt; BasePlot;\n    B -- Prepares Data --&gt; C[Plot Specific Logic];\n    C -- Calls Statistical Functions --&gt; D{Metrics Computation};\n    D -- Returns Computed Metrics --&gt; C;\n    C -- Renders Plot --&gt; E[Matplotlib Figure/Axes];\n    E --&gt; F(Output File/Display);\n\n    subgraph Metrics Computation\n        D\n    end\n\n    subgraph Visualization Layer\n        B\n        C\n        E\n    end\n\n    style D fill:#ccf,stroke:#333,stroke-width:2px\n    style B fill:#f9f,stroke:#333,stroke-width:2px\n</code></pre>"},{"location":"architecture/verification_plots/#4-module-boundaries-and-responsibilities","title":"4. Module Boundaries and Responsibilities","text":"Module Responsibility <code>src/monet_plots/plots/base.py</code> Foundation: Defines <code>BasePlot</code>. Enforces standard figure management and styling. Plot-Specific Classes (e.g., <code>roc_curve.py</code>) Visualization: Inherit from <code>BasePlot</code>. Handle plot-specific data wrangling (e.g., binning, feature selection) and Matplotlib rendering using the <code>plot()</code> method. <code>src/monet_plots/verification_metrics.py</code> Computation: Contains pure, stateless mathematical functions (e.g., <code>compute_pod</code>, <code>compute_brier_score_components</code>). This module only depends on <code>numpy</code> and <code>pandas</code>, not Matplotlib."},{"location":"architecture/verification_plots/#5-integration-points-with-verification_metricspy","title":"5. Integration Points with <code>verification_metrics.py</code>","text":"<p>The integration point is strictly from the concrete plot classes back to the stateless functions in <code>verification_metrics.py</code>.</p> <ul> <li>Data Preparation: Plot classes ingest raw or pre-processed data (often in a Pandas DataFrame).</li> <li>Metric Calculation: Within the plot's primary rendering method (usually <code>plot()</code> or a helper), relevant data columns are passed as arguments to the functions in <code>verification_metrics.py</code> (e.g., passing <code>forecasts</code> and <code>observations</code> to <code>compute_reliability_curve</code>).</li> <li>Rendering: The results from the metrics module (e.g., reliability statistics, CSI values) are then used by the plot class's rendering logic to draw the visual elements on the Matplotlib axes (<code>self.ax</code>).</li> </ul>"},{"location":"architecture/verification_plots/#6-extensibility-patterns-for-future-plots","title":"6. Extensibility Patterns for Future Plots","text":"<p>The system is designed for easy extension:</p> <ol> <li>Inheritance: Create a new class that inherits directly from <code>BasePlot</code>.</li> <li>Method Overriding: Implement the core rendering logic within a new <code>plot(...)</code> method in the new class. This method is responsible for calling utility functions from <code>verification_metrics.py</code> as needed.</li> <li>Figure Management: The boilerplate for figure creation, style application, and saving/closing is automatically inherited from <code>BasePlot</code>, minimizing boilerplate code.</li> <li>Dependency Management: New plot classes should avoid introducing new, unmanaged external dependencies unless absolutely necessary. If new statistical methods are needed, they should be added as new functions to <code>verification_metrics.py</code> first to maintain the computational/visualization split.</li> </ol>"},{"location":"configuration/","title":"Configuration and Customization Guide","text":"<p>Welcome to the MONET Plots configuration guide! This comprehensive resource will help you customize plots, create custom styles, and configure advanced settings to match your specific needs and publication requirements.</p>"},{"location":"configuration/#overview","title":"Overview","text":"<p>MONET Plots provides extensive customization options while maintaining default professional styling. This guide covers:</p> <ul> <li>Style Configuration - Creating custom visual styles</li> <li>Plot Customization - Modifying individual plot elements</li> <li>Advanced Settings - Fine-tuning plot behavior</li> <li>Theming - Creating consistent branded styles</li> </ul> Configuration Level Difficulty Use Case Basic Styling Beginner Quick appearance changes Custom Styles Intermediate Project-specific themes Advanced Customization Advanced Full control over plots Performance Tuning Intermediate Optimization settings"},{"location":"configuration/#getting-started","title":"Getting Started","text":""},{"location":"configuration/#quick-customization","title":"Quick Customization","text":"<pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import style, TimeSeriesPlot\n\n# Apply a custom style\nplt.style.use(style.wiley_style)\n\n# Quick customization of a plot\nplot = TimeSeriesPlot(figsize=(12, 6))\nplot.plot(data, title=\"Custom Styled Plot\")\nplot.save(\"custom_plot.png\")\n</code></pre>"},{"location":"configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>MONET Plots follows a configuration hierarchy:</p> <ol> <li>Global defaults - Library-wide settings</li> <li>Style overrides - Custom style dictionaries</li> <li>Plot-specific - Individual plot customizations</li> <li>Runtime parameters - Temporary modifications</li> </ol>"},{"location":"configuration/#navigation","title":"Navigation","text":"<ul> <li>Basic Styling - Quick appearance changes</li> <li>Custom Styles - Creating custom themes</li> <li>Advanced Customization - Full plot control</li> <li>Performance Tuning - Optimization settings</li> <li>Theming Guide - Consistent branding</li> <li>Color Management - Color schemes and palettes</li> </ul>"},{"location":"configuration/basic-styling/","title":"Basic Styling Guide","text":"<p>Learn how to quickly customize the appearance of your plots using MONET Plots' built-in styling system and basic customization options.</p>"},{"location":"configuration/basic-styling/#overview","title":"Overview","text":"<p>This guide covers fundamental styling techniques to make your plots look professional and consistent. We'll explore the default styles, quick customizations, and basic plot modifications.</p>"},{"location":"configuration/basic-styling/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Apply built-in style presets</li> <li>Modify basic plot elements</li> <li>Change colors and fonts</li> <li>Adjust plot dimensions and layout</li> <li>Create simple custom styles</li> </ul>"},{"location":"configuration/basic-styling/#built-in-style-presets","title":"Built-in Style Presets","text":"<p>MONET Plots comes with professionally designed style presets that follow publication standards.</p>"},{"location":"configuration/basic-styling/#wiley-style","title":"Wiley Style","text":"<p>The default Wiley-compliant style provides a clean, professional appearance suitable for scientific publications.</p> <pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import style, TimeSeriesPlot\n\n# Apply Wiley style (default)\nstyle.set_style(\"wiley\")\n\n# Create a plot\nplot = TimeSeriesPlot(figsize=(12, 6))\nplot.plot(df, x='time', y='value', title=\"Wiley Style Plot\")\nplot.save(\"wiley_style.png\")\n</code></pre> <p>Wiley Style Characteristics: - Font: Times New Roman serif font - Size: 10pt for body text, 12pt for titles - Grid: Light gray dotted lines - Lines: 1.5pt width - Colors: Professional color palette - Save Format: TIFF by default, 300 DPI</p>"},{"location":"configuration/basic-styling/#aps-style","title":"APS Style","text":"<p>For American Physical Society publications, use the <code>paper</code> style context:</p> <pre><code>from monet_plots import style\nstyle.set_style(\"paper\")\n</code></pre>"},{"location":"configuration/basic-styling/#nature-style","title":"Nature Style","text":"<p>For Nature journal publications, use the <code>paper</code> style context (or customize further if needed):</p> <pre><code>from monet_plots import style\nstyle.set_style(\"paper\")\n# Further customizations can be applied after setting the base style\n# plt.rcParams.update({'font.size': 7, 'figure.figsize': (3.5, 2)})\n</code></pre>"},{"location":"configuration/basic-styling/#quick-customizations","title":"Quick Customizations","text":""},{"location":"configuration/basic-styling/#changing-colors","title":"Changing Colors","text":"<pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import TimeSeriesPlot\n\n# Use a custom color palette\ncustom_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']\n\n# Apply custom style\nplt.style.use({\n    'axes.prop_cycle': plt.cycler('color', custom_colors),\n    'axes.labelsize': 12,\n    'axes.titlesize': 14,\n    'legend.fontsize': 11\n})\n\nplot = TimeSeriesPlot()\nplot.plot(df, x='time', y='value', color=custom_colors[0])\nplot.save(\"custom_colors.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#font-customization","title":"Font Customization","text":"<pre><code># Custom font configuration\nfont_style = {\n    'font.family': 'serif',\n    'font.serif': ['Georgia', 'Times New Roman', 'serif'],\n    'font.size': 11,\n    'axes.labelsize': 11,\n    'axes.titlesize': 14,\n    'legend.fontsize': 10,\n    'xtick.labelsize': 9,\n    'ytick.labelsize': 9\n}\n\nplt.style.use(font_style)\n</code></pre>"},{"location":"configuration/basic-styling/#size-and-layout","title":"Size and Layout","text":"<pre><code># Figure size and layout customization\nlayout_style = {\n    'figure.figsize': (14, 10),  # Large figure\n    'figure.dpi': 150,           # Lower DPI for web\n    'figure.autolayout': True,   # Automatic layout\n    'axes.titlesize': 16,        # Larger titles\n    'axes.labelsize': 14,        # Larger labels\n    'savefig.dpi': 300,          # High quality saves\n    'savefig.bbox': 'tight'      # Tight bounding box\n}\n\nplt.style.use(layout_style)\n</code></pre>"},{"location":"configuration/basic-styling/#basic-plot-customization","title":"Basic Plot Customization","text":""},{"location":"configuration/basic-styling/#title-and-labels","title":"Title and Labels","text":"<pre><code>from monet_plots import SpatialPlot\n\nplot = SpatialPlot(figsize=(12, 8))\n\n# Plot data\nplot.plot(data, title=\"Custom Title with Subtitle\")\n\n# Add custom labels\nplot.xlabel(\"Longitude (degrees)\")\nplot.ylabel(\"Latitude (degrees)\")\n\n# Add subtitle\nplot.ax.text(0.5, 0.95, \"Regional Analysis\",\n            transform=plot.ax.transAxes,\n            ha='center', fontsize=11, style='italic')\n\nplot.save(\"custom_labels.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#grid-and-ticks","title":"Grid and Ticks","text":"<pre><code>from monet_plots import TimeSeriesPlot\n\nplot = TimeSeriesPlot(figsize=(12, 6))\n\n# Plot data\nplot.plot(df, x='time', y='value')\n\n# Customize grid\nplot.ax.grid(True, linestyle='--', alpha=0.7, color='gray')\n\n# Customize ticks\nplot.ax.tick_params(axis='both', which='major', labelsize=10, length=6, width=1.5)\nplot.ax.tick_params(axis='both', which='minor', length=3, width=1)\n\n# Add minor grid\nplot.ax.grid(True, axis='both', which='minor', linestyle=':', alpha=0.3)\n\nplot.save(\"custom_grid.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#legend-customization","title":"Legend Customization","text":"<pre><code>from monet_plots import TimeSeriesPlot\n\nplot = TimeSeriesPlot(figsize=(12, 6))\n\n# Plot with custom legend\nplot.plot(\n    df,\n    x='time',\n    y='value',\n    title=\"Custom Legend Example\",\n    label=\"Main Dataset\"\n)\n\n# Customize legend\nlegend = plot.ax.legend(\n    loc='upper right',\n    frameon=True,\n    fancybox=True,\n    shadow=True,\n    framealpha=0.9,\n    fontsize=10,\n    markerscale=1.2,\n    edgecolor='black',\n    facecolor='white'\n)\n\n# Add legend title\nlegend.set_title(\"Data Sources\", prop={'size': 11, 'weight': 'bold'})\n\nplot.save(\"custom_legend.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#color-schemes","title":"Color Schemes","text":""},{"location":"configuration/basic-styling/#sequential-color-schemes","title":"Sequential Color Schemes","text":"<pre><code>from monet_plots import SpatialPlot\n\n# Use sequential colormap for continuous data\nplot = SpatialPlot(figsize=(12, 8))\n\n# Sequential data\nsequential_data = np.random.random((20, 30)) * 100\n\nplot.plot(\n    sequential_data,\n    cmap='viridis',  # Sequential colormap\n    title=\"Sequential Color Scheme\"\n)\n\nplot.save(\"sequential_colors.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#diverging-color-schemes","title":"Diverging Color Schemes","text":"<pre><code>from monet_plots import SpatialPlot\n\n# Use diverging colormap for data with center point\nplot = SpatialPlot(figsize=(12, 8))\n\n# Diverging data (positive and negative values)\ndiverging_data = np.random.normal(0, 50, (20, 30))\n\nplot.plot(\n    diverging_data,\n    cmap='RdBu_r',  # Red-Blue diverging\n    title=\"Diverging Color Scheme\"\n)\n\nplot.save(\"diverging_colors.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#qualitative-color-schemes","title":"Qualitative Color Schemes","text":"<pre><code>from monet_plots import ScatterPlot\n\n# Use qualitative colormap for categorical data\nplot = ScatterPlot(figsize=(12, 8))\n\n# Create categorical data\ncategories = ['A', 'B', 'C', 'D', 'E']\ncolors = plt.cm.Set3(np.linspace(0, 1, len(categories)))\n\nfor i, (category, color) in enumerate(zip(categories, colors)):\n    subset = df[df['category'] == category]\n    plot.ax.scatter(subset['x'], subset['y'],\n                   color=color, label=category, s=50, alpha=0.7)\n\nplot.ax.legend(title=\"Categories\")\nplot.title(\"Qualitative Color Scheme\")\nplot.save(\"qualitative_colors.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#colorblind-friendly-practices","title":"Colorblind-Friendly Practices","text":"<p>Ensuring your plots are accessible to individuals with color vision deficiencies is crucial for effective communication. MONET Plots encourages the use of colorblind-friendly palettes and practices.</p>"},{"location":"configuration/basic-styling/#recommended-colormaps","title":"Recommended Colormaps","text":"<p>Matplotlib offers several perceptually uniform colormaps that are suitable for colorblind individuals.</p> <p>For Sequential Data (ordered data, e.g., temperature, elevation):</p> <ul> <li><code>viridis</code></li> <li><code>plasma</code></li> <li><code>inferno</code></li> <li><code>magma</code></li> <li><code>cividis</code></li> </ul> <p>Example (Sequential):</p> <pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import SpatialPlot\nimport numpy as np\n\nplot = SpatialPlot(figsize=(12, 8))\ndata = np.random.random((20, 30)) * 100\n\nplot.plot(\n    data,\n    cmap='viridis',  # Colorblind-friendly sequential colormap\n    title=\"Sequential Data with Viridis Colormap\"\n)\nplot.save(\"colorblind_sequential.png\")\n</code></pre> <p>For Diverging Data (data with a critical central value, e.g., anomalies, differences):</p> <ul> <li><code>BrBG</code> (Brown-BlueGreen)</li> <li><code>PiYG</code> (Pink-YellowGreen)</li> <li><code>PRGn</code> (Purple-Green)</li> <li><code>PuOr</code> (Purple-Orange)</li> <li><code>RdGy</code> (Red-Gray)</li> <li><code>RdBu</code> (Red-Blue)</li> </ul> <p>(Note: Adding <code>_r</code> to the end of a colormap name reverses it, e.g., <code>RdBu_r</code>)</p> <p>Example (Diverging):</p> <pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import SpatialPlot\nimport numpy as np\n\nplot = SpatialPlot(figsize=(12, 8))\ndiverging_data = np.random.normal(0, 50, (20, 30))\n\nplot.plot(\n    diverging_data,\n    cmap='RdBu_r',  # Colorblind-friendly diverging colormap\n    title=\"Diverging Data with RdBu_r Colormap\"\n)\nplot.save(\"colorblind_diverging.png\")\n</code></pre> <p>For Qualitative/Categorical Data (distinct categories, no inherent order):</p> <p>When plotting categorical data, avoid using too many distinct colors that might be hard to differentiate. Consider using:</p> <ul> <li>Colorblind-friendly palettes: Matplotlib's <code>tab10</code>, <code>tab20</code>, <code>Paired</code> are often good starting points.</li> <li>Varying line styles or markers: In addition to color, use different line styles (e.g., solid, dashed, dotted) or marker shapes (e.g., circles, squares, triangles) to distinguish categories.</li> <li>Direct labeling: Label categories directly on the plot rather than relying solely on a legend.</li> </ul> <p>Example (Qualitative):</p> <pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import ScatterPlot\nimport pandas as pd\nimport numpy as np\n\nplot = ScatterPlot(figsize=(12, 8))\n\n# Create categorical data\ncategories = ['Group A', 'Group B', 'Group C', 'Group D']\ndata = {\n    'x': np.random.rand(100) * 10,\n    'y': np.random.rand(100) * 10,\n    'category': np.random.choice(categories, 100)\n}\ndf = pd.DataFrame(data)\n\n# Use a colorblind-friendly qualitative palette (tab10)\ncolors = plt.cm.get_cmap('tab10', len(categories))\n\nfor i, category in enumerate(categories):\n    subset = df[df['category'] == category]\n    plot.ax.scatter(subset['x'], subset['y'],\n                   color=colors(i), label=category, s=50, alpha=0.7)\n\nplot.ax.legend(title=\"Categories\")\nplot.title(\"Qualitative Data with Colorblind-Friendly Palette\")\nplot.save(\"colorblind_qualitative.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#general-best-practices","title":"General Best Practices","text":"<ul> <li>Avoid red-green combinations: These are particularly problematic for the most common forms of colorblindness (deuteranomaly and protanomaly).</li> <li>Use sufficient contrast: Ensure there is enough contrast between colors and between colors and the background.</li> <li>Provide redundant coding: Whenever possible, use other visual cues in addition to color, such as different line styles, marker shapes, patterns, or direct labels.</li> <li>Test your plots: Use online simulators or tools (e.g., Color Oracle) to check how your plots appear to individuals with different types of colorblindness.</li> </ul>"},{"location":"configuration/basic-styling/#quick-style-templates","title":"Quick Style Templates","text":"<p>MONET Plots provides convenient <code>set_style</code> contexts for common use cases:</p>"},{"location":"configuration/basic-styling/#presentation-style","title":"Presentation Style","text":"<p>Apply a style optimized for presentations:</p> <pre><code>from monet_plots import style\nstyle.set_style(\"presentation\")\n</code></pre>"},{"location":"configuration/basic-styling/#paper-publication-style","title":"Paper Publication Style","text":"<p>Apply a style suitable for academic papers:</p> <pre><code>from monet_plots import style\nstyle.set_style(\"paper\")\n</code></pre>"},{"location":"configuration/basic-styling/#web-publication-style","title":"Web Publication Style","text":"<p>Apply a style designed for web content:</p> <pre><code>from monet_plots import style\nstyle.set_style(\"web\")\n</code></pre>"},{"location":"configuration/basic-styling/#common-styling-patterns","title":"Common Styling Patterns","text":""},{"location":"configuration/basic-styling/#pattern-1-quick-style-application","title":"Pattern 1: Quick Style Application","text":"<pre><code># Apply style before creating plot\nplt.style.use('seaborn-v0_8-whitegrid')\n\nplot = TimeSeriesPlot()\nplot.plot(df, x='time', y='value')\nplot.save(\"quick_style.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#pattern-2-style-context-manager","title":"Pattern 2: Style Context Manager","text":"<pre><code># Apply style temporarily\nwith plt.style.context('seaborn-v0_8-darkgrid'):\n    plot = TimeSeriesPlot()\n    plot.plot(df, x='time', y='value')\n    plot.save(\"temp_style.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#pattern-3-style-combination","title":"Pattern 3: Style Combination","text":"<pre><code># Combine multiple styles\nbase_style = plt.style.library['seaborn-v0_8-whitegrid']\ncustom_colors = {'axes.prop_cycle': plt.cycler('color', ['#e74c3c', '#3498db'])}\n\ncombined_style = {**base_style, **custom_colors}\nplt.style.use(combined_style)\n\nplot = TimeSeriesPlot()\nplot.plot(df, x='time', y='value')\nplot.save(\"combined_style.png\")\n</code></pre>"},{"location":"configuration/basic-styling/#practice-exercises","title":"Practice Exercises","text":""},{"location":"configuration/basic-styling/#exercise-1-wiley-style-modification","title":"Exercise 1: Wiley Style Modification","text":"<p>Create a modified Wiley style with larger fonts and a different color scheme.</p>"},{"location":"configuration/basic-styling/#exercise-2-custom-presentation-style","title":"Exercise 2: Custom Presentation Style","text":"<p>Design a style optimized for academic presentations with readable fonts and high contrast.</p>"},{"location":"configuration/basic-styling/#exercise-3-journal-specific-style","title":"Exercise 3: Journal-Specific Style","text":"<p>Create a style for a specific journal of your choice based on their submission guidelines.</p>"},{"location":"configuration/basic-styling/#exercise-4-color-scheme-experimentation","title":"Exercise 4: Color Scheme Experimentation","text":"<p>Test different colormaps (viridis, plasma, inferno, magma) on your data and compare.</p>"},{"location":"configuration/basic-styling/#exercise-5-layout-optimization","title":"Exercise 5: Layout Optimization","text":"<p>Create a style that optimizes plot layout for multi-panel figures.</p>"},{"location":"configuration/basic-styling/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/basic-styling/#issue-1-style-not-applying","title":"Issue 1: Style Not Applying","text":"<pre><code># Reset matplotlib defaults before applying new style\nplt.rcParams.update(plt.rcParamsDefault)\nplt.style.use('your_style')\n</code></pre>"},{"location":"configuration/basic-styling/#issue-2-font-not-available","title":"Issue 2: Font Not Available","text":"<pre><code># Check available fonts\nimport matplotlib.font_manager as fm\nprint([f.name for f in fm.fontManager.ttflist])\n\n# Use fallback fonts\nfont_style = {\n    'font.family': 'serif',\n    'font.serif': ['Georgia', 'Times New Roman', 'serif']  # Fallback chain\n}\n</code></pre>"},{"location":"configuration/basic-styling/#issue-3-poor-text-readability","title":"Issue 3: Poor Text Readability","text":"<pre><code># Improve text readability\nreadable_style = {\n    'font.size': 12,\n    'axes.labelsize': 14,\n    'axes.titlesize': 16,\n    'legend.fontsize': 12,\n    'axes.titlesize': 16,\n    'axes.labelweight': 'bold'\n}\n</code></pre>"},{"location":"configuration/basic-styling/#next-steps","title":"Next Steps","text":"<p>After mastering basic styling, explore:</p> <ol> <li>Custom Styles - Create your own comprehensive style themes</li> <li>Advanced Customization - Fine-tune individual plot elements</li> <li>Color Management - Advanced color palette management</li> <li>Theming Guide - Create consistent branded styles</li> </ol>"},{"location":"configuration/basic-styling/#quick-reference","title":"Quick Reference","text":"Style Element Key Common Values Preset Style <code>style.set_style(context)</code> <code>\"wiley\"</code>, <code>\"presentation\"</code>, <code>\"paper\"</code>, <code>\"web\"</code>, <code>\"default\"</code> Font Family <code>font.family</code> <code>serif</code>, <code>sans-serif</code>, <code>monospace</code> Font Size <code>font.size</code> 8-16pt for most uses Figure Size <code>figure.figsize</code> (8, 6), (12, 8), (10, 6) Save Format <code>savefig.format</code> <code>png</code>, <code>tiff</code>, <code>pdf</code>, <code>eps</code> DPI <code>savefig.dpi</code> 300 for print, 150 for web Grid Style <code>grid.linestyle</code> <code>:</code>, <code>--</code>, <code>-</code>, <code>None</code> <p>Navigation:</p> <ul> <li>Configuration Index - All configuration guides</li> <li>Custom Styles - Advanced style creation</li> <li>Advanced Customization - Full plot control</li> <li>Color Management - Color schemes and palettes</li> </ul>"},{"location":"examples/","title":"Plotting Examples Gallery","text":"<p>Welcome to the MONET Plots gallery! This section provides a visual tour of the various plots you can create, from basic charts to complex meteorological visualizations.</p>"},{"location":"examples/#interactive-examples-gallery","title":"Interactive Examples Gallery","text":"<p>All plotting examples are now available in our comprehensive interactive gallery:</p> <p>\ud83c\udfaf Browse All Examples \u2192</p> <p>The gallery includes: - 44 Complete Examples with source code and output - Interactive Thumbnails for easy browsing - Downloadable Code in both Python and Jupyter formats - Organized Categories including basic plots, verification plots, spatial plots, wind plots, and more</p>"},{"location":"examples/#featured-integrations","title":"Featured Integrations","text":"Integration Description Xarray Integration Learn how to use xarray DataArrays and Datasets directly with MONET Plots for better performance and metadata preservation. View Example Spatial Mapping Explore geospatial plotting capabilities. View Examples Model Verification Statistical plots for model evaluation and verification. View Examples"},{"location":"examples/xarray-integration/","title":"Xarray Integration Guide","text":"<p>MONET Plots now supports direct plotting with xarray DataArrays and Datasets, providing better performance and integration with labeled multi-dimensional data.</p>"},{"location":"examples/xarray-integration/#overview","title":"Overview","text":"<p>Previously, MONET Plots would automatically convert all input data to pandas DataFrames using the <code>to_dataframe()</code> function. While this provided a consistent interface, it had several limitations:</p> <ul> <li>Performance overhead: Unnecessary conversion from xarray to pandas</li> <li>Loss of metadata: Xarray attributes and coordinate information were lost</li> <li>Limited functionality: Couldn't leverage xarray's powerful built-in plotting capabilities</li> </ul> <p>The new xarray integration preserves xarray objects throughout the plotting pipeline, enabling more efficient and feature-rich visualization.</p>"},{"location":"examples/xarray-integration/#key-changes","title":"Key Changes","text":""},{"location":"examples/xarray-integration/#new-normalize_data-function","title":"New <code>normalize_data()</code> Function","text":"<p>The new <code>normalize_data()</code> function replaces the previous <code>to_dataframe()</code> approach:</p> <pre><code>from monet_plots.plot_utils import normalize_data\n\n# Preserves xarray objects instead of converting to pandas\ndata = normalize_data(xarray_dataset)  # Returns xarray.Dataset\npandas_df = normalize_data(pandas_dataframe)  # Returns pandas.DataFrame\n</code></pre>"},{"location":"examples/xarray-integration/#updated-timeseriesplot","title":"Updated TimeSeriesPlot","text":"<p>The <code>TimeSeriesPlot</code> class now automatically detects and handles xarray objects:</p> <pre><code>from monet_plots.plots.timeseries import TimeSeriesPlot\n\n# Works with pandas DataFrames (backward compatible)\nplot = TimeSeriesPlot(pandas_df, x='time', y='value')\n\n# Works with xarray DataArrays\nplot = TimeSeriesPlot(xarray_dataarray, x='time', y='value')\n\n# Works with xarray Datasets\nplot = TimeSeriesPlot(xarray_dataset, x='time', y='variable_name')\n</code></pre>"},{"location":"examples/xarray-integration/#usage-examples","title":"Usage Examples","text":""},{"location":"examples/xarray-integration/#basic-xarray-time-series-plot","title":"Basic Xarray Time Series Plot","text":"<pre><code>import xarray as xr\nimport pandas as pd\nimport numpy as np\nfrom monet_plots.plots.timeseries import TimeSeriesPlot\n\n# Create sample xarray data\ndates = pd.date_range('2023-01-01', periods=100, freq='h')\ntemperature = 15 + 5 * np.sin(np.arange(100) * 2 * np.pi / 24) + np.random.normal(0, 1, 100)\n\nda = xr.DataArray(\n    temperature,\n    dims=['time'],\n    coords={'time': dates},\n    name='temperature',\n    attrs={'units': '\u00b0C', 'long_name': 'Air Temperature'}\n)\n\n# Create and plot\nplot = TimeSeriesPlot(da, x='time', y='temperature',\n                     title=\"Temperature Time Series\",\n                     ylabel=\"Temperature (\u00b0C)\")\nax = plot.plot()\nplot.save(\"temperature_timeseries.png\")\nplot.close()\n</code></pre>"},{"location":"examples/xarray-integration/#xarray-dataset-with-multiple-variables","title":"Xarray Dataset with Multiple Variables","text":"<pre><code># Create xarray dataset with multiple variables\nds = xr.Dataset({\n    'temperature': (['time'], 15 + 5 * np.sin(np.arange(100) * 2 * np.pi / 24) + np.random.normal(0, 1, 100)),\n    'humidity': (['time'], 50 + 20 * np.sin(np.arange(100) * 2 * np.pi / 24) + np.random.normal(0, 5, 100)),\n    'pressure': (['time'], 1013 + 5 * np.random.normal(0, 1, 100))\n}, coords={'time': dates})\n\n# Plot temperature from the dataset\nplot = TimeSeriesPlot(ds, x='time', y='temperature',\n                     title=\"Temperature from Dataset\")\nax = plot.plot()\nplot.save(\"dataset_temperature.png\")\nplot.close()\n</code></pre>"},{"location":"examples/xarray-integration/#backward-compatibility-with-pandas","title":"Backward Compatibility with Pandas","text":"<pre><code># Existing pandas code continues to work unchanged\ndf = pd.DataFrame({\n    'time': dates,\n    'value': np.random.normal(0, 1, 100),\n    'units': 'm/s'\n})\n\nplot = TimeSeriesPlot(df, x='time', y='value',\n                     title=\"Pandas DataFrame Plot\")\nax = plot.plot()\nplot.save(\"pandas_timeseries.png\")\nplot.close()\n</code></pre>"},{"location":"examples/xarray-integration/#benefits-of-xarray-integration","title":"Benefits of Xarray Integration","text":""},{"location":"examples/xarray-integration/#1-performance","title":"1. Performance","text":"<p>Xarray objects avoid unnecessary conversion to pandas DataFrames, reducing memory usage and improving performance for large datasets.</p>"},{"location":"examples/xarray-integration/#2-metadata-preservation","title":"2. Metadata Preservation","text":"<p>Xarray attributes and coordinate information are preserved throughout the plotting process:</p> <pre><code>da = xr.DataArray(\n    data,\n    attrs={'units': '\u00b0C', 'long_name': 'Temperature', 'instrument': 'thermometer'}\n)\n# Attributes are preserved and can be used in plots\n</code></pre>"},{"location":"examples/xarray-integration/#3-multi-dimensional-data","title":"3. Multi-dimensional Data","text":"<p>Xarray's native support for multi-dimensional data enables more sophisticated visualizations:</p> <pre><code># 2D xarray data\ndata_2d = xr.DataArray(\n    np.random.randn(10, 20),\n    dims=['time', 'space'],\n    coords={'time': pd.date_range('2023-01-01', periods=10),\n            'space': np.arange(20)}\n)\n</code></pre>"},{"location":"examples/xarray-integration/#4-built-in-plotting-capabilities","title":"4. Built-in Plotting Capabilities","text":"<p>The implementation leverages xarray's powerful built-in plotting methods for better visualization quality and consistency.</p>"},{"location":"examples/xarray-integration/#migration-guide","title":"Migration Guide","text":""},{"location":"examples/xarray-integration/#for-existing-users","title":"For Existing Users","text":"<p>No changes are required! Your existing pandas-based code will continue to work exactly as before. The new xarray support is fully backward compatible.</p>"},{"location":"examples/xarray-integration/#for-new-projects","title":"For New Projects","text":"<p>Consider using xarray for: - Time series data with regular or irregular time coordinates - Multi-dimensional data (e.g., time \u00d7 space \u00d7 variables) - Data with rich metadata that should be preserved - Large datasets where performance matters</p>"},{"location":"examples/xarray-integration/#technical-details","title":"Technical Details","text":""},{"location":"examples/xarray-integration/#data-flow","title":"Data Flow","text":"<pre><code>graph TD\n    A[Input Data] --&gt; B{normalize_data}\n    B --&gt;|xarray| C[Xarray Processing]\n    B --&gt;|pandas| D[Pandas Processing]\n    C --&gt; E[Plot Result]\n    D --&gt; E\n</code></pre>"},{"location":"examples/xarray-integration/#implementation-strategy","title":"Implementation Strategy","text":"<p>The implementation uses a duck typing approach:</p> <ol> <li>Detection: <code>normalize_data()</code> identifies the input data type</li> <li>Preservation: Xarray objects are preserved; pandas objects remain pandas</li> <li>Routing: Plot methods dispatch to appropriate handlers (<code>_plot_xarray()</code> vs <code>_plot_dataframe()</code>)</li> <li>Unification: Common interface ensures consistent behavior</li> </ol>"},{"location":"examples/xarray-integration/#error-handling","title":"Error Handling","text":"<p>The system gracefully handles edge cases: - Missing xarray dependency (falls back to pandas) - Invalid data structures (clear error messages) - Mixed data types (automatic conversion where appropriate)</p>"},{"location":"examples/xarray-integration/#performance-comparison","title":"Performance Comparison","text":""},{"location":"examples/xarray-integration/#memory-usage","title":"Memory Usage","text":"<pre><code>import sys\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\n\n# Large dataset\nn = 1_000_000\ndata = np.random.randn(n)\n\n# Pandas approach\ndf = pd.DataFrame({'time': pd.date_range('2023-01-01', periods=n), 'value': data})\nprint(f\"Pandas memory: {sys.getsizeof(df)} bytes\")\n\n# Xarray approach\nda = xr.DataArray(data, dims=['time'], coords={'time': pd.date_range('2023-01-01', periods=n)})\nprint(f\"Xarray memory: {sys.getsizeof(da)} bytes\")\n</code></pre>"},{"location":"examples/xarray-integration/#processing-time","title":"Processing Time","text":"<pre><code># Xarray avoids conversion overhead\n# For large datasets, this can be significant\n</code></pre>"},{"location":"examples/xarray-integration/#future-enhancements","title":"Future Enhancements","text":"<p>The xarray integration is designed to be extensible. Future improvements may include:</p> <ul> <li>Additional plot types: Extend xarray support to other plot classes</li> <li>Advanced features: Leverage xarray's groupby, resampling, and rolling operations</li> <li>Spatial data: Better integration with xarray's spatial coordinates</li> <li>Dask integration: Support for out-of-core computation with large datasets</li> </ul>"},{"location":"examples/xarray-integration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/xarray-integration/#common-issues","title":"Common Issues","text":"<p>Issue: <code>ModuleNotFoundError: No module named 'xarray'</code></p> <p>Solution: Install xarray with <code>pip install xarray</code> or <code>conda install xarray</code></p> <p>Issue: Plots look different between pandas and xarray versions</p> <p>Solution: This is expected due to different plotting backends. Use the same data type for consistent results.</p> <p>Issue: Performance is worse with xarray</p> <p>Solution: Ensure you're using the latest versions and check for unnecessary data conversions in your pipeline.</p>"},{"location":"examples/xarray-integration/#conclusion","title":"Conclusion","text":"<p>The xarray integration in MONET Plots provides a powerful new way to visualize scientific data while maintaining full backward compatibility. Whether you're working with time series, multi-dimensional data, or complex metadata, xarray support enables more efficient and feature-rich plotting.</p> <p>For more information, see: - Xarray Documentation - Pandas vs Xarray Comparison - MONET Plots API Reference</p>"},{"location":"gallery/","title":"MONET Plots Gallery","text":"<p>This gallery contains a collection of examples demonstrating the various plot types and features available in MONET Plots. Each example includes the source code and the resulting visualization.</p>"},{"location":"gallery/#getting-started","title":"Getting Started","text":"<p>The examples below are categorized by plot type and complexity.</p> <p> Spatial Plot </p> <p> Wind Rose </p> <p> Time Series Plot </p> <p> Upper Air Plot </p> <p> Conditional Quantile </p> <p> Soccer Plot </p> <p> Diurnal Error Plot </p> <p> Curtain Plot </p> <p> Brier Decomposition Plot </p> <p> Basic Spatial Plotting </p> <p> Bivariate Polar Plot </p> <p> Taylor Diagram </p> <p> Trajectory Plot </p> <p> Fingerprint Plot </p> <p> Profile Plot </p> <p> Xarray Integration </p> <p> Wind Barbs Plot </p> <p> Wind Quiver Plot </p> <p> Kernel Density Estimate (KDE) Plot </p> <p> Ridgeline Plot </p> <p> Spatial Contour Plot </p> <p> Categorical Plot </p> <p> Relative Economic Value Plot </p> <p> Performance Diagram </p> <p> Spatial Scatter Bias Plot (Alternative) </p> <p> Rank Histogram </p> <p> Spatial Bias Scatter Plot </p> <p> Scatter Plot with Regression </p> <p> Ensemble Spread-Skill Plot </p> <p> ROC Curve </p> <p> Reliability Diagram </p> <p> Conditional Bias </p> <p> Meteogram </p> <p> Facet Grid Plot </p> <p> Facet Grid Spatial </p> <p> Scorecard </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/mg_execution_times/","title":"Computation times","text":"<p>00:19.101 total execution time for gallery files:</p> <p>+-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_ridgeline (examples/plot_ridgeline.py)                                  | 00:02.234 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_facet_grid_spatial (examples/plot_facet_grid_spatial.py)       | 00:01.770 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_spatial (examples/plot_spatial.py)                                        | 00:01.688 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_spatial_bias_scatter (examples/plot_spatial_bias_scatter.py) | 00:00.881 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_kde (examples/plot_kde.py)                                                    | 00:00.816 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_fingerprint (examples/plot_fingerprint.py)                            | 00:00.658 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_facet_grid (examples/plot_facet_grid.py)                               | 00:00.658 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_conditional_bias (examples/plot_conditional_bias.py)             | 00:00.616 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_categorical (examples/plot_categorical.py)                            | 00:00.559 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_diurnal_error (examples/plot_diurnal_error.py)                      | 00:00.558 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_windrose (examples/plot_windrose.py)                                     | 00:00.544 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_curtain (examples/plot_curtain.py)                                        | 00:00.453 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_scorecard (examples/plot_scorecard.py)                                  | 00:00.426 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_timeseries (examples/plot_timeseries.py)                               | 00:00.421 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_polar (examples/plot_polar.py)                                              | 00:00.420 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_meteogram (examples/plot_meteogram.py)                                  | 00:00.416 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_performance_diagram (examples/plot_performance_diagram.py)    | 00:00.413 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_upper_air (examples/plot_upper_air.py)                                  | 00:00.401 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_rev (examples/plot_rev.py)                                                    | 00:00.383 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_ensemble (examples/plot_ensemble.py)                                     | 00:00.381 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_reliability_diagram (examples/plot_reliability_diagram.py)    | 00:00.379 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_conditional_quantile (examples/plot_conditional_quantile.py) | 00:00.378 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_roc_curve (examples/plot_roc_curve.py)                                  | 00:00.367 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_taylor_diagram (examples/plot_taylor_diagram.py)                   | 00:00.358 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_profile (examples/plot_profile.py)                                        | 00:00.352 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_rank_histogram (examples/plot_rank_histogram.py)                   | 00:00.349 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_brier_decomposition (examples/plot_brier_decomposition.py)    | 00:00.343 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_soccer (examples/plot_soccer.py)                                           | 00:00.335 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_scatter (examples/plot_scatter.py)                                        | 00:00.327 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_spatial_contour (examples/plot_spatial_contour.py)                | 00:00.284 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_trajectory (examples/plot_trajectory.py)                               | 00:00.262 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_xarray_integration (examples/plot_xarray_integration.py)       | 00:00.247 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_basic_plotting (examples/plot_basic_plotting.py)                   | 00:00.182 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_wind_quiver (examples/plot_wind_quiver.py)                            | 00:00.142 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_wind_barbs (examples/plot_wind_barbs.py)                               | 00:00.096 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+ | plot_sp_scatter_bias (examples/plot_sp_scatter_bias.py)                | 00:00.001 | 0.0 MB | +-----------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"gallery/plot_basic_plotting/","title":"Basic Spatial Plotting","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_basic_plotting/#basic-spatial-plotting","title":"Basic Spatial Plotting","text":"<p>What it's for: This example demonstrates the foundational <code>SpatialPlot</code> class, which provides a consistent interface for creating map-based visualizations in MONET Plots.</p> <p>When to use: Use <code>SpatialPlot</code> when you need full control over a map-based visualization and want to use standard Matplotlib or Cartopy commands on a pre-configured axes that includes geographic features.</p> <p>How to read: *   Axes: The plot is in geographic coordinates (typically Latitude/Longitude). *   Features: It automatically includes geographic context like coastlines and     borders to provide spatial orientation. *   Interpretation: Data is plotted directly onto the map; the location of colors     or markers corresponds to their real-world geographical position.</p> <p>Out:</p> <pre><code>Basic spatial plot saved successfully!\n</code></pre> <p></p> <pre><code>import numpy as np\nfrom monet_plots import SpatialPlot\n\n# Step 1: Prepare spatial data\n# Create a 2D array representing spatial data\ndata = np.random.random((20, 30)) * 100\n\n# Step 2: Initialize the plot\nplot = SpatialPlot(figsize=(10, 8))\n\n# Step 3: Plot the data\n# SpatialPlot sets up the map axes. We use standard matplotlib/cartopy methods to plot.\nplot.ax.pcolormesh(data)\nplot.ax.set_title(\"Basic Spatial Plot\")\n\n# Step 4: Add labels and save\nplot.ax.set_xlabel(\"Longitude\")\nplot.ax.set_ylabel(\"Latitude\")\nplot.save(\"basic_spatial.png\")\n\n# Step 5: Close the plot\nplot.close()\n\nprint(\"Basic spatial plot saved successfully!\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.182 seconds)</p> <p> Download Python source code: plot_basic_plotting.py</p> <p> Download Jupyter notebook: plot_basic_plotting.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_brier_decomposition/","title":"Brier Decomposition Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_brier_decomposition/#brier-decomposition-plot","title":"Brier Decomposition Plot","text":"<p>What it's for: The Brier Score Decomposition plot visualizes the three components of the Brier Score: Reliability, Resolution, and Uncertainty. The total Brier Score (BS) is calculated as: BS = Reliability - Resolution + Uncertainty.</p> <p>When to use: Use this to gain a deeper understanding of why a probabilistic forecast system is performing a certain way. It allows you to distinguish between a model that is poorly calibrated (Reliability) and one that lacks the ability to distinguish different outcomes (Resolution).</p> <p>How to read: *   Reliability (Lower is better): Measures the weighted average of the squared     differences between forecast probabilities and the relative frequencies of observed events. *   Resolution (Higher is better): Measures how much the frequencies of events for     specific forecast categories differ from the overall climatological frequency. *   Uncertainty (Fixed for a given set of observations): Represents the inherent     variability of the events being forecast. *   Interpretation: A perfect model would have a Reliability of 0 and a Resolution     equal to the Uncertainty, resulting in a Brier Score of 0.</p> <p></p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.brier_decomposition import BrierScoreDecompositionPlot\n\ndata = pd.DataFrame(\n    {\n        \"model\": [\"Model A\", \"Model B\", \"Model C\"],\n        \"reliability\": [0.02, 0.05, 0.01],\n        \"resolution\": [0.15, 0.10, 0.18],\n        \"uncertainty\": [0.25, 0.25, 0.25],\n    }\n)\n\nplot = BrierScoreDecompositionPlot(figsize=(10, 7))\nplot.plot(\n    data,\n    reliability_col=\"reliability\",\n    resolution_col=\"resolution\",\n    uncertainty_col=\"uncertainty\",\n    label_col=\"model\",\n    title=\"Brier Score Decomposition Comparison\",\n)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.343 seconds)</p> <p> Download Python source code: plot_brier_decomposition.py</p> <p> Download Jupyter notebook: plot_brier_decomposition.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_categorical/","title":"Categorical Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_categorical/#categorical-plot","title":"Categorical Plot","text":"<p>What it's for: The <code>categorical_plot</code> function is a versatile tool for visualizing data that is grouped into discrete categories (e.g., different models, sites, or seasons). It supports various underlying plot types like bars, boxes, or violins.</p> <p>When to use: Use this to compare aggregate statistics across different groups. It is ideal for showing how Mean Bias or RMSE varies between different model versions or different geographic regions.</p> <p>How to read: *   X-axis: Represents discrete categories. *   Y-axis: Represents the numerical variable being compared. *   Interpretation: In a bar plot (as shown here), the height of the bar usually     represents the mean or median of the group. Error bars (if present) show the     variability or uncertainty within that category.</p> <p></p> <pre><code>import xarray as xr\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.categorical import categorical_plot\n\n# 1. Prepare sample data\n# Create a sample xarray DataArray with a categorical dimension\nnp.random.seed(42)  # for reproducibility\ndata = xr.DataArray(\n    np.random.normal(loc=10, scale=2, size=(100, 3)),\n    coords={\"sample\": np.arange(100), \"category\": [\"Group A\", \"Group B\", \"Group C\"]},\n    dims=[\"sample\", \"category\"],\n    name=\"measurement\",\n)\n\n# 2. Create a basic bar plot\n# Note: categorical_plot handles conversion to dataframe internally if needed\nfig, ax = categorical_plot(\n    data,\n    x=\"category\",\n    y=\"measurement\",\n    kind=\"bar\",\n    title=\"Mean Measurement per Category\",\n    xlabel=\"Category\",\n    ylabel=\"Measurement Value\",\n)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.559 seconds)</p> <p> Download Python source code: plot_categorical.py</p> <p> Download Jupyter notebook: plot_categorical.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_conditional_bias/","title":"Conditional Bias","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_conditional_bias/#conditional-bias","title":"Conditional Bias","text":"<p>What it's for: A Conditional Bias plot examines how the mean bias of a model varies as a function of the observed or modeled value itself.</p> <p>When to use: Use this plot to identify systematic errors that are dependent on the magnitude of the variable. For example, it can reveal if a model consistently over-predicts low concentrations but under-predicts high concentrations (a common issue in many environmental models).</p> <p>How to read: *   X-axis: The reference value (typically the observed value), often grouped into bins. *   Y-axis: The mean bias (Model - Observation) calculated for each bin. *   Zero Line: A horizontal line at zero represents no bias. *   Interpretation: Points above the zero line indicate over-prediction for that range,     while points below indicate under-prediction. The trend of the points shows how the     model's systematic error changes across the data range.</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.conditional_bias import ConditionalBiasPlot\n\n# 1. Prepare sample data\nnp.random.seed(42)  # for reproducibility\nn_samples = 500\n\n# Simulate observations\nobservations = np.random.normal(loc=10, scale=3, size=n_samples)\n\n# Simulate forecasts with a bias that depends on the observation value:\n# - For lower observations, forecast is slightly higher (positive bias)\n# - For higher observations, forecast is slightly lower (negative bias)\n# - Add some random noise\nforecasts = (\n    observations\n    + (0.5 - 0.1 * observations)\n    + np.random.normal(loc=0, scale=0.5, size=n_samples)\n)\n\n# Ensure data is in a DataFrame\ndf = pd.DataFrame({\"observations\": observations, \"forecasts\": forecasts})\n\n# 2. Initialize and create the plot\nplot = ConditionalBiasPlot(figsize=(10, 6))\nplot.plot(df, obs_col=\"observations\", fcst_col=\"forecasts\", n_bins=15)\n\n# 3. Add titles and labels\nplot.ax.set_title(\"Conditional Bias Plot (Forecast vs. Observation)\")\nplot.ax.set_xlabel(\"Observed Value\")\nplot.ax.set_ylabel(\"Mean Bias (Forecast - Observation)\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.616 seconds)</p> <p> Download Python source code: plot_conditional_bias.py</p> <p> Download Jupyter notebook: plot_conditional_bias.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_conditional_quantile/","title":"Conditional Quantile","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_conditional_quantile/#conditional-quantile","title":"Conditional Quantile","text":"<p>What it's for: A Conditional Quantile plot provides a comprehensive view of model performance by showing the distribution of modeled values conditioned on the observed values. It goes beyond simple mean bias by showing the spread and variability of the model across the entire data range.</p> <p>When to use: Use this when you need a detailed diagnosis of model error distributions. It is particularly useful for understanding how the model handles extremes and whether the uncertainty in the model increases or decreases with the magnitude of the variable.</p> <p>How to read: *   X-axis: The observed value, divided into bins. *   Y-axis: The modeled value. *   1:1 Line: Represents a perfect match between model and observations. *   Central Line (Median): Shows the 50th percentile of the model for each observation bin. *   Shaded Regions/Quantiles: Represent different percentiles (e.g., 25th-75th, 5th-95th).     A narrow band indicates consistent model behavior, while a wide band indicates high     variability/uncertainty for that observed value.</p> <p></p> <p>Out:</p> <pre><code>Conditional quantile plot saved to conditional_quantile_example.png\n</code></pre> <p></p> <pre><code>import pandas as pd\nimport numpy as np\nfrom monet_plots.plots.conditional_quantile import ConditionalQuantilePlot\n\n# Create dummy model vs obs\nobs = np.random.exponential(10, 1000)\nmod = obs * 0.8 + np.random.normal(0, 5, 1000) + 2\n\ndf = pd.DataFrame({\"obs\": obs, \"mod\": mod})\n\n# Initialize and plot\nplot = ConditionalQuantilePlot(df, obs_col=\"obs\", mod_col=\"mod\", bins=10)\nplot.plot(show_points=True)\nplot.save(\"conditional_quantile_example.png\")\nprint(\"Conditional quantile plot saved to conditional_quantile_example.png\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.378 seconds)</p> <p> Download Python source code: plot_conditional_quantile.py</p> <p> Download Jupyter notebook: plot_conditional_quantile.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_curtain/","title":"Curtain Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_curtain/#curtain-plot","title":"Curtain Plot","text":"<p>What it's for: A Curtain plot (or time-height cross-section) visualizes how a vertical profile changes over time at a fixed location, or along a moving path (like a flight track).</p> <p>When to use: Use this to monitor the evolution of the planetary boundary layer, track the arrival and dispersion of a smoke plume, or analyze the vertical structure of a weather system as it passes over a station.</p> <p>How to read: *   X-axis: Typically represents Time (or distance along a track). *   Y-axis: Represents Altitude or Pressure. *   Color: Represents the magnitude of the variable being plotted (e.g., PM2.5     concentration, potential temperature). *   Interpretation: Look for temporal trends at specific heights or the movement of     features (like an inversion layer) upward or downward over time.</p> <p></p> <p>Out:</p> <pre><code>Curtain plot saved to curtain_example.png\n</code></pre> <p></p> <pre><code>import xarray as xr\nimport numpy as np\nimport pandas as pd\nfrom monet_plots.plots.curtain import CurtainPlot\n\n# Create dummy 2D data\ntimes = pd.date_range(\"2023-01-01\", periods=24, freq=\"h\")\nlevels = np.linspace(1000, 100, 10)\ndata = np.exp(-((np.arange(24) - 12) ** 2) / 20)[:, np.newaxis] * np.exp(\n    -((np.arange(10) - 5) ** 2) / 10\n)\nda = xr.DataArray(\n    data.T, coords=[levels, times], dims=[\"level\", \"time\"], name=\"concentration\"\n)\n\n# Initialize and plot\nplot = CurtainPlot(da)\nplot.plot(kind=\"contourf\", cmap=\"viridis\")\nplot.save(\"curtain_example.png\")\nprint(\"Curtain plot saved to curtain_example.png\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.453 seconds)</p> <p> Download Python source code: plot_curtain.py</p> <p> Download Jupyter notebook: plot_curtain.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_diurnal_error/","title":"Diurnal Error Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_diurnal_error/#diurnal-error-plot","title":"Diurnal Error Plot","text":"<p>What it's for: A Diurnal Error plot visualizes how model performance (typically Mean Bias) varies across the 24-hour daily cycle.</p> <p>When to use: Use this to diagnose systemic issues in the model that are linked to the time of day, such as errors in the timing of emissions, the development of the planetary boundary layer, or the model's response to solar radiation.</p> <p>How to read: *   X-axis: Hour of the day (0-23), often in local time or UTC. *   Y-axis: Represents the error metric (e.g., Model - Observation). *   Interpretation: Look for consistent peaks or troughs at specific times. For     example, a large positive bias in the morning might indicate an issue with     how the model handles the transition from a stable nighttime boundary layer     to a convective daytime one.</p> <p></p> <p>Out:</p> <pre><code>Diurnal error plot saved to diurnal_error_example.png\n</code></pre> <p></p> <pre><code>import pandas as pd\nimport numpy as np\nfrom monet_plots.plots.diurnal_error import DiurnalErrorPlot\n\n# Create dummy time series data\ndates = pd.date_range(\"2023-01-01\", periods=24 * 30, freq=\"h\")\ndf = pd.DataFrame(\n    {\n        \"time\": dates,\n        \"obs\": np.random.rand(24 * 30) * 10 + 5,\n        \"mod\": np.random.rand(24 * 30) * 10 + 6,  # Slight bias\n    }\n)\n\n# Initialize and plot\nplot = DiurnalErrorPlot(df, obs_col=\"obs\", mod_col=\"mod\", second_dim=\"dayofweek\")\nplot.plot()\nplot.save(\"diurnal_error_example.png\")\nprint(\"Diurnal error plot saved to diurnal_error_example.png\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.558 seconds)</p> <p> Download Python source code: plot_diurnal_error.py</p> <p> Download Jupyter notebook: plot_diurnal_error.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_ensemble/","title":"Ensemble Spread-Skill Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_ensemble/#ensemble-spread-skill-plot","title":"Ensemble Spread-Skill Plot","text":"<p>What it's for: The Spread-Skill plot evaluates the reliability of an ensemble forecast system by comparing the ensemble spread (the standard deviation among ensemble members) to the skill (the actual error, usually RMSE, of the ensemble mean).</p> <p>When to use: Use this to determine if your ensemble is well-calibrated. A perfectly calibrated ensemble should have a spread that matches the expected error of the ensemble mean.</p> <p>How to read: *   X-axis: Ensemble Spread. *   Y-axis: Ensemble Skill (RMSE of the mean). *   1:1 Line: Represents a perfectly calibrated ensemble. *   Points above the line: Indicate the ensemble is \"under-dispersive\" (too     little spread; the model is overconfident). *   Points below the line: Indicate the ensemble is \"over-dispersive\" (too     much spread; the model is under-confident).</p> <p></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.ensemble import SpreadSkillPlot\n\n# 1. Prepare sample data\nnp.random.seed(42)  # for reproducibility\n\n# Simulate ensemble spread (standard deviation of ensemble members)\n# Values typically range from 0 upwards\nspread_data = np.random.uniform(0.5, 3.0, 50)\n\n# Simulate ensemble skill (RMSE of ensemble mean)\n# For a reliable ensemble, skill should be close to spread.\n# We'll add some noise around the spread to simulate real-world data.\nskill_data = spread_data + np.random.normal(0, 0.5, 50)\n# Ensure skill is non-negative\nskill_data[skill_data &lt; 0] = 0.1\n\n# 2. Initialize and create the plot\nplot = SpreadSkillPlot(spread=spread_data, skill=skill_data, figsize=(8, 8))\nplot.plot(color=\"blue\", alpha=0.7, s=50, label=\"Ensemble Data\")\n\n# The plot method automatically adds labels, title, and a 1:1 line.\n# You can further customize if needed.\nplot.ax.legend()  # Display the legend for the scatter points\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.381 seconds)</p> <p> Download Python source code: plot_ensemble.py</p> <p> Download Jupyter notebook: plot_ensemble.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_facet_grid/","title":"Facet Grid Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_facet_grid/#facet-grid-plot","title":"Facet Grid Plot","text":"<p>What it's for: A Facet Grid allows you to create a matrix of subplots (facets) based on categorical variables in your dataset. It is a powerful way to visualize the same relationship across different subsets of data.</p> <p>When to use: Use this to explore how a relationship (e.g., between model and observation) changes across different sites, months, variables, or experiment groups. It enables \"small multiple\" visualizations that are much easier to compare than separate plots.</p> <p>How to read: *   Columns/Rows: Represent different levels of a categorical variable (e.g.,     each column is a different city). *   Subplots: Each facet contains a plot of the same type (e.g., a scatter plot). *   Interpretation: Compare the trends, slopes, or distributions across the     facets to identify inconsistencies or regional/temporal differences.</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.facet_grid import FacetGridPlot\n\n# 1. Prepare sample data\nnp.random.seed(42)  # for reproducibility\nn_samples_per_category = 100\ncategories = [\"Group A\", \"Group B\", \"Group C\"]\n\ndata_list = []\nfor i, cat in enumerate(categories):\n    x = np.random.normal(loc=i * 5, scale=2, size=n_samples_per_category)\n    y = 0.5 * x + np.random.normal(loc=0, scale=1, size=n_samples_per_category) + i * 3\n    temp_df = pd.DataFrame({\"x_data\": x, \"y_data\": y, \"category\": cat})\n    data_list.append(temp_df)\n\ndf = pd.concat(data_list).reset_index(drop=True)\n\n# 2. Initialize FacetGridPlot\n# We'll create a column for each 'category'\nfg_plot = FacetGridPlot(data=df, col=\"category\", height=4, aspect=1.2)\n\n# 3. Map a scatter plot to each facet\nfg_plot.grid.map(plt.scatter, \"x_data\", \"y_data\", alpha=0.7, s=50, edgecolor=\"w\")\n\n# 4. Set titles and labels\nfg_plot.set_titles(col_template=\"Category: {col_name}\")\nfg_plot.grid.set_xlabels(\"X-axis Data\")\nfg_plot.grid.set_ylabels(\"Y-axis Data\")\nfg_plot.fig.suptitle(\n    \"Scatter Plot across Categories\", y=1.02\n)  # y adjusts title position\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.658 seconds)</p> <p> Download Python source code: plot_facet_grid.py</p> <p> Download Jupyter notebook: plot_facet_grid.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_facet_grid_spatial/","title":"Facet Grid Spatial","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_facet_grid_spatial/#facet-grid-spatial","title":"Facet Grid Spatial","text":"<p>What it's for: Facet Grid Spatial is an extension of the facet grid concept applied to geographic maps. It allows you to create a matrix of maps, where each map represents a different subset of your data (e.g., different models and different timestamps).</p> <p>When to use: Use this when you need to compare spatial patterns across multiple dimensions simultaneously, such as comparing the output of several different models at multiple points in time. It is the most effective way to identify where and when models diverge in their spatial predictions.</p> <p>How to read: *   Rows/Columns: Represent different categorical dimensions (e.g., Time vs. Model). *   Subplots: Each facet is a complete <code>SpatialPlot</code> showing the geographic     distribution of a variable. *   Interpretation: Look for spatial shifts or intensity differences between     the maps in different rows and columns.</p> <p></p> <p>Out:</p> <pre><code>/opt/hostedtoolcache/Python/3.10.19/x64/lib/python3.10/site-packages/seaborn/axisgrid.py:123: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.\n  self._figure.tight_layout(*args, **kwargs)\n/home/runner/work/monet-plots/monet-plots/examples/plot_facet_grid_spatial.py:68: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.\n  plt.tight_layout()\nGenerated 'facet_grid_spatial_plot.png'\n</code></pre> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport xarray as xr\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.facet_grid import SpatialFacetGridPlot\nfrom monet_plots.plots.spatial_imshow import SpatialImshowPlot\n\n# 1. Create some dummy spatial data\n# Simulate data for two models ('model_A', 'model_B') and two times ('2023-01-01', '2023-01-02')\nlats = np.arange(30, 35, 0.5)\nlons = np.arange(-100, -95, 0.5)\ntimes = pd.to_datetime([\"2023-01-01\", \"2023-01-02\"])\nmodels = [\"model_A\", \"model_B\"]\n\n# Create a DataArray with dimensions (time, model, lat, lon)\ndata = xr.DataArray(\n    np.random.rand(len(times), len(models), len(lats), len(lons)) * 100,\n    coords={\"time\": times, \"model\": models, \"lat\": lats, \"lon\": lons},\n    dims=[\"time\", \"model\", \"lat\", \"lon\"],\n    name=\"temperature\",\n)\n\n# Add some variation for demonstration\ndata.loc[{\"model\": \"model_A\", \"time\": \"2023-01-01\"}] += 10\ndata.loc[{\"model\": \"model_B\", \"time\": \"2023-01-02\"}] -= 5\n\n# Convert to Dataset if you have multiple variables, or keep as DataArray\nds = data.to_dataset()\n\n\n# 2. Use SpatialFacetGridPlot\n# We want 'time' as rows and 'model' as columns\ngrid = SpatialFacetGridPlot(ds, row=\"time\", col=\"model\", height=4, aspect=1.2)\n\n# 3. Map SpatialImshowPlot to each facet using map_monet\ngrid.map_monet(\n    SpatialImshowPlot,\n    cmap=\"viridis\",\n    coastlines=True,\n    add_colorbar=True,\n    label=\"Temperature (C)\",\n)\n\n# 4. Final adjustments\nplt.tight_layout()\n\n# 5. Save the figure\ngrid.save(\"facet_grid_spatial_plot.png\", dpi=300)\n\nprint(\"Generated 'facet_grid_spatial_plot.png'\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.770 seconds)</p> <p> Download Python source code: plot_facet_grid_spatial.py</p> <p> Download Jupyter notebook: plot_facet_grid_spatial.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_fingerprint/","title":"Fingerprint Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_fingerprint/#fingerprint-plot","title":"Fingerprint Plot","text":"<p>What it's for: A Fingerprint plot is a 2D heatmap used to identify temporal patterns and cycles in a time series, such as diurnal (daily) and seasonal variations.</p> <p>When to use: Use this to analyze long-term monitoring data (e.g., air quality, temperature, energy usage). It is excellent for revealing when high-concentration events typically occur\u2014for instance, during morning rush hour or on specific days of the year.</p> <p>How to read: *   X-axis: Typically represents the Hour of the Day (0-23). *   Y-axis: Typically represents the Day of the Year, Month, or Date. *   Color: Represents the magnitude of the variable being analyzed. *   Interpretation: Look for vertical bands (indicating consistent diurnal patterns     across the year) or horizontal bands (indicating seasonal patterns). Bright spots     highlight specific times and days with unusually high or low values.</p> <p></p> <p>Out:</p> <pre><code>Fingerprint plot saved to fingerprint_example.png\n</code></pre> <p></p> <pre><code>import pandas as pd\nimport numpy as np\nfrom monet_plots.plots.fingerprint import FingerprintPlot\n\n# Create dummy data showing a diurnal/seasonal pattern\ndates = pd.date_range(\"2023-01-01\", periods=24 * 365, freq=\"h\")\nhours = dates.hour\ndoy = dates.dayofyear\nval = (\n    np.sin(2 * np.pi * hours / 24)\n    + np.sin(2 * np.pi * doy / 365)\n    + np.random.randn(24 * 365) * 0.1\n)\n\ndf = pd.DataFrame({\"time\": dates, \"concentration\": val})\n\n# Initialize and plot\nplot = FingerprintPlot(df, val_col=\"concentration\", x_scale=\"hour\", y_scale=\"dayofyear\")\nplot.plot(cmap=\"magma\")\nplot.save(\"fingerprint_example.png\")\nprint(\"Fingerprint plot saved to fingerprint_example.png\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.658 seconds)</p> <p> Download Python source code: plot_fingerprint.py</p> <p> Download Jupyter notebook: plot_fingerprint.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_kde/","title":"Kernel Density Estimate (KDE) Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_kde/#kernel-density-estimate-kde-plot","title":"Kernel Density Estimate (KDE) Plot","text":"<p>What it's for: A KDE plot visualizes the probability density of one or more variables. It provides a smoothed version of a histogram, making it easier to identify the underlying distribution of the data.</p> <p>When to use: Use this to visualize the distribution of model errors, concentrations, or any continuous variable. In 2D (as shown in this example), it is excellent for visualizing the joint distribution and correlation between two variables without the clutter of a scatter plot.</p> <p>How to read: *   Axes: Represent the variables being analyzed. *   Contour/Color: Higher intensity or specific contour levels indicate regions with     a higher density of data points (i.e., where values are more likely to occur). *   Interpretation: The peak of the density represents the most frequent value (mode).     In 2D, the shape of the density (e.g., an elongated ellipse) indicates the     correlation between the two variables.</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.kde import KDEPlot\n\n# 1. Prepare sample data\nnp.random.seed(42)  # for reproducibility\nmean = [0, 0]\ncov = [[1, 0.8], [0.8, 1]]  # Correlated variables\ndata = np.random.multivariate_normal(mean, cov, 1000)\ndf = pd.DataFrame(data, columns=[\"Variable A\", \"Variable B\"])\n\n# 2. Initialize and create the plot\nplot = KDEPlot(\n    df=df,\n    x=\"Variable A\",\n    y=\"Variable B\",\n    title=\"2D Kernel Density Estimate of Correlated Variables\",\n    figsize=(8, 7),\n)\nplot.plot()  # Default KDE plot\n\n# 3. Add titles and labels\nplot.ax.set_xlabel(\"Variable A\")\nplot.ax.set_ylabel(\"Variable B\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.816 seconds)</p> <p> Download Python source code: plot_kde.py</p> <p> Download Jupyter notebook: plot_kde.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_meteogram/","title":"Meteogram","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_meteogram/#meteogram","title":"Meteogram","text":"<p>What it's for: A Meteogram is a time series plot that displays multiple meteorological variables (e.g., temperature, pressure, humidity, wind) for a single geographical location.</p> <p>When to use: Use this to visualize the evolution of local weather conditions over a specific period. It is commonly used for weather forecasting, climate monitoring, and analyzing site-specific observational data.</p> <p>How to read: *   X-axis: Represents time (usually UTC or local time). *   Y-axes: Each variable is typically plotted on its own axis or in a stacked sub-plot. *   Interpretation: Look for correlations between variables (e.g., a drop in pressure     followed by a change in wind direction and temperature, indicating a frontal passage).</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.meteogram import Meteogram\n\n# 1. Prepare sample data\nnp.random.seed(42)  # for reproducibility\ndates = pd.date_range(\"2023-01-01 00:00\", periods=24, freq=\"h\")\n\n# Simulate temperature with a diurnal cycle\ntemperature = (\n    20 + 5 * np.sin(np.linspace(0, 2 * np.pi, 24)) + np.random.normal(0, 0.5, 24)\n)\n# Simulate humidity\nhumidity = 70 - 10 * np.cos(np.linspace(0, 2 * np.pi, 24)) + np.random.normal(0, 1, 24)\n# Simulate pressure\npressure = (\n    1012\n    + 3 * np.sin(np.linspace(0, 2 * np.pi, 24) + np.pi / 4)\n    + np.random.normal(0, 0.2, 24)\n)\n\ndf = pd.DataFrame(\n    {\"Temperature\": temperature, \"Humidity\": humidity, \"Pressure\": pressure},\n    index=dates,\n)\n\n# 2. Initialize and create the plot\nplot = Meteogram(\n    df=df, variables=[\"Temperature\", \"Humidity\", \"Pressure\"], figsize=(12, 9)\n)\nplot.plot(linewidth=1.5, marker=\"o\", markersize=3)  # Plot with lines and markers\n\n# Add an overall title to the figure\nplot.fig.suptitle(\"Synthetic Meteogram for a 24-hour Period\", fontsize=16)\n\nplt.tight_layout(rect=[0, 0.03, 1, 0.95])  # Adjust layout to prevent title overlap\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.416 seconds)</p> <p> Download Python source code: plot_meteogram.py</p> <p> Download Jupyter notebook: plot_meteogram.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_performance_diagram/","title":"Performance Diagram","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_performance_diagram/#performance-diagram","title":"Performance Diagram","text":"<p>What it's for: The Performance Diagram is a powerful visualization tool for evaluating categorical (yes/no) forecasts. It provides a concise summary of several key verification metrics in a single plot, specifically relating the Success Ratio (1 - False Alarm Ratio) and the Probability of Detection (POD).</p> <p>When to use: Use this diagram when evaluating the performance of deterministic or thresholded probabilistic forecasts, especially for rare events where standard accuracy can be misleading. It is commonly used in meteorology to assess weather warning systems and model skill.</p> <p>How to read: *   X-axis: Success Ratio (the fraction of \"yes\" forecasts that were correct). *   Y-axis: Probability of Detection (the fraction of \"yes\" events that were correctly forecast). *   Dashed Lines: Represent Frequency Bias. A bias of 1 (the diagonal) indicates the system     forecast the event as often as it occurred. *   Solid Contours: Represent the Critical Success Index (CSI). Higher CSI values (moving     toward the top-right) indicate better overall skill. *   Interpretation: A perfect forecast resides at the top-right corner (Success Ratio = 1, POD = 1).</p> <p></p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.performance_diagram import PerformanceDiagramPlot\n\n# 1. Prepare sample data with pre-calculated metrics\n# Each row represents a different forecast threshold or scenario\ndata = {\n    \"success_ratio\": [0.2, 0.4, 0.6, 0.8, 0.9],\n    \"pod\": [0.3, 0.6, 0.7, 0.85, 0.92],\n    \"model\": [\"Model A\"] * 5,  # For a single model\n}\ndf = pd.DataFrame(data)\n\n# 2. Initialize and create the plot\nplot = PerformanceDiagramPlot(figsize=(8, 8))\nplot.plot(\n    df,\n    x_col=\"success_ratio\",\n    y_col=\"pod\",\n    markersize=8,\n    color=\"blue\",\n    label=\"Forecast System\",\n)\n\n# 3. Add titles and labels (optional, but good practice)\nplot.ax.set_title(\"Performance Diagram for a Forecast System\")\nplot.ax.legend(loc=\"lower right\")  # Add legend for the plotted points\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.413 seconds)</p> <p> Download Python source code: plot_performance_diagram.py</p> <p> Download Jupyter notebook: plot_performance_diagram.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_polar/","title":"Bivariate Polar Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_polar/#bivariate-polar-plot","title":"Bivariate Polar Plot","text":"<p>What it's for: A Bivariate Polar plot (sometimes called a polar plot or bivariate plot) visualizes how a variable (e.g., pollutant concentration) varies as a function of wind speed and wind direction.</p> <p>When to use: Use this to identify the potential source directions and distances (using wind speed as a proxy for distance/source type) of observed concentrations at a monitoring site. High concentrations at low wind speeds often suggest local sources, while high concentrations at high wind speeds suggest long-range transport.</p> <p>How to read: *   Angle: Represents the Wind Direction (0-360 degrees). *   Radial Distance: Represents the Wind Speed. *   Color: Represents the magnitude of the variable (e.g., concentration). *   Interpretation: Bright clusters indicate specific wind conditions (direction     and speed) associated with high values of the variable.</p> <p></p> <p>Out:</p> <pre><code>Bivariate polar plot saved to polar_example.png\n</code></pre> <p></p> <pre><code>import pandas as pd\nimport numpy as np\nfrom monet_plots.plots.polar import BivariatePolarPlot\n\n# Create dummy wind dependent data\nn = 1000\nws = np.random.gamma(2, 2, n)\nwd = np.random.uniform(0, 360, n)\n# Concentration higher when wind is from the East (90 deg) and low speed\nconc = 10 * np.exp(-((wd - 90) ** 2) / 1000) * np.exp(-ws / 5) + np.random.rand(n)\n\ndf = pd.DataFrame({\"ws\": ws, \"wd\": wd, \"conc\": conc})\n\n# Initialize and plot\nplot = BivariatePolarPlot(df, ws_col=\"ws\", wd_col=\"wd\", val_col=\"conc\")\nplot.plot(n_bins_ws=15, n_bins_wd=36)\nplot.save(\"polar_example.png\")\nprint(\"Bivariate polar plot saved to polar_example.png\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.420 seconds)</p> <p> Download Python source code: plot_polar.py</p> <p> Download Jupyter notebook: plot_polar.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_profile/","title":"Profile Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_profile/#profile-plot","title":"Profile Plot","text":"<p>What it's for: A Profile plot visualizes the vertical distribution of a variable (e.g., temperature, humidity, or pollutant concentration) through the atmosphere or a body of water.</p> <p>When to use: Use this for atmospheric soundings (radiosondes), LIDAR/SODAR measurements, or model vertical grid evaluation. It is essential for understanding the stability of the atmosphere or the structure of the planetary boundary layer.</p> <p>How to read: *   X-axis: The variable of interest (e.g., Temperature, Mixing Ratio). *   Y-axis: Altitude (meters, kilometers) or Pressure (hPa). In meteorology, it is common     to use pressure as a vertical coordinate. *   Interpretation: The slope of the line indicates the vertical gradient of the     variable (e.g., the lapse rate for temperature).</p> <p></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.profile import ProfilePlot\n\n# 1. Prepare sample 1D data\naltitude = np.linspace(0, 10000, 100)  # meters\ntemperature = 20 - 0.0065 * altitude + 5 * np.sin(altitude / 1000)  # degrees Celsius\n\n# 2. Initialize and create the plot\nplot = ProfilePlot(x=temperature, y=altitude, figsize=(7, 9))\nplot.plot(color=\"red\", linewidth=2, label=\"Temperature Profile\")\n\n# 3. Add titles and labels\nplot.ax.set_title(\"Atmospheric Temperature Profile\")\nplot.ax.set_xlabel(\"Temperature (\u00b0C)\")\nplot.ax.set_ylabel(\"Altitude (m)\")\nplot.ax.legend()\nplot.ax.grid(True, linestyle=\"--\", alpha=0.6)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.352 seconds)</p> <p> Download Python source code: plot_profile.py</p> <p> Download Jupyter notebook: plot_profile.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_rank_histogram/","title":"Rank Histogram","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_rank_histogram/#rank-histogram","title":"Rank Histogram","text":"<p>What it's for: The Rank Histogram (also known as a Talagrand diagram) is used to evaluate the reliability of an ensemble forecast system. It checks whether the observation is equally likely to fall in any of the \"bins\" defined by the sorted ensemble members.</p> <p>When to use: Use this when you have an ensemble of forecasts and a corresponding observation. It is essential for diagnosing issues with ensemble spread and bias.</p> <p>How to read: *   X-axis: The rank of the observation relative to the sorted ensemble members (0 to N). *   Y-axis: Frequency or relative frequency of occurrences in each rank. *   Flat (Uniform): Indicates a reliable ensemble where the observation is indistinguishable     from the ensemble members. *   U-shape: Indicates a lack of spread (the ensemble is over-confident; the observation     frequently falls outside the ensemble range). *   Dome shape: Indicates too much spread (the ensemble is under-confident; the observation     falls in the middle more often than expected). *   Asymmetry (Sloping): Indicates a systematic bias in the ensemble mean.</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.rank_histogram import RankHistogramPlot\n\n# 1. Prepare sample data for a uniform rank distribution\nnp.random.seed(42)  # for reproducibility\nn_ensemble_members = 10\nn_forecasts = 1000\n\n# Simulate ranks from 0 to n_ensemble_members (inclusive)\n# A uniform distribution means each rank is equally likely\nranks_uniform = np.random.randint(0, n_ensemble_members + 1, n_forecasts)\ndf_uniform = pd.DataFrame({\"rank\": ranks_uniform})\n\n# 2. Initialize and create the plot\nplot = RankHistogramPlot(figsize=(10, 6))\nplot.plot(df_uniform, rank_col=\"rank\", n_members=n_ensemble_members, normalize=True)\n\n# 3. Add titles and labels\nplot.ax.set_title(\"Rank Histogram: Uniform Distribution (Reliable Ensemble)\")\nplot.ax.set_xlabel(\"Rank of Observation\")\nplot.ax.set_ylabel(\"Relative Frequency\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.349 seconds)</p> <p> Download Python source code: plot_rank_histogram.py</p> <p> Download Jupyter notebook: plot_rank_histogram.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_reliability_diagram/","title":"Reliability Diagram","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_reliability_diagram/#reliability-diagram","title":"Reliability Diagram","text":"<p>What it's for: A Reliability Diagram (or calibration curve) evaluates how well the predicted probabilities of a probabilistic forecast system match the actual frequency of observed events.</p> <p>When to use: Use this diagram to assess the calibration of any probabilistic model (e.g., weather forecasts, machine learning classifiers). It helps determine if the model is overconfident, underconfident, or well-calibrated.</p> <p>How to read: *   X-axis: The forecast probability (often grouped into bins). *   Y-axis: The observed relative frequency of the event for each probability bin. *   1:1 Diagonal Line: Represents perfect reliability. If the model says there is a 70%     chance of an event, and it occurs 70% of the time, the point will fall on this line. *   Points below the line: Indicate over-forecasting or over-confidence (the predicted     probability is higher than the actual frequency). *   Points above the line: Indicate under-forecasting (the predicted probability is lower     than the actual frequency). *   Histogram/Inset: Often shows the sample frequency in each bin, providing context on     how much data supports each point.</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.reliability_diagram import ReliabilityDiagramPlot\n\n# 1. Prepare sample data\nnp.random.seed(42)  # for reproducibility\nn_samples = 1000\n\n# Simulate forecast probabilities (e.g., probability of rain)\nforecast_probabilities = np.random.rand(n_samples)\n\n# Simulate observations based on these probabilities (binary outcome)\n# Introduce some unreliability: forecasts are slightly overconfident at low probs, underconfident at high probs\nobservations = (\n    np.random.rand(n_samples) &lt; (forecast_probabilities * 0.8 + 0.1)\n).astype(int)\n\ndf = pd.DataFrame(\n    {\"forecast_prob\": forecast_probabilities, \"observed_event\": observations}\n)\n\n# 2. Initialize and create the plot\nplot = ReliabilityDiagramPlot(figsize=(8, 8))\nplot.plot(\n    df,\n    forecasts_col=\"forecast_prob\",\n    observations_col=\"observed_event\",\n    n_bins=10,\n    markersize=8,\n    color=\"blue\",\n    label=\"Forecast System\",\n)\n\n# 3. Add titles and labels\nplot.ax.set_title(\"Reliability Diagram for a Probabilistic Forecast\")\nplot.ax.legend(loc=\"upper left\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.379 seconds)</p> <p> Download Python source code: plot_reliability_diagram.py</p> <p> Download Jupyter notebook: plot_reliability_diagram.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_rev/","title":"Relative Economic Value Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_rev/#relative-economic-value-plot","title":"Relative Economic Value Plot","text":"<p>What it's for: The Relative Economic Value plot (also known as the Richardson plot) assesses the practical utility of a forecast system for a user who must make a decision based on a cost-loss ratio.</p> <p>When to use: Use this to move beyond purely statistical metrics and communicate the \"value\" of a model to stakeholders. It helps answer whether using the model's forecasts is better than simply relying on climatology or always taking a protective action.</p> <p>How to read: *   X-axis: The Cost/Loss (C/L) ratio of the user. This represents the cost of     taking action divided by the loss incurred if an event happens and no action was taken. *   Y-axis: Relative Economic Value (V). *   The Curve: Shows the value for each possible cost-loss ratio. *   Interpretation: A value of 1 represents a perfect forecast. A value of 0     means the forecast is no more valuable than simply using climatology. The     highest point on the curve indicates the cost-loss ratio for which the     forecast system is most beneficial.</p> <p></p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.rev import RelativeEconomicValuePlot\n\n# 1. Prepare sample data with contingency table counts\n# These counts represent the performance of a forecast system over many events\ndata = {\n    \"hits\": [100],\n    \"misses\": [20],\n    \"fa\": [30],  # False Alarms\n    \"cn\": [850],  # Correct Negatives\n}\ndf = pd.DataFrame(data)\n\n# Define the columns for hits, misses, false alarms, and correct negatives\ncontingency_cols = [\"hits\", \"misses\", \"fa\", \"cn\"]\n\n# 2. Initialize and create the plot\nplot = RelativeEconomicValuePlot(figsize=(10, 7))\nplot.plot(df, counts_cols=contingency_cols, color=\"blue\", linewidth=2)\n\n# 3. Add titles and labels\nplot.ax.set_title(\"Relative Economic Value of a Forecast System\")\nplot.ax.legend(loc=\"lower right\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.383 seconds)</p> <p> Download Python source code: plot_rev.py</p> <p> Download Jupyter notebook: plot_rev.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_ridgeline/","title":"Ridgeline Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_ridgeline/#ridgeline-plot","title":"Ridgeline Plot","text":"<p>What it's for: A Ridgeline plot (also known as a Joyplot) visualizes the distribution of a continuous variable across multiple groups by using partially overlapping density plots.</p> <p>When to use: Use this to compare how a distribution changes over time (e.g., daily profiles for each month) or across different experimental groups. It is more space-efficient and often easier to read than multiple overlapping histograms or KDE plots.</p> <p>How to read: *   X-axis: The value of the variable being measured. *   Y-axis: Represents different categories or groups. Each group has its own     Kernel Density Estimate (KDE). *   Interpretation: Look for shifts in the peak (mean/mode) or the width (spread)     of the distributions as you move from one group to another.</p> <p></p> <pre><code>import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.ridgeline import RidgelinePlot\n\n# 1. Prepare sample data\n# Grouped data for different categories\nnp.random.seed(42)\nn_points = 200\ncategories = [\"Group A\", \"Group B\", \"Group C\", \"Group D\"]\ndata = []\n\nfor i, cat in enumerate(categories):\n    values = np.random.normal(i * 2, 1.0, n_points)\n    df = pd.DataFrame({\"measurement\": values, \"group\": cat})\n    data.append(df)\n\ndf_all = pd.concat(data)\n\n# 2. Initialize and create the plot\n# RidgelinePlot(data, group_dim, x=None, ...)\nplot = RidgelinePlot(df_all, \"group\", x=\"measurement\", figsize=(10, 8))\nplot.plot(title=\"Ridgeline Plot of Different Groups\", cmap=\"viridis\")\n\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  2.234 seconds)</p> <p> Download Python source code: plot_ridgeline.py</p> <p> Download Jupyter notebook: plot_ridgeline.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_roc_curve/","title":"ROC Curve","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_roc_curve/#roc-curve","title":"ROC Curve","text":"<p>What it's for: The Receiver Operating Characteristic (ROC) curve evaluates the discrimination ability of a forecast system\u2014how well it can distinguish between an event occurring and not occurring. It is independent of bias and calibration.</p> <p>When to use: Use this curve to compare the overall skill of different models or to determine the optimal threshold for a binary classifier. It is a standard tool in both signal detection theory and meteorological verification.</p> <p>How to read: *   X-axis: Probability of False Detection (POFD) or False Alarm Rate. *   Y-axis: Probability of Detection (POD) or Hit Rate. *   The Curve: Each point on the curve represents a different decision threshold. *   Top-Left Corner: Represents a perfect forecast (POD = 1, POFD = 0). *   Diagonal Line: Represents a \"no-skill\" forecast, equivalent to random guessing. *   Area Under the Curve (AUC): A value of 1.0 indicates perfect discrimination, while     0.5 indicates no skill. The higher the AUC, the better the model's potential skill.</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.roc_curve import ROCCurvePlot\n\n# 1. Prepare sample data\nnp.random.seed(42)  # for reproducibility\n\n# Simulate POD and POFD values for different thresholds\n# A good model will have high POD for low POFD\nthresholds = np.linspace(0, 1, 50)\npod = 0.5 * (1 + np.tanh(5 * (thresholds - 0.5))) + np.random.normal(0, 0.05, 50)\npofd = thresholds + np.random.normal(0, 0.03, 50)\n\n# Ensure values are within [0, 1] and sorted for plotting\npod = np.clip(pod, 0, 1)\npofd = np.clip(pofd, 0, 1)\n\n# Sort by POFD to ensure correct curve plotting\ndf = (\n    pd.DataFrame({\"pofd\": pofd, \"pod\": pod})\n    .sort_values(by=\"pofd\")\n    .reset_index(drop=True)\n)\n\n# 2. Initialize and create the plot\nplot = ROCCurvePlot(figsize=(8, 8))\nplot.plot(df, x_col=\"pofd\", y_col=\"pod\", color=\"blue\", linewidth=2)\n\n# 3. Add titles and labels\nplot.ax.set_title(\"Receiver Operating Characteristic (ROC) Curve\")\n# Legend includes AUC automatically if show_auc=True (default)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.367 seconds)</p> <p> Download Python source code: plot_roc_curve.py</p> <p> Download Jupyter notebook: plot_roc_curve.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_scatter/","title":"Scatter Plot with Regression","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_scatter/#scatter-plot-with-regression","title":"Scatter Plot with Regression","text":"<p>What it's for: A Scatter Plot visualizes the relationship between two continuous variables. This implementation often includes a linear regression line to summarize the trend.</p> <p>When to use: Use this to assess the correlation between model output and observations, or to explore the relationship between two different physical variables (e.g., temperature vs. ozone concentration).</p> <p>How to read: *   X-axis: Typically the predictor or independent variable (e.g., Observations). *   Y-axis: Typically the response or dependent variable (e.g., Model). *   Regression Line: Shows the best-fit linear relationship. The slope and     intercept provide information about systematic bias and scaling. *   Interpretation: The tightness of the point cluster around the line indicates      the strength of the correlation. Points on the 1:1 diagonal would represent      a perfect match.</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.scatter import ScatterPlot\n\n# 1. Prepare sample data\nnp.random.seed(42)  # for reproducibility\nn_samples = 100\n\n# Simulate two correlated variables\nx_data = np.random.normal(loc=10, scale=2, size=n_samples)\ny_data = 0.7 * x_data + np.random.normal(loc=5, scale=1.5, size=n_samples)\n\ndf = pd.DataFrame({\"predictor\": x_data, \"response\": y_data})\n\n# 2. Initialize and create the plot\nplot = ScatterPlot(\n    df=df,\n    x=\"predictor\",\n    y=\"response\",\n    title=\"Scatter Plot of Response vs. Predictor\",\n    figsize=(9, 7),\n)\nplot.plot(\n    scatter_kws={\"alpha\": 0.7, \"s\": 60, \"edgecolor\": \"w\"},  # kwargs for scatter points\n    line_kws={\"color\": \"red\", \"linewidth\": 2},  # kwargs for regression line\n)\n\n# 3. Add titles and labels\nplot.ax.set_xlabel(\"Predictor Variable\")\nplot.ax.set_ylabel(\"Response Variable\")\nplot.ax.grid(True, linestyle=\"--\", alpha=0.6)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.327 seconds)</p> <p> Download Python source code: plot_scatter.py</p> <p> Download Jupyter notebook: plot_scatter.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_scorecard/","title":"Scorecard","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_scorecard/#scorecard","title":"Scorecard","text":"<p>What it's for: The Scorecard is a tabular visualization that provides a high-level overview of model performance across multiple variables, metrics, lead times, or locations. It uses color-coding to highlight areas of strength and weakness.</p> <p>When to use: Use this when you have a large number of performance statistics to present simultaneously. It is particularly effective for comparing a new model version against a baseline, or for identifying which meteorological variables or forecast horizons are most problematic.</p> <p>How to read: *   Rows/Columns: Represent different dimensions of the evaluation (e.g., Variable vs.     Forecast Lead Time). *   Cell Color: Indicates the performance level. Typically, a diverging colormap is     used where green represents improvement (or good performance) and red represents     degradation (or poor performance) relative to a benchmark. *   Interpretation: Look for patterns in the colors. For example, a whole row of red     might indicate a systemic issue with a specific variable, while a column of red might     indicate a drop in performance at a specific lead time.</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.scorecard import ScorecardPlot\n\n# 1. Prepare sample data in long format\nnp.random.seed(42)  # for reproducibility\n\nvariables = [\"Temperature\", \"Humidity\", \"Wind Speed\", \"Pressure\"]\nlead_times = [\"+06h\", \"+12h\", \"+18h\", \"+24h\", \"+36h\"]\n\ndata_list = []\nfor var in variables:\n    for lt in lead_times:\n        # Simulate a metric value (e.g., RMSE difference from baseline)\n        # Values around 0 mean similar performance, positive means worse, negative means better\n        metric_value = np.random.normal(loc=0, scale=0.5)\n        if var == \"Temperature\" and lt == \"+06h\":\n            metric_value = -1.2  # Example of good performance\n        elif var == \"Pressure\" and lt == \"+36h\":\n            metric_value = 1.5  # Example of poor performance\n\n        data_list.append(\n            {\"Variable\": var, \"Lead Time\": lt, \"Metric Value\": metric_value}\n        )\n\ndf = pd.DataFrame(data_list)\n\n# 2. Initialize and create the plot\nplot = ScorecardPlot(figsize=(10, 7))\nplot.plot(\n    df,\n    x_col=\"Lead Time\",\n    y_col=\"Variable\",\n    val_col=\"Metric Value\",\n    cmap=\"RdYlGn_r\",  # Red-Yellow-Green colormap, reversed so green is good (negative values)\n    center=0,  # Center the colormap at 0\n    linewidths=0.5,  # Add lines between cells\n    linecolor=\"black\",\n)\n\n# 3. Add titles and labels (plot.plot sets default title and labels)\nplot.ax.set_title(\"Model Performance Scorecard (RMSE Difference)\", fontsize=14)\nplot.ax.set_xlabel(\"Forecast Lead Time\")\nplot.ax.set_ylabel(\"Meteorological Variable\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.426 seconds)</p> <p> Download Python source code: plot_scorecard.py</p> <p> Download Jupyter notebook: plot_scorecard.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_soccer/","title":"Soccer Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_soccer/#soccer-plot","title":"Soccer Plot","text":"<p>What it's for: The Soccer Plot is a summary visualization tool used to evaluate model performance against predefined benchmarks. It is particularly popular in the air quality modeling community for comparing results from multiple sites, models, or time periods in a single view.</p> <p>When to use: Use this plot when you want to quickly communicate whether model performance meets specific standards (e.g., EPA or industry-standard \"Goals\" and \"Criteria\"). It is excellent for high-level summaries of large datasets.</p> <p>How to read: *   X-axis: Typically represents Mean Bias (MB) or Normalized Mean Bias (NMB). *   Y-axis: Typically represents Mean Error (ME) or Normalized Mean Error (NME). *   The \"Goal\" (Inner Rectangle): Represents the most stringent performance benchmark.     Points inside this box are considered excellent. *   The \"Criteria\" (Outer Rectangle): Represents a standard performance benchmark.     Points inside this box are considered acceptable. *   Interpretation: Ideally, points should cluster near the bottom-center of the plot     (low error, low bias), staying within the \"Goal\" or \"Criteria\" boxes.</p> <p></p> <p>Out:</p> <pre><code>Soccer plot saved to soccer_example.png\n</code></pre> <p></p> <pre><code>import pandas as pd\nfrom monet_plots.plots.soccer import SoccerPlot\n\n# Create dummy data\ndf = pd.DataFrame(\n    {\n        \"obs\": [10, 20, 30, 40],\n        \"mod\": [12, 18, 35, 38],\n        \"site\": [\"Site A\", \"Site B\", \"Site C\", \"Site D\"],\n    }\n)\n\n# Initialize Soccer Plot\nplot = SoccerPlot(\n    df,\n    obs_col=\"obs\",\n    mod_col=\"mod\",\n    label_col=\"site\",\n    goal={\"bias\": 20, \"error\": 40},\n    criteria={\"bias\": 40, \"error\": 60},\n)\n\n# Generate plot\nplot.plot()\nplot.save(\"soccer_example.png\")\nprint(\"Soccer plot saved to soccer_example.png\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.335 seconds)</p> <p> Download Python source code: plot_soccer.py</p> <p> Download Jupyter notebook: plot_soccer.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_sp_scatter_bias/","title":"Spatial Scatter Bias Plot (Alternative)","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_sp_scatter_bias/#spatial-scatter-bias-plot-alternative","title":"Spatial Scatter Bias Plot (Alternative)","text":"<p>What it's for: This plot (intended as an alternative to Spatial Bias Scatter) visualizes model bias at geographic locations.</p> <p>When to use: Use this to identify regional patterns in model errors, specifically comparing a reference dataset (observations) with a comparison dataset (model output) across a geographic domain.</p> <p>How to read: *   Markers: Represent data points at specific Latitude/Longitude coordinates. *   Color: Represents the bias (Comparison - Reference). *   Interpretation: Clusters of similar colors indicate regional systematic     biases in the comparison dataset.</p> <p>Note: This specific example is currently a placeholder for an alternative implementation.</p> <pre><code>import numpy as np\nimport pandas as pd\n# from monet_plots.plots.sp_scatter_bias import SpScatterBiasPlot\n\n# 1. Prepare sample data\nnp.random.seed(42)  # for reproducibility\nn_points = 500\n\n# Simulate random latitude and longitude points\nlat = np.random.uniform(20, 50, n_points)\nlon = np.random.uniform(-120, -70, n_points)\n\n# Simulate reference and comparison values\nreference_values = 10 + 5 * np.random.rand(n_points)\n# Introduce a spatial bias: higher values in the west, lower in the east\ncomparison_values = reference_values + (lon / 100 + np.random.normal(0, 0.5, n_points))\n\ndf = pd.DataFrame(\n    {\n        \"latitude\": lat,\n        \"longitude\": lon,\n        \"reference_value\": reference_values,\n        \"comparison_value\": comparison_values,\n    }\n)\n\n# 2. Initialize and create the plot\n# Example skipped: SpScatterBiasPlot module not found in this version.\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.001 seconds)</p> <p> Download Python source code: plot_sp_scatter_bias.py</p> <p> Download Jupyter notebook: plot_sp_scatter_bias.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_spatial/","title":"Spatial Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_spatial/#spatial-plot","title":"Spatial Plot","text":"<p>What it's for: The <code>SpatialPlot</code> class is a high-level wrapper for creating geographic maps with pre-configured styles, projections, and features (like coastlines and states).</p> <p>When to use: Use this for any plot that requires a map background. It serves as the base for more specialized spatial plots (like contours or scatter plots) but can be used standalone for custom map visualizations.</p> <p>How to read: *   Axes: Represents geographic space using a specific map projection (e.g.,     Plate Carr\u00e9e or Lambert Conformal). *   Colorbar: Shows the relationship between colors on the map and the data values. *   Interpretation: Allows for the visualization of the spatial extent and     gradients of a variable across a region.</p> <p></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.spatial import SpatialPlot\n\ndata = np.random.random((20, 30)) * 100\nplot = SpatialPlot(figsize=(10, 8))\nim = plot.ax.pcolormesh(data, cmap=\"viridis\", shading=\"auto\")\nplot.ax.set_title(\"Basic Spatial Plot\")\nplot.add_colorbar(im, label=\"Value\")\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.688 seconds)</p> <p> Download Python source code: plot_spatial.py</p> <p> Download Jupyter notebook: plot_spatial.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_spatial_bias_scatter/","title":"Spatial Bias Scatter Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_spatial_bias_scatter/#spatial-bias-scatter-plot","title":"Spatial Bias Scatter Plot","text":"<p>What it's for: The Spatial Bias Scatter plot visualizes model performance (specifically bias) at discrete point locations, such as air quality monitoring stations, on a geographic map.</p> <p>When to use: Use this to identify regional patterns in model errors. For example, it can reveal if a model consistently over-predicts in urban areas vs. rural areas, or if there is a systematic bias along a coastline.</p> <p>How to read: *   Markers: Each point on the map represents a specific location (e.g., a station). *   Marker Color: Typically represents the Mean Bias (Model - Observation). A     diverging colormap (e.g., Blue-White-Red) is often used where red indicates     over-prediction and blue indicates under-prediction. *   Interpretation: Look for geographic clusters of the same color, which     suggest localized systematic errors in the model.</p> <p></p> <pre><code>import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nfrom monet_plots.plots.spatial_bias_scatter import SpatialBiasScatterPlot\n\n# 1. Prepare sample data (CONUS region)\nn_points = 100\ndf = pd.DataFrame(\n    {\n        \"latitude\": np.random.uniform(30, 50, n_points),\n        \"longitude\": np.random.uniform(-125, -70, n_points),\n        \"obs\": np.random.uniform(0, 50, n_points),\n        \"model\": np.random.uniform(0, 50, n_points),\n    }\n)\n\n# 2. Initialize and plot with CONUS extent to match the data\n# Bias is calculated as col2 - col1\n# Set extent to [lon_min, lon_max, lat_min, lat_max] to match the data coverage\nplot = SpatialBiasScatterPlot(\n    df,\n    col1=\"obs\",\n    col2=\"model\",\n    projection=ccrs.PlateCarree(),\n    figsize=(10, 8),\n    extent=[-130, -65, 25, 55],  # CONUS extent\n    coastlines=True,\n    states=True,\n)\nplot.plot()\n\nplt.title(\"Spatial Bias Scatter Example\")\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.881 seconds)</p> <p> Download Python source code: plot_spatial_bias_scatter.py</p> <p> Download Jupyter notebook: plot_spatial_bias_scatter.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_spatial_contour/","title":"Spatial Contour Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_spatial_contour/#spatial-contour-plot","title":"Spatial Contour Plot","text":"<p>What it's for: A Spatial Contour plot visualizes continuous 2D fields (like temperature, pressure, or pollutant concentrations) as line or filled contours on a map.</p> <p>When to use: Use this to show the spatial distribution and gradients of a variable over a geographical region. It is ideal for identifying centers of high/low values and observing the overall structure of a field.</p> <p>How to read: *   Contours: Lines (or boundaries between colors) represent points of equal value. *   Color Scale: Indicates the magnitude of the variable in each region. *   Interpretation: Closely spaced contour lines indicate a steep gradient     (rapid change over distance), while widely spaced lines indicate a flat field.</p> <p></p> <p>Out:</p> <pre><code>/home/runner/work/monet-plots/monet-plots/src/monet_plots/plots/spatial_contour.py:118: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.\n  self.fig.tight_layout()\n</code></pre> <p></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.spatial_contour import SpatialContourPlot\n\n\n# 1. Create dummy data\nclass GridObj:\n    def __init__(self, lat, lon):\n        self.variables = {\n            \"LAT\": lat[np.newaxis, np.newaxis, :, :],\n            \"LON\": lon[np.newaxis, np.newaxis, :, :],\n        }\n\n\nlats = np.linspace(30, 50, 100)\nlons = np.linspace(-125, -70, 100)\nlon_grid, lat_grid = np.meshgrid(lons, lats)\ngridobj = GridObj(lat_grid, lon_grid)\n\n# Create a 2D variable to contour\ndata = np.sin(lat_grid / 10.0) * np.cos(lon_grid / 10.0)\n\n# 2. Initialize and plot\nplot = SpatialContourPlot(data, gridobj, figsize=(10, 8))\nplot.plot(levels=15, cmap=\"viridis\")\n\nplot.ax.set_title(\"Spatial Contour Example\")\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.284 seconds)</p> <p> Download Python source code: plot_spatial_contour.py</p> <p> Download Jupyter notebook: plot_spatial_contour.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_taylor_diagram/","title":"Taylor Diagram","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_taylor_diagram/#taylor-diagram","title":"Taylor Diagram","text":"<p>What it's for: The Taylor Diagram provides a concise statistical summary of how well a model (or multiple models) matches a reference dataset (usually observations). It summarizes three statistics in a single point: the correlation coefficient, the root-mean-square (RMS) error, and the standard deviation.</p> <p>When to use: Use this diagram to compare multiple models or different versions of the same model against a single set of observations. It is a standard tool in climate and meteorological model evaluation for assessing spatial or temporal patterns.</p> <p>How to read: *   Radial Distance from Origin: Represents the Standard Deviation of the data. *   Angular Coordinate (Arc): Represents the Pearson Correlation Coefficient (R). *   Distance from the Reference Point (on the X-axis): Represents the Centered     Root-Mean-Square (RMS) error. *   Interpretation: A perfect model would be represented by the \"Reference\" point     on the x-axis (Correlation = 1, same Standard Deviation as observations, RMS error = 0).     The closer a model's point is to the reference point, the better it matches the observations.</p> <p></p> <p>Out:</p> <pre><code>Reference std: 1.1750591258156107\n</code></pre> <p></p> <pre><code>import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.taylor_diagram import TaylorDiagramPlot\n\n# 1. Prepare model data\nnp.random.seed(42)\nn_points = 1000\nobs = np.random.normal(0, 1.2, n_points)\nmodel1 = 0.9 * obs + np.random.normal(0, 0.5, n_points)\nmodel2 = 0.7 * obs + np.random.normal(0, 0.8, n_points)\n\ndf = pd.DataFrame({\"obs\": obs, \"Model A\": model1, \"Model B\": model2})\n\n# 2. Initialize and create the plot\n# TaylorDiagramPlot calculates statistics from the DataFrame\nplot = TaylorDiagramPlot(df, col1=\"obs\", col2=[\"Model A\", \"Model B\"], scale=1.5)\nplot.plot()\n\nplt.title(\"Model Comparison Taylor Diagram\")\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.358 seconds)</p> <p> Download Python source code: plot_taylor_diagram.py</p> <p> Download Jupyter notebook: plot_taylor_diagram.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_timeseries/","title":"Time Series Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_timeseries/#time-series-plot","title":"Time Series Plot","text":"<p>What it's for: A Time Series plot visualizes how one or more variables change over a continuous temporal interval.</p> <p>When to use: Use this for monitoring data, model output at a specific location, or area-averaged values over time. It is the primary tool for identifying trends, diurnal cycles, seasonal patterns, and episodic events.</p> <p>How to read: *   X-axis: Represents Time (UTC or local). *   Y-axis: Represents the value of the variable. *   Interpretation: Look for temporal trends, variability, and the timing of     maximum/minimum values. Multiple lines can be used to compare models against     observations or different model scenarios.</p> <p></p> <pre><code>import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.timeseries import TimeSeriesPlot\n\ndates = pd.date_range(\"2023-01-01\", periods=100, freq=\"D\")\nvalues = np.cumsum(np.random.normal(0, 1, 100)) + 50\ndf = pd.DataFrame({\"time\": dates, \"values\": values})\nplot = TimeSeriesPlot(df=df, figsize=(12, 6))\nplot.plot(x=\"time\", y=\"values\", title=\"Daily Time Series\", ylabel=\"Temperature (\u00b0C)\")\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.421 seconds)</p> <p> Download Python source code: plot_timeseries.py</p> <p> Download Jupyter notebook: plot_timeseries.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_trajectory/","title":"Trajectory Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_trajectory/#trajectory-plot","title":"Trajectory Plot","text":"<p>What it's for: A Trajectory plot visualizes the path of a parcel of air or a mobile platform (e.g., aircraft, ship, or research balloon) over time. It typically combines a horizontal map view of the path with a time-series view of variables measured along that path.</p> <p>When to use: Use this when you need to understand the history of an air mass (back-trajectories) or visualize data collected by mobile sensors. It is essential for source-receptor analysis in air quality studies.</p> <p>How to read: *   Map View (Top/Main): Shows the geographic path (Longitude/Latitude). Markers or     colors along the path often represent time or a measured variable. *   Time-Series View (Bottom): Shows how one or more variables changed as the     platform moved along the trajectory. *   Interpretation: Allows you to correlate specific geographical locations or     events along the path with observed changes in the measured data.</p> <p></p> <p>Out:</p> <pre><code>Ignoring fixed x limits to fulfill fixed data aspect with adjustable data limits.\n/home/runner/work/monet-plots/monet-plots/src/monet_plots/plots/timeseries.py:151: UserWarning: The figure layout has changed to tight\n  self.fig.tight_layout()\n</code></pre> <p></p> <pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.trajectory import TrajectoryPlot\n\n# 1. Prepare sample data\nn_points = 50\ntime = pd.date_range(\"2023-01-01\", periods=n_points, freq=\"h\")\nlat = np.linspace(30, 40, n_points) + np.random.normal(0, 0.5, n_points)\nlon = np.linspace(-120, -110, n_points) + np.random.normal(0, 0.5, n_points)\ndata = np.sin(np.linspace(0, 5, n_points)) * 10 + 20\nts_data = data + np.random.normal(0, 2, n_points)\n\n# 2. Initialize and plot\n# TrajectoryPlot(longitude, latitude, data, time, ts_data, ...)\nplot = TrajectoryPlot(lon, lat, data, time, ts_data, figsize=(12, 6))\nplot.plot()\n\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.262 seconds)</p> <p> Download Python source code: plot_trajectory.py</p> <p> Download Jupyter notebook: plot_trajectory.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_upper_air/","title":"Upper Air Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_upper_air/#upper-air-plot","title":"Upper Air Plot","text":"<p>What it's for: An Upper Air plot is a standard meteorological visualization that combines geopotential height (represented as contours) and wind (represented as barbs) on a single map for a specific atmospheric pressure level.</p> <p>When to use: Use this to analyze the synoptic-scale weather patterns at various levels of the atmosphere (e.g., 850, 700, 500, or 250 hPa). It is essential for identifying ridges, troughs, jet streams, and other features that drive surface weather.</p> <p>How to read: *   Contours: Lines of equal geopotential height (similar to isobars on a     surface map). *   Wind Barbs: Indicate the wind direction and speed at specific points. *   Interpretation: The relationship between the height contours and the wind     barbs indicates the atmospheric flow. For example, in the mid-latitudes, the     wind typically flows roughly parallel to the height contours (geostrophic flow).</p> <p></p> <p>Out:</p> <pre><code>/home/runner/work/monet-plots/monet-plots/src/monet_plots/plots/spatial_contour.py:118: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.\n  self.fig.tight_layout()\n</code></pre> <p></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.upper_air import UpperAir\n\n# 1. Prepare sample data\nlats = np.linspace(30, 50, 20)\nlons = np.linspace(-125, -70, 30)\nhgt = np.random.uniform(5000, 6000, (20, 30))\nu = np.random.uniform(-20, 20, (20, 30))\nv = np.random.uniform(-20, 20, (20, 30))\n\n# 2. Initialize and plot\nplot = UpperAir(lat=lats, lon=lons, hgt=hgt, u=u, v=v, figsize=(10, 8))\nplot.plot()\n\nplt.title(\"Upper Air Example (500 hPa)\")\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.401 seconds)</p> <p> Download Python source code: plot_upper_air.py</p> <p> Download Jupyter notebook: plot_upper_air.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_wind_barbs/","title":"Wind Barbs Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_wind_barbs/#wind-barbs-plot","title":"Wind Barbs Plot","text":"<p>What it's for: A Wind Barbs plot uses standardized meteorological symbols to represent wind speed and direction at various points on a map.</p> <p>When to use: Use this when you need a clear, precise representation of wind speed categories and directions across a geographic region. It is the traditional way to display wind data on weather maps.</p> <p>How to read: *   The Staff: Points in the direction the wind is blowing from. *   The Barbs/Flags: Attached to the end of the staff. Each full barb     represents 10 units of speed (e.g., knots or m/s), a half-barb is 5 units,     and a pennant (flag) is 50 units. *   Interpretation: Allows you to quickly assess wind speed and direction     patterns, identifying features like wind shifts and areas of high wind speeds.</p> <p></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.wind_barbs import WindBarbsPlot\n\n\n# 1. Prepare sample data\nclass GridObj:\n    def __init__(self, lat, lon):\n        self.variables = {\n            \"LAT\": lat[np.newaxis, np.newaxis, :, :],\n            \"LON\": lon[np.newaxis, np.newaxis, :, :],\n        }\n\n\nlats = np.linspace(30, 50, 10)\nlons = np.linspace(-125, -70, 10)\nlon_grid, lat_grid = np.meshgrid(lons, lats)\ngridobj = GridObj(lat_grid, lon_grid)\n\nws = np.random.uniform(5, 50, (10, 10))\nwdir = np.random.uniform(0, 360, (10, 10))\n\n# 2. Initialize and plot\nplot = WindBarbsPlot(ws, wdir, gridobj, figsize=(10, 8))\nplot.plot()\n\nplt.title(\"Wind Barbs Example\")\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.096 seconds)</p> <p> Download Python source code: plot_wind_barbs.py</p> <p> Download Jupyter notebook: plot_wind_barbs.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_wind_quiver/","title":"Wind Quiver Plot","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_wind_quiver/#wind-quiver-plot","title":"Wind Quiver Plot","text":"<p>What it's for: A Wind Quiver plot uses arrows (vectors) to represent the wind flow field.</p> <p>When to use: Use this for an intuitive, visual representation of wind direction and speed. It is particularly effective for visualizing circulation patterns, such as vortices or the flow around geographic obstacles.</p> <p>How to read: *   The Arrow: Points in the direction the wind is blowing. *   Arrow Length/Color: Typically represents the magnitude of the wind speed. *   Interpretation: The density and orientation of the arrows provide a     snapshot of the overall wind velocity field.</p> <p></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.wind_quiver import WindQuiverPlot\n\n\n# 1. Prepare sample data\nclass GridObj:\n    def __init__(self, lat, lon):\n        self.variables = {\n            \"LAT\": lat[np.newaxis, np.newaxis, :, :],\n            \"LON\": lon[np.newaxis, np.newaxis, :, :],\n        }\n\n\nlats = np.linspace(30, 50, 20)\nlons = np.linspace(-125, -70, 20)\nlon_grid, lat_grid = np.meshgrid(lons, lats)\ngridobj = GridObj(lat_grid, lon_grid)\n\nws = np.random.uniform(5, 20, (20, 20))\nwdir = np.random.uniform(0, 360, (20, 20))\n\n# 2. Initialize and plot\nplot = WindQuiverPlot(ws, wdir, gridobj, figsize=(10, 8))\nplot.plot()\n\nplt.title(\"Wind Quiver Example\")\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.142 seconds)</p> <p> Download Python source code: plot_wind_quiver.py</p> <p> Download Jupyter notebook: plot_wind_quiver.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_windrose/","title":"Wind Rose","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_windrose/#wind-rose","title":"Wind Rose","text":"<p>What it's for: A Wind Rose is a graphical tool used by meteorologists to give a succinct view of how wind speed and direction are typically distributed at a particular location.</p> <p>When to use: Use this to characterize the wind climatology of a site. It is critical for siting wind turbines, designing airport runways, and understanding the dispersion of pollutants from a local source.</p> <p>How to read: *   Direction (Circular/Compass): The \"petals\" point toward the direction from which     the wind is blowing. *   Length of Petals: Indicates the frequency (percentage of time) the wind blows     from that direction. *   Color within Petals: Represents different wind speed categories (e.g., 0-2 m/s,     2-5 m/s, etc.). *   Interpretation: A long petal pointing North indicates that the wind frequently     blows from the North. The distribution of colors within that petal shows the     distribution of wind speeds for that specific direction.</p> <p></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom monet_plots.plots.windrose import Windrose\n\n# 1. Prepare sample data\nnp.random.seed(42)\nn_samples = 1000\nws = np.random.gamma(2, 2, n_samples)  # Wind speed\nwd = np.random.uniform(0, 360, n_samples)  # Wind direction\n\n# 2. Initialize and create the plot\nplot = Windrose(wd=wd, ws=ws, figsize=(8, 8))\nplot.plot()\n\nplt.title(\"Sample Windrose\")\nplt.show()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.544 seconds)</p> <p> Download Python source code: plot_windrose.py</p> <p> Download Jupyter notebook: plot_windrose.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"gallery/plot_xarray_integration/","title":"Xarray Integration","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"gallery/plot_xarray_integration/#xarray-integration","title":"Xarray Integration","text":"<p>What it's for: This example demonstrates how MONET Plots integrates directly with <code>xarray</code> data structures.</p> <p>When to use: Use this whenever your data is already stored in xarray <code>DataArray</code> or <code>Dataset</code> formats. MONET Plots will automatically leverage the coordinates and attributes (like <code>units</code>, <code>long_name</code>, and <code>standard_name</code>) to automate plot labeling and formatting.</p> <p>How to read: *   Axes/Labels: Notice that the axes labels and plot title are automatically     populated from the xarray metadata. *   Interpretation: The plot is interpreted according to its specific     visualization type (in this case, a Time Series), but with significantly     less manual configuration required.</p> <pre><code>import xarray as xr\nimport pandas as pd\nimport numpy as np\nfrom monet_plots.plots.timeseries import TimeSeriesPlot\n\n# Create sample xarray data\ndates = pd.date_range(\"2023-01-01\", periods=100, freq=\"h\")\ntemperature = (\n    15 + 5 * np.sin(np.arange(100) * 2 * np.pi / 24) + np.random.normal(0, 1, 100)\n)\n\nda = xr.DataArray(\n    temperature,\n    dims=[\"time\"],\n    coords={\"time\": dates},\n    name=\"temperature\",\n    attrs={\"units\": \"\u00b0C\", \"long_name\": \"Air Temperature\"},\n)\n\n# Create and plot\nplot = TimeSeriesPlot(\n    da,\n    x=\"time\",\n    y=\"temperature\",\n    title=\"Temperature Time Series\",\n    ylabel=\"Temperature (\u00b0C)\",\n)\nax = plot.plot()\nplot.save(\"temperature_timeseries.png\")\nplot.close()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.247 seconds)</p> <p> Download Python source code: plot_xarray_integration.py</p> <p> Download Jupyter notebook: plot_xarray_integration.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"performance/","title":"Performance Optimization Guide","text":"<p>Welcome to the MONET Plots performance optimization guide! This comprehensive resource will help you create efficient, fast, and scalable visualizations, especially when working with large datasets and complex plotting workflows.</p>"},{"location":"performance/#overview","title":"Overview","text":"<p>MONET Plots is designed with performance in mind, but large datasets and complex visualizations can still present challenges. This guide provides strategies and techniques to optimize your plotting performance.</p> Optimization Level Difficulty Focus Area Basic Optimization Beginner Quick wins for most users Memory Management Intermediate Large datasets and memory usage Rendering Optimization Advanced Plot generation speed Workflow Optimization Intermediate Multi-plot workflows"},{"location":"performance/#performance-principles","title":"Performance Principles","text":""},{"location":"performance/#1-downsample-when-possible","title":"1. Downsample When Possible","text":"<p>Reduce data points for interactive viewing while preserving important features.</p>"},{"location":"performance/#2-close-plots-properly","title":"2. Close Plots Properly","text":"<p>Always close plots when done to free memory resources.</p>"},{"location":"performance/#3-use-appropriate-data-types","title":"3. Use Appropriate Data Types","text":"<p>Choose the right data structure for your use case.</p>"},{"location":"performance/#4-batch-operations","title":"4. Batch Operations","text":"<p>Group similar operations together for efficiency.</p>"},{"location":"performance/#5-cache-results","title":"5. Cache Results","text":"<p>Save intermediate results to avoid recomputation.</p>"},{"location":"performance/#quick-start-basic-optimization","title":"Quick Start: Basic Optimization","text":"<pre><code>import numpy as np\nfrom monet_plots import SpatialPlot\n\n# Before: Full resolution\nlarge_data = np.random.random((1000, 1500))  # 1.5M points\nplot = SpatialPlot()\nplot.plot(large_data)  # Slow!\n\n# After: Downsampled\nsmall_data = large_data[::10, ::10]  # 15K points\nplot = SpatialPlot()\nplot.plot(small_data)  # Much faster!\n</code></pre>"},{"location":"performance/#performance-metrics","title":"Performance Metrics","text":"<p>Monitor these key performance indicators:</p> <ul> <li>Generation Time: Time to create the plot</li> <li>Memory Usage: RAM consumed during plotting</li> <li>File Size: Output file size</li> <li>Rendering Speed: Time to display or save</li> <li>Interactive Responsiveness: Performance in interactive environments</li> </ul>"},{"location":"performance/#navigation","title":"Navigation","text":"<ul> <li>Basic Optimization - Quick performance wins</li> <li>Memory Management - Handling large datasets</li> <li>Rendering Optimization - Fast plot generation</li> <li>Workflow Optimization - Efficient multi-plot workflows</li> <li>Benchmarking - Performance measurement and analysis</li> </ul>"},{"location":"performance/basic-optimization/","title":"Basic Optimization Techniques","text":"<p>Learn the fundamental optimization techniques that will give you the biggest performance improvements with minimal effort. These strategies are easy to implement and will significantly speed up your plotting workflows.</p>"},{"location":"performance/basic-optimization/#overview","title":"Overview","text":"<p>Basic optimization focuses on quick wins that provide immediate performance benefits without requiring complex changes to your code. These techniques are suitable for most users and will solve common performance bottlenecks.</p>"},{"location":"performance/basic-optimization/#key-benefits","title":"Key Benefits","text":"<ul> <li>Faster plot generation - Reduce wait times from minutes to seconds</li> <li>Lower memory usage - Handle larger datasets without crashing</li> <li>Better interactivity - Smoother interactive plotting</li> <li>Improved resource usage - More efficient CPU and RAM utilization</li> </ul>"},{"location":"performance/basic-optimization/#quick-wins","title":"Quick Wins","text":""},{"location":"performance/basic-optimization/#1-downsample-data-for-interactive-use","title":"1. Downsample Data for Interactive Use","text":"<p>Problem: Large datasets make interactive plotting slow and unresponsive.</p> <p>Solution: Downsample data for interactive viewing, use full resolution only for final exports.</p> <pre><code>import numpy as np\nfrom monet_plots import SpatialPlot\n\n# Before: Slow interactive plotting\nlarge_data = np.random.random((500, 500))  # 250K points\nplot = SpatialPlot()\nplot.plot(large_data)  # Takes several seconds\n\n# After: Fast interactive plotting\ndownsampled_data = large_data[::5, ::5]  # 10K points\nplot = SpatialPlot()\nplot.plot(downsampled_data)  # Takes fractions of a second\n</code></pre> <p>Downsampling Strategies:</p> <pre><code>import numpy as np\n\ndef smart_downsample(data, target_points=10000):\n    \"\"\"Intelligently downsample data to target point count.\"\"\"\n    total_points = np.prod(data.shape)\n\n    if total_points &lt;= target_points:\n        return data  # No downsampling needed\n\n    # Calculate downsampling factors\n    downsample_factor = int(np.sqrt(total_points / target_points))\n\n    # Apply downsampling\n    downsampled = data[::downsample_factor, ::downsample_factor]\n\n    return downsampled\n\n# Usage\ndata = np.random.random((1000, 1000))\nefficient_data = smart_downsample(data, target_points=25000)  # 40x40 grid\n</code></pre>"},{"location":"performance/basic-optimization/#2-close-plots-properly","title":"2. Close Plots Properly","text":"<p>Problem: Unclosed plots accumulate in memory, causing slowdowns and crashes.</p> <p>Solution: Always close plots when you're done with them.</p> <pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import TimeSeriesPlot\n\n# Problem: Memory leak\nfor i in range(10):\n    plot = TimeSeriesPlot()\n    plot.plot(df, x='time', y='value')\n    plot.save(f\"plot_{i}.png\")\n    # plot.close()  # Missing this line causes memory buildup!\n\n# Solution: Proper cleanup\nfor i in range(10):\n    plot = TimeSeriesPlot()\n    plot.plot(df, x='time', y='value')\n    plot.save(f\"plot_{i}.png\")\n    plot.close()  # Important: Free memory\n\n# Or use context manager for automatic cleanup\nfor i in range(10):\n    with TimeSeriesPlot() as plot:\n        plot.plot(df, x='time', y='value')\n        plot.save(f\"plot_{i}.png\")\n</code></pre>"},{"location":"performance/basic-optimization/#3-use-efficient-data-types","title":"3. Use Efficient Data Types","text":"<p>Problem: Using inefficient data types slows down operations.</p> <p>Solution: Choose appropriate data types for your data.</p> <pre><code>import numpy as np\nimport pandas as pd\n\n# Before: Inefficient data types\ndata_float64 = np.random.random((1000, 1000)).astype(np.float64)  # 8 bytes per element\nmemory_usage = data_float64.nbytes / (1024**2)  # ~7.6 MB\n\n# After: Optimized data types\ndata_float32 = np.random.random((1000, 1000)).astype(np.float32)  # 4 bytes per element\noptimized_memory = data_float32.nbytes / (1024**2)  # ~3.8 MB (50% reduction!)\n\nprint(f\"Memory saved: {memory_usage - optimized_memory:.2f} MB\")\n\n# For integer data\ndata_int64 = np.random.randint(0, 1000, (1000, 1000), dtype=np.int64)  # 8 bytes\ndata_int32 = np.random.randint(0, 1000, (1000, 1000), dtype=np.int32)  # 4 bytes\n</code></pre>"},{"location":"performance/basic-optimization/#4-limit-plot-elements","title":"4. Limit Plot Elements","text":"<p>Problem: Too many plot elements (markers, lines, text) slow rendering.</p> <p>Solution: Reduce the number of visual elements, especially for large datasets.</p> <pre><code>from monet_plots import ScatterPlot\n\n# Before: Too many markers\nn_points = 100000\nx = np.random.normal(0, 1, n_points)\ny = np.random.normal(0, 1, n_points)\n\nplot = ScatterPlot()\nplot.plot(pd.DataFrame({'x': x, 'y': y}), x='x', y='y')  # Slow with 100K points\n\n# After: Optimized scatter plot\n# Sample data for scatter plot\nsample_indices = np.random.choice(n_points, size=5000, replace=False)\nx_sampled = x[sample_indices]\ny_sampled = y[sample_indices]\n\nplot = ScatterPlot()\nplot.plot(pd.DataFrame({'x': x_sampled, 'y': y_sampled}), x='x', y='y')  # Much faster\n</code></pre>"},{"location":"performance/basic-optimization/#batch-operations","title":"Batch Operations","text":""},{"location":"performance/basic-optimization/#group-similar-operations","title":"Group Similar Operations","text":"<p>Problem: Individual plot operations are inefficient when repeated.</p> <p>Solution: Batch similar operations together.</p> <pre><code>from monet_plots import TimeSeriesPlot\nimport pandas as pd\n\n# Before: Individual plot creation (slow)\nfor month in range(1, 13):\n    plot = TimeSeriesPlot()\n    month_data = df[df['month'] == month]\n    plot.plot(month_data, x='date', y='value')\n    plot.save(f\"month_{month}.png\")\n    plot.close()\n\n# After: Batch processing (faster)\nplots_to_create = []\nfor month in range(1, 13):\n    plot = TimeSeriesPlot()\n    month_data = df[df['month'] == month]\n    plot.plot(month_data, x='date', y='value')\n    plots_to_create.append((plot, f\"month_{month}.png\"))\n\n# Save all plots at once\nfor plot, filename in plots_to_create:\n    plot.save(filename)\n    plot.close()\n</code></pre>"},{"location":"performance/basic-optimization/#pre-computation","title":"Pre-computation","text":"<p>Problem: Repeated calculations slow down multiple plots.</p> <p>Solution: Pre-compute common calculations.</p> <pre><code>import numpy as np\nfrom monet_plots import SpatialPlot\n\n# Before: Repeated calculations (slow)\nfor i in range(5):\n    data = np.random.random((100, 100))\n    plot = SpatialPlot()\n    plot.plot(data, title=f\"Plot {i+1}\")\n    plot.save(f\"plot_{i+1}.png\")\n    plot.close()\n\n# After: Pre-computation (faster)\n# Generate all data first\nall_data = [np.random.random((100, 100)) for _ in range(5)]\n\n# Create plots with pre-computed data\nfor i, data in enumerate(all_data):\n    plot = SpatialPlot()\n    plot.plot(data, title=f\"Plot {i+1}\")\n    plot.save(f\"plot_{i+1}.png\")\n    plot.close()\n</code></pre>"},{"location":"performance/basic-optimization/#efficient-color-mapping","title":"Efficient Color Mapping","text":""},{"location":"performance/basic-optimization/#use-discrete-colorbars-for-large-data","title":"Use Discrete Colorbars for Large Data","text":"<p>Problem: Continuous colorbars with many data points are slow.</p> <p>Solution: Use discrete colorbars for large datasets.</p> <pre><code>from monet_plots import SpatialPlot\nimport numpy as np\n\n# Large dataset\nlarge_data = np.random.random((200, 200)) * 100\n\n# Before: Continuous colorbar (slow)\nplot = SpatialPlot()\nplot.plot(large_data, discrete=False)  # Continuous colorbar\n\n# After: Discrete colorbar (fast)\nplot = SpatialPlot()\nplot.plot(large_data, discrete=True, ncolors=20)  # Discrete colorbar\n</code></pre>"},{"location":"performance/basic-optimization/#optimize-colormap-selection","title":"Optimize Colormap Selection","text":"<p>Problem: Some colormaps are computationally more expensive than others.</p> <p>Solution: Use efficient colormaps.</p> <pre><code>from monet_plots import SpatialPlot\nimport numpy as np\n\ndata = np.random.random((100, 100))\n\n# Fast colormaps\nfast_colormaps = ['viridis', 'plasma', 'inferno', 'magma', 'cividis']\nslow_colormaps = ['jet', 'rainbow', 'gist_rainbow']\n\n# Use fast colormaps for better performance\nplot = SpatialPlot()\nplot.plot(data, cmap='viridis')  # Fast\nplot.save(\"fast_colormap.png\")\n\n# Avoid slow colormaps\n# plot = SpatialPlot()\n# plot.plot(data, cmap='jet')  # Slow - avoid for large datasets\n</code></pre>"},{"location":"performance/basic-optimization/#interactive-optimization","title":"Interactive Optimization","text":""},{"location":"performance/basic-optimization/#enable-interactive-mode","title":"Enable Interactive Mode","text":"<p>Problem: Plots may not respond well to interactive commands.</p> <p>Solution: Enable interactive mode for better responsiveness.</p> <pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import TimeSeriesPlot\n\n# Enable interactive mode\nplt.ion()\n\n# Create interactive plot\nplot = TimeSeriesPlot()\nplot.plot(df, x='time', y='value')\n\n# Plot will update immediately when modified\nplot.title(\"Interactive Plot\")\nplt.draw()  # Force update\n</code></pre>"},{"location":"performance/basic-optimization/#use-aggressive-redrawing","title":"Use Aggressive Redrawing","text":"<p>Problem: Interactive plots may be slow to update.</p> <p>Solution: Control redrawing behavior.</p> <pre><code># Turn off interactive updates during batch operations\nplt.ioff()\n\n# Perform multiple operations\nplot = TimeSeriesPlot()\nplot.plot(df, x='time', y='value')\nplot.title(\"Batch Update\")\nplot.xlabel(\"Custom Label\")\n\n# Turn interactive updates back on\nplt.ion()\n\n# Force a single redraw\nplt.draw()\n</code></pre>"},{"location":"performance/basic-optimization/#memory-optimization","title":"Memory Optimization","text":""},{"location":"performance/basic-optimization/#use-memory-efficient-data-structures","title":"Use Memory-Efficient Data Structures","text":"<p>Problem: Large pandas DataFrames consume excessive memory.</p> <p>Solution: Use appropriate data types in pandas.</p> <pre><code>import pandas as pd\nimport numpy as np\n\n# Before: Memory-inefficient DataFrame\nn_rows = 1_000_000\nlarge_df = pd.DataFrame({\n    'id': range(n_rows),\n    'value': np.random.random(n_rows),\n    'category': np.random.choice(['A', 'B', 'C'], n_rows)\n})\n\nprint(f\"Memory usage: {large_df.memory_usage(deep=True).sum() / 1024**2:.2f} MB\")\n\n# After: Memory-optimized DataFrame\noptimized_df = pd.DataFrame({\n    'id': pd.Series(range(n_rows), dtype='int32'),\n    'value': pd.Series(np.random.random(n_rows), dtype='float32'),\n    'category': pd.Series(np.random.choice(['A', 'B', 'C'], n_rows), dtype='category')\n})\n\nprint(f\"Optimized memory: {optimized_df.memory_usage(deep=True).sum() / 1024**2:.2f} MB\")\n</code></pre>"},{"location":"performance/basic-optimization/#process-data-in-chunks","title":"Process Data in Chunks","text":"<p>Problem: Loading and processing large datasets at once is memory-intensive.</p> <p>Solution: Process data in manageable chunks.</p> <pre><code>from monet_plots import SpatialPlot\nimport numpy as np\n\n# Before: Load all data at once\n# huge_data = np.load('huge_dataset.npy')  # May cause memory issues\n# plot = SpatialPlot()\n# plot.plot(huge_data)  # Memory intensive\n\n# After: Process in chunks\nchunk_size = 1000\ntotal_size = 5000\n\nfor i in range(0, total_size, chunk_size):\n    chunk = np.random.random((chunk_size, chunk_size))\n    plot = SpatialPlot()\n    plot.plot(chunk, title=f\"Chunk {i//chunk_size + 1}\")\n    plot.save(f\"chunk_{i//chunk_size + 1}.png\")\n    plot.close()\n</code></pre>"},{"location":"performance/basic-optimization/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"performance/basic-optimization/#simple-timing","title":"Simple Timing","text":"<pre><code>import time\nfrom monet_plots import SpatialPlot\nimport numpy as np\n\n# Simple timing\nstart_time = time.time()\n\ndata = np.random.random((100, 100))\nplot = SpatialPlot()\nplot.plot(data)\nplot.save(\"timed_plot.png\")\nplot.close()\n\nend_time = time.time()\nprint(f\"Plot creation took {end_time - start_time:.2f} seconds\")\n</code></pre>"},{"location":"performance/basic-optimization/#memory-usage-monitoring","title":"Memory Usage Monitoring","text":"<pre><code>import psutil\nimport os\nfrom monet_plots import SpatialPlot\nimport numpy as np\n\ndef get_memory_usage():\n    \"\"\"Get current memory usage in MB.\"\"\"\n    process = psutil.Process(os.getpid())\n    return process.memory_info().rss / (1024 * 1024)\n\n# Monitor memory usage\ninitial_memory = get_memory_usage()\nprint(f\"Initial memory: {initial_memory:.2f} MB\")\n\n# Create plot\ndata = np.random.random((500, 500))\nplot = SpatialPlot()\nplot.plot(data)\nplot.save(\"monitored_plot.png\")\nplot.close()\n\nfinal_memory = get_memory_usage()\nprint(f\"Final memory: {final_memory:.2f} MB\")\nprint(f\"Memory used: {final_memory - initial_memory:.2f} MB\")\n</code></pre>"},{"location":"performance/basic-optimization/#common-optimization-patterns","title":"Common Optimization Patterns","text":""},{"location":"performance/basic-optimization/#pattern-1-lazy-loading","title":"Pattern 1: Lazy Loading","text":"<pre><code>def create_plot_with_lazy_loading(data_source, plot_config):\n    \"\"\"Create plot with lazy data loading.\"\"\"\n    # Load only necessary data\n    data = load_data_lazily(data_source)\n\n    # Configure plot\n    plot = SpatialPlot(**plot_config)\n\n    # Plot and save\n    plot.plot(data)\n    plot.save(\"lazy_loaded_plot.png\")\n    plot.close()\n</code></pre>"},{"location":"performance/basic-optimization/#pattern-2-caching","title":"Pattern 2: Caching","text":"<pre><code>from functools import lru_cache\nimport numpy as np\n\n@lru_cache(maxsize=10)\ndef generate_cached_data(shape, seed):\n    \"\"\"Cache generated data to avoid recomputation.\"\"\"\n    np.random.seed(seed)\n    return np.random.random(shape)\n\n# Usage\ndata1 = generate_cached_data((100, 100), 42)  # First call - computes\ndata2 = generate_cached_data((100, 100), 42)  # Second call - cached\n</code></pre>"},{"location":"performance/basic-optimization/#pattern-3-batch-processing","title":"Pattern 3: Batch Processing","text":"<pre><code>def batch_create_plots(data_list, plot_configs):\n    \"\"\"Create multiple plots efficiently.\"\"\"\n    # Pre-process all data\n    processed_data = [process_data(data) for data in data_list]\n\n    # Create all plots\n    plots = []\n    for data, config in zip(processed_data, plot_configs):\n        plot = SpatialPlot(**config)\n        plot.plot(data)\n        plots.append(plot)\n\n    # Save all plots\n    for i, plot in enumerate(plots):\n        plot.save(f\"batch_plot_{i}.png\")\n        plot.close()\n</code></pre>"},{"location":"performance/basic-optimization/#practice-exercises","title":"Practice Exercises","text":""},{"location":"performance/basic-optimization/#exercise-1-data-downsampling","title":"Exercise 1: Data Downsampling","text":"<p>Take a large dataset and implement smart downsampling to achieve a target performance level.</p>"},{"location":"performance/basic-optimization/#exercise-2-memory-cleanup","title":"Exercise 2: Memory Cleanup","text":"<p>Create a script that generates multiple plots and ensures proper memory cleanup.</p>"},{"location":"performance/basic-optimization/#exercise-3-batch-processing","title":"Exercise 3: Batch Processing","text":"<p>Implement batch processing for creating time series plots for multiple months.</p>"},{"location":"performance/basic-optimization/#exercise-4-interactive-optimization","title":"Exercise 4: Interactive Optimization","text":"<p>Optimize an interactive plotting workflow for real-time data updates.</p>"},{"location":"performance/basic-optimization/#exercise-5-performance-monitoring","title":"Exercise 5: Performance Monitoring","text":"<p>Add performance monitoring to your existing plotting scripts.</p>"},{"location":"performance/basic-optimization/#troubleshooting","title":"Troubleshooting","text":""},{"location":"performance/basic-optimization/#issue-1-still-slow-after-optimization","title":"Issue 1: Still Slow After Optimization","text":"<pre><code># Profile your code to find bottlenecks\nimport cProfile\nimport pstats\n\ndef profile_plot_creation():\n    data = np.random.random((100, 100))\n    plot = SpatialPlot()\n    plot.plot(data)\n    plot.save(\"profiled_plot.png\")\n    plot.close()\n\n# Run profiler\nprofiler = cProfile.Profile()\nprofiler.enable()\nprofile_plot_creation()\nprofiler.disable()\n\n# Print statistics\nstats = pstats.Stats(profiler)\nstats.sort_stats('cumulative')\nstats.print_stats(10)  # Show top 10 time-consuming functions\n</code></pre>"},{"location":"performance/basic-optimization/#issue-2-memory-not-released","title":"Issue 2: Memory Not Released","text":"<pre><code># Force garbage collection\nimport gc\n\n# After creating plots\nplot.close()\ndel plot\ngc.collect()  # Force garbage collection\n</code></pre>"},{"location":"performance/basic-optimization/#issue-3-interactive-plots-unresponsive","title":"Issue 3: Interactive Plots Unresponsive","text":"<pre><code># Check interactive mode\nimport matplotlib.pyplot as plt\nprint(f\"Interactive mode: {plt.isinteractive()}\")\n\n# Enable if needed\nplt.ion()\n\n# Turn off blitting for complex plots\nplot = SpatialPlot()\nplot.plot(data)\nplot.ax.set_title('Interactive Plot', blit=False)\n</code></pre>"},{"location":"performance/basic-optimization/#next-steps","title":"Next Steps","text":"<p>After mastering basic optimization, explore:</p> <ol> <li>Memory Management - Advanced memory optimization techniques</li> <li>Rendering Optimization - Fine-tune plot generation speed</li> <li>Workflow Optimization - Optimize multi-plot workflows</li> <li>Benchmarking - Measure and compare performance</li> </ol>"},{"location":"performance/basic-optimization/#quick-reference","title":"Quick Reference","text":"Optimization Technique Impact Downsampling <code>data[::factor, ::factor]</code> High Plot Closing <code>plot.close()</code> High Data Types <code>float32</code> instead of <code>float64</code> Medium Batch Operations Group similar operations Medium Colorbars Use discrete for large data Medium Colormaps Choose efficient colormaps Low <p>Navigation:</p> <ul> <li>Performance Index - All performance guides</li> <li>Memory Management - Advanced memory optimization</li> <li>Rendering Optimization - Fast plot generation</li> <li>Workflow Optimization - Multi-plot workflows</li> <li>Benchmarking - Performance measurement</li> </ul>"},{"location":"plots/","title":"Plot Types Documentation","text":""},{"location":"plots/#overview","title":"Overview","text":"<p>This document serves as the central index for all available Verification Plots within the MONET Plots system. These plots are specifically designed to evaluate model forecast quality against observations across various statistical and spatial domains. They provide critical insights into bias, reliability, skill, and resolution, adhering to best practices in meteorological and statistical verification.</p> <p>For detailed instructions on each plot's usage, customization, and underlying methodology, refer to the individual documentation pages listed below.</p>"},{"location":"plots/#available-verification-plots","title":"Available Verification Plots","text":"<p>The following verification plots are available. Each link directs to a page detailing its usage, configuration, and interpretation.</p> Plot Name Description Documentation Link <code>WindQuiverPlot</code> Wind vector arrows indicating direction and magnitude. <code>Wind Quiver</code> <code>WindBarbsPlot</code> Conventional meteorological wind barbs. <code>Wind Barbs</code> <code>CurtainPlot</code> Vertical cross-section (altitude vs time/distance). <code>Vertical Curtain Plot</code> <code>DiurnalErrorPlot</code> Heat map of model error by hour of day. <code>Diurnal Error Plot</code> <code>FingerprintPlot</code> Temporal patterns across two different scales. <code>Fingerprint Plot</code> <code>BivariatePolarPlot</code> Dependence on wind speed and direction. <code>Bivariate Polar Plot</code> <code>ProfilePlot</code> Vertical atmospheric profiles. <code>Profile Plot</code>"},{"location":"plots/#usage-and-style-guidelines","title":"Usage and Style Guidelines","text":"<p>All plot classes follow the same core structure:</p> <ol> <li>Initialization: Instantiate the plot class (e.g., <code>TimeSeriesPlot(df, ...)</code>).</li> <li>Plotting: Call the main <code>.plot()</code> method.</li> <li>Customization: Use methods like <code>.ax.set_title()</code> or global configuration.</li> <li>Output: Save the figure using <code>.save()</code> and close with <code>.close()</code>.</li> </ol> <p>For more details on styling, please see the Configuration Guide.</p>"},{"location":"plots/base/","title":"Base Plot","text":"<p>Base class for all plots, ensuring a consistent interface and style.</p>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot","title":"<code>BasePlot</code>","text":"<p>Base class for all plots.</p> <p>Handles figure and axis creation, applies a consistent style, and provides a common interface for saving and closing plots.</p> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>class BasePlot:\n    \"\"\"Base class for all plots.\n\n    Handles figure and axis creation, applies a consistent style,\n    and provides a common interface for saving and closing plots.\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, style: str | None = \"wiley\", **kwargs):\n        \"\"\"Initializes the plot with a consistent style.\n\n        If `fig` and `ax` are not provided, a new figure and axes\n        are created.\n\n        Args:\n            fig (matplotlib.figure.Figure, optional): Figure to plot on.\n            ax (matplotlib.axes.Axes, optional): Axes to plot on.\n            style (str, optional): Style name to apply (e.g., 'wiley', 'paper').\n                If None, no style is applied. Defaults to 'wiley'.\n            **kwargs: Additional keyword arguments for `plt.subplots`.\n        \"\"\"\n        if style:\n            set_style(style)\n\n        if ax is not None:\n            self.ax = ax\n            if fig is not None:\n                self.fig = fig\n            else:\n                self.fig = ax.figure\n        elif fig is not None:\n            self.fig = fig\n            self.ax = None\n        else:\n            self.fig, self.ax = plt.subplots(**kwargs)\n\n    def save(self, filename, **kwargs):\n        \"\"\"Saves the plot to a file.\n\n        Args:\n            filename (str): The name of the file to save the plot to.\n            **kwargs: Additional keyword arguments for `savefig`.\n        \"\"\"\n        self.fig.savefig(filename, **kwargs)\n\n    def close(self):\n        \"\"\"Closes the plot figure.\"\"\"\n        plt.close(self.fig)\n\n    def add_logo(\n        self,\n        logo: str | Any | None = None,\n        *,\n        ax: matplotlib.axes.Axes | None = None,\n        loc: str = \"upper right\",\n        scale: float = 0.1,\n        pad: float = 0.05,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Adds a logo to the plot.\n\n        Parameters\n        ----------\n        logo : str or array-like, optional\n            Path to the logo image, a URL, or a numpy array.\n            If None, the default MONET logo is used.\n        ax : matplotlib.axes.Axes, optional\n            The axes to add the logo to. Defaults to `self.ax`.\n        loc : str, optional\n            Location of the logo ('upper right', 'upper left', 'lower right',\n            'lower left', 'center'). Defaults to \"upper right\".\n        scale : float, optional\n            Scaling factor for the logo, by default 0.1.\n        pad : float, optional\n            Padding from the edge of the axes, by default 0.05.\n        **kwargs : Any\n            Additional keyword arguments passed to `AnnotationBbox`.\n\n        Returns\n        -------\n        matplotlib.offsetbox.AnnotationBbox\n            The added logo object.\n        \"\"\"\n        import matplotlib.image as mpimg\n        from matplotlib.offsetbox import OffsetImage, AnnotationBbox\n        from ..plot_utils import get_logo_path\n\n        if ax is None:\n            ax = self.ax\n\n        if logo is None:\n            logo = get_logo_path()\n\n        if isinstance(logo, str):\n            if logo.startswith(\"http\"):\n                import urllib.request\n                import io\n\n                with urllib.request.urlopen(logo) as url:\n                    f = io.BytesIO(url.read())\n                img = mpimg.imread(f)\n            else:\n                img = mpimg.imread(logo)\n        else:\n            img = logo\n\n        imagebox = OffsetImage(img, zoom=scale)\n        imagebox.image.axes = ax\n\n        # Mapping of location strings to axes fraction coordinates and box alignment\n        loc_map = {\n            \"upper right\": ((1 - pad, 1 - pad), (1, 1)),\n            \"upper left\": ((pad, 1 - pad), (0, 1)),\n            \"lower right\": ((1 - pad, pad), (1, 0)),\n            \"lower left\": ((pad, pad), (0, 0)),\n            \"center\": ((0.5, 0.5), (0.5, 0.5)),\n        }\n\n        if loc in loc_map:\n            xy, box_alignment = loc_map[loc]\n        else:\n            # If loc is not a string in loc_map, assume it might be a coordinate\n            # tuple, but for simplicity we default to upper right if it's invalid\n            if isinstance(loc, tuple) and len(loc) == 2:\n                xy = loc\n                box_alignment = (0.5, 0.5)\n            else:\n                xy, box_alignment = loc_map[\"upper right\"]\n\n        ab = AnnotationBbox(\n            imagebox,\n            xy,\n            xycoords=\"axes fraction\",\n            box_alignment=box_alignment,\n            pad=0,\n            frameon=False,\n            **kwargs,\n        )\n\n        ax.add_artist(ab)\n        return ab\n\n    def add_colorbar(\n        self,\n        mappable: matplotlib.cm.ScalarMappable,\n        *,\n        ax: matplotlib.axes.Axes | None = None,\n        label: str | None = None,\n        loc: str = \"right\",\n        size: str = \"5%\",\n        pad: float = 0.05,\n        **kwargs: Any,\n    ) -&gt; matplotlib.colorbar.Colorbar:\n        \"\"\"Add a colorbar that matches the axes size.\n\n        This method uses `inset_axes` to ensure the colorbar height (or width)\n        matches the axes dimensions exactly, which is particularly useful for\n        geospatial plots with fixed aspects.\n\n        Parameters\n        ----------\n        mappable : matplotlib.cm.ScalarMappable\n            The mappable object (e.g., from imshow, scatter, contourf).\n        ax : matplotlib.axes.Axes, optional\n            The axes to attach the colorbar to. Defaults to `self.ax`.\n        label : str, optional\n            Label for the colorbar, by default None.\n        loc : str, optional\n            Location of the colorbar ('right', 'left', 'top', 'bottom'),\n            by default \"right\".\n        size : str, optional\n            Width (if vertical) or height (if horizontal) of the colorbar,\n            as a percentage of the axes, by default \"5%\".\n        pad : float, optional\n            Padding between the axes and the colorbar, by default 0.05.\n        **kwargs : Any\n            Additional keyword arguments passed to `fig.colorbar`.\n\n        Returns\n        -------\n        matplotlib.colorbar.Colorbar\n            The created colorbar object.\n        \"\"\"\n        from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\n        if ax is None:\n            ax = self.ax\n\n        orientation = \"vertical\" if loc in [\"right\", \"left\"] else \"horizontal\"\n\n        # Determine anchor and position based on location\n        if loc == \"right\":\n            bbox_to_anchor = (1.0 + pad, 0.0, 1.0, 1.0)\n            width, height = size, \"100%\"\n        elif loc == \"left\":\n            bbox_to_anchor = (-(float(size.strip(\"%\")) / 100.0 + pad), 0.0, 1.0, 1.0)\n            width, height = size, \"100%\"\n        elif loc == \"top\":\n            bbox_to_anchor = (0.0, 1.0 + pad, 1.0, 1.0)\n            width, height = \"100%\", size\n        else:  # bottom\n            bbox_to_anchor = (0.0, -(float(size.strip(\"%\")) / 100.0 + pad), 1.0, 1.0)\n            width, height = \"100%\", size\n\n        cax = inset_axes(\n            ax,\n            width=width,\n            height=height,\n            loc=\"lower left\",\n            bbox_to_anchor=bbox_to_anchor,\n            bbox_transform=ax.transAxes,\n            borderpad=0,\n        )\n\n        cb = self.fig.colorbar(mappable, cax=cax, orientation=orientation, **kwargs)\n\n        if label:\n            cb.set_label(label)\n\n        return cb\n</code></pre>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot.__init__","title":"<code>__init__(fig=None, ax=None, style='wiley', **kwargs)</code>","text":"<p>Initializes the plot with a consistent style.</p> <p>If <code>fig</code> and <code>ax</code> are not provided, a new figure and axes are created.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figure to plot on.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>Axes to plot on.</p> <code>None</code> <code>style</code> <code>str</code> <p>Style name to apply (e.g., 'wiley', 'paper'). If None, no style is applied. Defaults to 'wiley'.</p> <code>'wiley'</code> <code>**kwargs</code> <p>Additional keyword arguments for <code>plt.subplots</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def __init__(self, fig=None, ax=None, style: str | None = \"wiley\", **kwargs):\n    \"\"\"Initializes the plot with a consistent style.\n\n    If `fig` and `ax` are not provided, a new figure and axes\n    are created.\n\n    Args:\n        fig (matplotlib.figure.Figure, optional): Figure to plot on.\n        ax (matplotlib.axes.Axes, optional): Axes to plot on.\n        style (str, optional): Style name to apply (e.g., 'wiley', 'paper').\n            If None, no style is applied. Defaults to 'wiley'.\n        **kwargs: Additional keyword arguments for `plt.subplots`.\n    \"\"\"\n    if style:\n        set_style(style)\n\n    if ax is not None:\n        self.ax = ax\n        if fig is not None:\n            self.fig = fig\n        else:\n            self.fig = ax.figure\n    elif fig is not None:\n        self.fig = fig\n        self.ax = None\n    else:\n        self.fig, self.ax = plt.subplots(**kwargs)\n</code></pre>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot.add_colorbar","title":"<code>add_colorbar(mappable, *, ax=None, label=None, loc='right', size='5%', pad=0.05, **kwargs)</code>","text":"<p>Add a colorbar that matches the axes size.</p> <p>This method uses <code>inset_axes</code> to ensure the colorbar height (or width) matches the axes dimensions exactly, which is particularly useful for geospatial plots with fixed aspects.</p>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot.add_colorbar--parameters","title":"Parameters","text":"<p>mappable : matplotlib.cm.ScalarMappable     The mappable object (e.g., from imshow, scatter, contourf). ax : matplotlib.axes.Axes, optional     The axes to attach the colorbar to. Defaults to <code>self.ax</code>. label : str, optional     Label for the colorbar, by default None. loc : str, optional     Location of the colorbar ('right', 'left', 'top', 'bottom'),     by default \"right\". size : str, optional     Width (if vertical) or height (if horizontal) of the colorbar,     as a percentage of the axes, by default \"5%\". pad : float, optional     Padding between the axes and the colorbar, by default 0.05. **kwargs : Any     Additional keyword arguments passed to <code>fig.colorbar</code>.</p>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot.add_colorbar--returns","title":"Returns","text":"<p>matplotlib.colorbar.Colorbar     The created colorbar object.</p> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def add_colorbar(\n    self,\n    mappable: matplotlib.cm.ScalarMappable,\n    *,\n    ax: matplotlib.axes.Axes | None = None,\n    label: str | None = None,\n    loc: str = \"right\",\n    size: str = \"5%\",\n    pad: float = 0.05,\n    **kwargs: Any,\n) -&gt; matplotlib.colorbar.Colorbar:\n    \"\"\"Add a colorbar that matches the axes size.\n\n    This method uses `inset_axes` to ensure the colorbar height (or width)\n    matches the axes dimensions exactly, which is particularly useful for\n    geospatial plots with fixed aspects.\n\n    Parameters\n    ----------\n    mappable : matplotlib.cm.ScalarMappable\n        The mappable object (e.g., from imshow, scatter, contourf).\n    ax : matplotlib.axes.Axes, optional\n        The axes to attach the colorbar to. Defaults to `self.ax`.\n    label : str, optional\n        Label for the colorbar, by default None.\n    loc : str, optional\n        Location of the colorbar ('right', 'left', 'top', 'bottom'),\n        by default \"right\".\n    size : str, optional\n        Width (if vertical) or height (if horizontal) of the colorbar,\n        as a percentage of the axes, by default \"5%\".\n    pad : float, optional\n        Padding between the axes and the colorbar, by default 0.05.\n    **kwargs : Any\n        Additional keyword arguments passed to `fig.colorbar`.\n\n    Returns\n    -------\n    matplotlib.colorbar.Colorbar\n        The created colorbar object.\n    \"\"\"\n    from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\n    if ax is None:\n        ax = self.ax\n\n    orientation = \"vertical\" if loc in [\"right\", \"left\"] else \"horizontal\"\n\n    # Determine anchor and position based on location\n    if loc == \"right\":\n        bbox_to_anchor = (1.0 + pad, 0.0, 1.0, 1.0)\n        width, height = size, \"100%\"\n    elif loc == \"left\":\n        bbox_to_anchor = (-(float(size.strip(\"%\")) / 100.0 + pad), 0.0, 1.0, 1.0)\n        width, height = size, \"100%\"\n    elif loc == \"top\":\n        bbox_to_anchor = (0.0, 1.0 + pad, 1.0, 1.0)\n        width, height = \"100%\", size\n    else:  # bottom\n        bbox_to_anchor = (0.0, -(float(size.strip(\"%\")) / 100.0 + pad), 1.0, 1.0)\n        width, height = \"100%\", size\n\n    cax = inset_axes(\n        ax,\n        width=width,\n        height=height,\n        loc=\"lower left\",\n        bbox_to_anchor=bbox_to_anchor,\n        bbox_transform=ax.transAxes,\n        borderpad=0,\n    )\n\n    cb = self.fig.colorbar(mappable, cax=cax, orientation=orientation, **kwargs)\n\n    if label:\n        cb.set_label(label)\n\n    return cb\n</code></pre>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot.add_logo","title":"<code>add_logo(logo=None, *, ax=None, loc='upper right', scale=0.1, pad=0.05, **kwargs)</code>","text":"<p>Adds a logo to the plot.</p>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot.add_logo--parameters","title":"Parameters","text":"<p>logo : str or array-like, optional     Path to the logo image, a URL, or a numpy array.     If None, the default MONET logo is used. ax : matplotlib.axes.Axes, optional     The axes to add the logo to. Defaults to <code>self.ax</code>. loc : str, optional     Location of the logo ('upper right', 'upper left', 'lower right',     'lower left', 'center'). Defaults to \"upper right\". scale : float, optional     Scaling factor for the logo, by default 0.1. pad : float, optional     Padding from the edge of the axes, by default 0.05. **kwargs : Any     Additional keyword arguments passed to <code>AnnotationBbox</code>.</p>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot.add_logo--returns","title":"Returns","text":"<p>matplotlib.offsetbox.AnnotationBbox     The added logo object.</p> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def add_logo(\n    self,\n    logo: str | Any | None = None,\n    *,\n    ax: matplotlib.axes.Axes | None = None,\n    loc: str = \"upper right\",\n    scale: float = 0.1,\n    pad: float = 0.05,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Adds a logo to the plot.\n\n    Parameters\n    ----------\n    logo : str or array-like, optional\n        Path to the logo image, a URL, or a numpy array.\n        If None, the default MONET logo is used.\n    ax : matplotlib.axes.Axes, optional\n        The axes to add the logo to. Defaults to `self.ax`.\n    loc : str, optional\n        Location of the logo ('upper right', 'upper left', 'lower right',\n        'lower left', 'center'). Defaults to \"upper right\".\n    scale : float, optional\n        Scaling factor for the logo, by default 0.1.\n    pad : float, optional\n        Padding from the edge of the axes, by default 0.05.\n    **kwargs : Any\n        Additional keyword arguments passed to `AnnotationBbox`.\n\n    Returns\n    -------\n    matplotlib.offsetbox.AnnotationBbox\n        The added logo object.\n    \"\"\"\n    import matplotlib.image as mpimg\n    from matplotlib.offsetbox import OffsetImage, AnnotationBbox\n    from ..plot_utils import get_logo_path\n\n    if ax is None:\n        ax = self.ax\n\n    if logo is None:\n        logo = get_logo_path()\n\n    if isinstance(logo, str):\n        if logo.startswith(\"http\"):\n            import urllib.request\n            import io\n\n            with urllib.request.urlopen(logo) as url:\n                f = io.BytesIO(url.read())\n            img = mpimg.imread(f)\n        else:\n            img = mpimg.imread(logo)\n    else:\n        img = logo\n\n    imagebox = OffsetImage(img, zoom=scale)\n    imagebox.image.axes = ax\n\n    # Mapping of location strings to axes fraction coordinates and box alignment\n    loc_map = {\n        \"upper right\": ((1 - pad, 1 - pad), (1, 1)),\n        \"upper left\": ((pad, 1 - pad), (0, 1)),\n        \"lower right\": ((1 - pad, pad), (1, 0)),\n        \"lower left\": ((pad, pad), (0, 0)),\n        \"center\": ((0.5, 0.5), (0.5, 0.5)),\n    }\n\n    if loc in loc_map:\n        xy, box_alignment = loc_map[loc]\n    else:\n        # If loc is not a string in loc_map, assume it might be a coordinate\n        # tuple, but for simplicity we default to upper right if it's invalid\n        if isinstance(loc, tuple) and len(loc) == 2:\n            xy = loc\n            box_alignment = (0.5, 0.5)\n        else:\n            xy, box_alignment = loc_map[\"upper right\"]\n\n    ab = AnnotationBbox(\n        imagebox,\n        xy,\n        xycoords=\"axes fraction\",\n        box_alignment=box_alignment,\n        pad=0,\n        frameon=False,\n        **kwargs,\n    )\n\n    ax.add_artist(ab)\n    return ab\n</code></pre>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot.close","title":"<code>close()</code>","text":"<p>Closes the plot figure.</p> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def close(self):\n    \"\"\"Closes the plot figure.\"\"\"\n    plt.close(self.fig)\n</code></pre>"},{"location":"plots/base/#monet_plots.plots.base.BasePlot.save","title":"<code>save(filename, **kwargs)</code>","text":"<p>Saves the plot to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save the plot to.</p> required <code>**kwargs</code> <p>Additional keyword arguments for <code>savefig</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/base.py</code> <pre><code>def save(self, filename, **kwargs):\n    \"\"\"Saves the plot to a file.\n\n    Args:\n        filename (str): The name of the file to save the plot to.\n        **kwargs: Additional keyword arguments for `savefig`.\n    \"\"\"\n    self.fig.savefig(filename, **kwargs)\n</code></pre>"},{"location":"plots/brier_decomposition/","title":"Brier Decomposition","text":""},{"location":"plots/brier_decomposition/#monet_plots.plots.brier_decomposition.BrierScoreDecompositionPlot","title":"<code>BrierScoreDecompositionPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Brier Score Decomposition Plot.</p> <p>Visualizes the components of the Brier Score: Reliability, Resolution, and Uncertainty. BS = Reliability - Resolution + Uncertainty</p> Source code in <code>src/monet_plots/plots/brier_decomposition.py</code> <pre><code>class BrierScoreDecompositionPlot(BasePlot):\n    \"\"\"\n    Brier Score Decomposition Plot.\n\n    Visualizes the components of the Brier Score: Reliability,\n    Resolution, and Uncertainty.\n    BS = Reliability - Resolution + Uncertainty\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        reliability_col: str = \"reliability\",\n        resolution_col: str = \"resolution\",\n        uncertainty_col: str = \"uncertainty\",\n        forecasts_col: Optional[str] = None,\n        observations_col: Optional[str] = None,\n        n_bins: int = 10,\n        label_col: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data: Input data.\n            reliability_col/resolution_col/uncertainty_col (str):\n                Pre-computed component columns.\n            forecasts_col/observations_col (str, optional):\n                Raw forecast probabilities and binary observations.\n            n_bins (int): Bins for decomposition if raw data.\n            label_col (str, optional): Grouping column.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        title = kwargs.pop(\"title\", \"Brier Score Decomposition\")\n        df = to_dataframe(data)\n        # Compute components if raw data provided\n        if forecasts_col and observations_col:\n            components_list = []\n            if label_col:\n                for name, group in df.groupby(label_col):\n                    comps = compute_brier_score_components(\n                        np.asarray(group[forecasts_col]),\n                        np.asarray(group[observations_col]),\n                        n_bins,\n                    )\n                    row = pd.Series(comps)\n                    row[\"model\"] = str(name)\n                    components_list.append(row)\n            else:\n                comps = compute_brier_score_components(\n                    np.asarray(df[forecasts_col]),\n                    np.asarray(df[observations_col]),\n                    n_bins,\n                )\n                row = pd.Series(comps)\n                row[\"model\"] = \"Model\"\n                components_list.append(row)\n\n            df_plot = pd.DataFrame(components_list)\n            plot_label_col = \"model\"\n        else:\n            required_cols = [reliability_col, resolution_col, uncertainty_col]\n            validate_dataframe(df, required_columns=required_cols)\n            df_plot = df\n            plot_label_col = label_col\n\n        # Prepare for plotting: make resolution negative for visualization\n        df_plot = df_plot.copy()\n        df_plot[\"resolution_plot\"] = -df_plot[resolution_col]\n\n        # Grouped bar plot\n        if plot_label_col:\n            labels = df_plot[plot_label_col].astype(str)\n        else:\n            labels = df_plot.index.astype(str)\n\n        x = np.arange(len(labels))\n        width = 0.25\n\n        self.ax.bar(\n            x - width,\n            df_plot[reliability_col],\n            width,\n            label=\"Reliability\",\n            color=\"red\",\n            alpha=0.8,\n            **kwargs,\n        )\n        self.ax.bar(\n            x,\n            df_plot[\"resolution_plot\"],\n            width,\n            label=\"Resolution (-)\",\n            color=\"green\",\n            alpha=0.8,\n            **kwargs,\n        )\n        self.ax.bar(\n            x + width,\n            df_plot[uncertainty_col],\n            width,\n            label=\"Uncertainty\",\n            color=\"blue\",\n            alpha=0.8,\n            **kwargs,\n        )\n\n        # Total Brier Score as line on top if available\n        if \"brier_score\" in df_plot.columns:\n            self.ax.plot(\n                x,\n                df_plot[\"brier_score\"],\n                \"ko-\",\n                linewidth=2,\n                markersize=6,\n                label=\"Brier Score\",\n            )\n\n        self.ax.set_xticks(x)\n        self.ax.set_xticklabels(labels, rotation=45, ha=\"right\")\n        self.ax.legend(loc=\"best\")\n        self.ax.set_ylabel(\"Brier Score Components\")\n        self.ax.set_title(title)\n        self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"plots/brier_decomposition/#monet_plots.plots.brier_decomposition.BrierScoreDecompositionPlot.plot","title":"<code>plot(data, reliability_col='reliability', resolution_col='resolution', uncertainty_col='uncertainty', forecasts_col=None, observations_col=None, n_bins=10, label_col=None, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data.</p> required <code>reliability_col/resolution_col/uncertainty_col</code> <code>str</code> <p>Pre-computed component columns.</p> required <code>forecasts_col/observations_col</code> <code>str</code> <p>Raw forecast probabilities and binary observations.</p> required <code>n_bins</code> <code>int</code> <p>Bins for decomposition if raw data.</p> <code>10</code> <code>label_col</code> <code>str</code> <p>Grouping column.</p> <code>None</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/brier_decomposition.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    reliability_col: str = \"reliability\",\n    resolution_col: str = \"resolution\",\n    uncertainty_col: str = \"uncertainty\",\n    forecasts_col: Optional[str] = None,\n    observations_col: Optional[str] = None,\n    n_bins: int = 10,\n    label_col: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data: Input data.\n        reliability_col/resolution_col/uncertainty_col (str):\n            Pre-computed component columns.\n        forecasts_col/observations_col (str, optional):\n            Raw forecast probabilities and binary observations.\n        n_bins (int): Bins for decomposition if raw data.\n        label_col (str, optional): Grouping column.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    title = kwargs.pop(\"title\", \"Brier Score Decomposition\")\n    df = to_dataframe(data)\n    # Compute components if raw data provided\n    if forecasts_col and observations_col:\n        components_list = []\n        if label_col:\n            for name, group in df.groupby(label_col):\n                comps = compute_brier_score_components(\n                    np.asarray(group[forecasts_col]),\n                    np.asarray(group[observations_col]),\n                    n_bins,\n                )\n                row = pd.Series(comps)\n                row[\"model\"] = str(name)\n                components_list.append(row)\n        else:\n            comps = compute_brier_score_components(\n                np.asarray(df[forecasts_col]),\n                np.asarray(df[observations_col]),\n                n_bins,\n            )\n            row = pd.Series(comps)\n            row[\"model\"] = \"Model\"\n            components_list.append(row)\n\n        df_plot = pd.DataFrame(components_list)\n        plot_label_col = \"model\"\n    else:\n        required_cols = [reliability_col, resolution_col, uncertainty_col]\n        validate_dataframe(df, required_columns=required_cols)\n        df_plot = df\n        plot_label_col = label_col\n\n    # Prepare for plotting: make resolution negative for visualization\n    df_plot = df_plot.copy()\n    df_plot[\"resolution_plot\"] = -df_plot[resolution_col]\n\n    # Grouped bar plot\n    if plot_label_col:\n        labels = df_plot[plot_label_col].astype(str)\n    else:\n        labels = df_plot.index.astype(str)\n\n    x = np.arange(len(labels))\n    width = 0.25\n\n    self.ax.bar(\n        x - width,\n        df_plot[reliability_col],\n        width,\n        label=\"Reliability\",\n        color=\"red\",\n        alpha=0.8,\n        **kwargs,\n    )\n    self.ax.bar(\n        x,\n        df_plot[\"resolution_plot\"],\n        width,\n        label=\"Resolution (-)\",\n        color=\"green\",\n        alpha=0.8,\n        **kwargs,\n    )\n    self.ax.bar(\n        x + width,\n        df_plot[uncertainty_col],\n        width,\n        label=\"Uncertainty\",\n        color=\"blue\",\n        alpha=0.8,\n        **kwargs,\n    )\n\n    # Total Brier Score as line on top if available\n    if \"brier_score\" in df_plot.columns:\n        self.ax.plot(\n            x,\n            df_plot[\"brier_score\"],\n            \"ko-\",\n            linewidth=2,\n            markersize=6,\n            label=\"Brier Score\",\n        )\n\n    self.ax.set_xticks(x)\n    self.ax.set_xticklabels(labels, rotation=45, ha=\"right\")\n    self.ax.legend(loc=\"best\")\n    self.ax.set_ylabel(\"Brier Score Components\")\n    self.ax.set_title(title)\n    self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"plots/categorical/","title":"Categorical Plots","text":""},{"location":"plots/categorical/#monet_plots.plots.categorical.categorical_plot","title":"<code>categorical_plot(data, *, kind='bar', col_wrap=3, figsize=(15, 8), title=None, legend='auto', legend_labels=None, xlabel=None, ylabel=None, sharey=True, **kwargs)</code>","text":"<p>Make a categorical plot (bar or violin).</p>"},{"location":"plots/categorical/#monet_plots.plots.categorical.categorical_plot--parameters","title":"Parameters","text":"<p>data : xarray.Dataset or xarray.DataArray     Data to be plotted. kind : str, optional     Type of plot, 'bar' or 'violin', by default 'bar'. col_wrap : int, optional     Number of columns for subplot grid, by default 3. figsize : tuple, optional     Figure size, by default (15, 8). title : str, optional     Plot title, by default None. legend : str, optional     Legend type, by default \"auto\". legend_labels : list of str, optional     Legend labels, by default None. xlabel : str, optional     X-axis label, by default None. ylabel : str, optional     Y-axis label, by default None. sharey : bool, optional     Whether to share the y-axis, by default True. **kwargs     Additional keyword arguments passed to seaborn.catplot().</p>"},{"location":"plots/categorical/#monet_plots.plots.categorical.categorical_plot--returns","title":"Returns","text":"<p>fig, ax     Matplotlib figure and axes objects.</p> Source code in <code>src/monet_plots/plots/categorical.py</code> <pre><code>def categorical_plot(\n    data,\n    *,\n    kind=\"bar\",\n    col_wrap=3,\n    figsize=(15, 8),\n    title=None,\n    legend=\"auto\",\n    legend_labels=None,\n    xlabel=None,\n    ylabel=None,\n    sharey=True,\n    **kwargs,\n):\n    \"\"\"Make a categorical plot (bar or violin).\n\n    Parameters\n    ----------\n    data : xarray.Dataset or xarray.DataArray\n        Data to be plotted.\n    kind : str, optional\n        Type of plot, 'bar' or 'violin', by default 'bar'.\n    col_wrap : int, optional\n        Number of columns for subplot grid, by default 3.\n    figsize : tuple, optional\n        Figure size, by default (15, 8).\n    title : str, optional\n        Plot title, by default None.\n    legend : str, optional\n        Legend type, by default \"auto\".\n    legend_labels : list of str, optional\n        Legend labels, by default None.\n    xlabel : str, optional\n        X-axis label, by default None.\n    ylabel : str, optional\n        Y-axis label, by default None.\n    sharey : bool, optional\n        Whether to share the y-axis, by default True.\n    **kwargs\n        Additional keyword arguments passed to seaborn.catplot().\n\n    Returns\n    -------\n    fig, ax\n        Matplotlib figure and axes objects.\n    \"\"\"\n    if \"x\" not in kwargs or \"y\" not in kwargs:\n        raise ValueError(\"x and y must be provided as keyword arguments\")\n\n    if isinstance(data, xr.DataArray) and data.name is None:\n        data.name = kwargs[\"y\"]\n\n    df = data.to_dataframe().reset_index()\n\n    from .. import style\n\n    col = \"site\" if \"site\" in df else None\n    with plt.style.context(style.wiley_style):\n        p = sns.catplot(\n            data=df,\n            kind=kind,\n            col=col,\n            col_wrap=col_wrap if col is not None else None,\n            sharey=sharey,\n            **kwargs,\n        )\n        p.fig.set_size_inches(figsize)\n\n        if title is not None:\n            p.fig.suptitle(title)\n\n        if ylabel is not None:\n            p.axes.flatten()[0].set_ylabel(ylabel)\n        if xlabel is not None:\n            p.axes.flatten()[0].set_xlabel(xlabel)\n\n        if legend == \"auto\":\n            if \"hue\" in kwargs:\n                legend = True\n            else:\n                legend = False\n\n        if legend is True:\n            if isinstance(legend_labels, list) and len(legend_labels) &gt; 0:\n                # To be implemented: custom legend labels\n                pass\n            # Seaborn handles legend automatically when using 'hue'\n            pass\n\n    return p.fig, p.axes\n</code></pre>"},{"location":"plots/categorical/#monet_plots.plots.categorical.categorical_timeseries","title":"<code>categorical_timeseries(data, **kwargs)</code>","text":"<p>Make a timeseries of categorical plots.</p> <p>(Placeholder for future implementation)</p> Source code in <code>src/monet_plots/plots/categorical.py</code> <pre><code>def categorical_timeseries(data, **kwargs):\n    \"\"\"Make a timeseries of categorical plots.\n\n    (Placeholder for future implementation)\n    \"\"\"\n    raise NotImplementedError(\"Categorical timeseries plots are not yet implemented.\")\n</code></pre>"},{"location":"plots/conditional_bias/","title":"Conditional Bias","text":""},{"location":"plots/conditional_bias/#monet_plots.plots.conditional_bias.ConditionalBiasPlot","title":"<code>ConditionalBiasPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Conditional Bias Plot.</p> <p>Visualizes the Bias (Forecast - Observation) as a function of the Observed Value. Supports native Xarray/Dask objects and interactive visualization.</p> Source code in <code>src/monet_plots/plots/conditional_bias.py</code> <pre><code>class ConditionalBiasPlot(BasePlot):\n    \"\"\"\n    Conditional Bias Plot.\n\n    Visualizes the Bias (Forecast - Observation) as a function of the Observed Value.\n    Supports native Xarray/Dask objects and interactive visualization.\n    \"\"\"\n\n    def __init__(self, data: Optional[Any] = None, fig=None, ax=None, **kwargs):\n        \"\"\"\n        Initializes the plot.\n\n        Parameters\n        ----------\n        data : Any, optional\n            The input data (Dataset, DataArray, DataFrame, or ndarray).\n        fig : matplotlib.figure.Figure, optional\n            Figure to plot on.\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot on.\n        **kwargs : Any\n            Additional keyword arguments for the figure.\n        \"\"\"\n        super().__init__(fig=fig, ax=ax, **kwargs)\n        self.data = normalize_data(data) if data is not None else None\n\n    def plot(\n        self,\n        data: Optional[Any] = None,\n        obs_col: Optional[str] = None,\n        fcst_col: Optional[str] = None,\n        n_bins: int = 10,\n        label: str = \"Model\",\n        label_col: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Generates the static Matplotlib plot.\n\n        Parameters\n        ----------\n        data : Any, optional\n            Input data, overrides self.data if provided.\n        obs_col : str, optional\n            Name of the observation variable. Required for Dataset/DataFrame.\n        fcst_col : str, optional\n            Name of the forecast variable. Required for Dataset/DataFrame.\n        n_bins : int, optional\n            Number of bins for observed values, by default 10.\n        label : str, optional\n            Label for the model data, by default \"Model\".\n        label_col : str, optional\n            Column name to group by for plotting multiple lines.\n        **kwargs : Any\n            Additional Matplotlib plotting arguments passed to `errorbar`.\n\n        Returns\n        -------\n        matplotlib.axes.Axes\n            The axes object containing the plot.\n        \"\"\"\n        plot_data = normalize_data(data) if data is not None else self.data\n        if plot_data is None:\n            raise ValueError(\"No data provided.\")\n\n        try:\n            if label_col:\n                # Handle grouping for multiple models/categories\n                for name, group in plot_data.groupby(label_col):\n                    obs = group[obs_col]\n                    mod = group[fcst_col]\n                    self._plot_single(obs, mod, n_bins, label=str(name), **kwargs)\n            else:\n                # Single model plot\n                if isinstance(plot_data, xr.Dataset):\n                    obs = plot_data[obs_col]\n                    mod = plot_data[fcst_col]\n                elif isinstance(plot_data, xr.DataArray):\n                    mod = plot_data\n                    obs = kwargs.pop(\"obs\", None)\n                    if obs is None:\n                        raise ValueError(\"obs must be provided if data is a DataArray.\")\n                elif isinstance(plot_data, pd.DataFrame):\n                    obs = plot_data[obs_col]\n                    mod = plot_data[fcst_col]\n                else:\n                    # Should have been normalized\n                    raise TypeError(f\"Unsupported data type: {type(plot_data)}\")\n\n                self._plot_single(obs, mod, n_bins, label=label, **kwargs)\n        except KeyError as e:\n            raise ValueError(f\"Required column not found: {e}\") from e\n\n        self.ax.axhline(0, color=\"k\", linestyle=\"--\", linewidth=1.5, alpha=0.7)\n        xlabel = (\n            plot_data[obs_col].attrs.get(\"long_name\", obs_col)\n            if obs_col\n            else \"Observed Value\"\n        )\n        self.ax.set_xlabel(xlabel)\n        self.ax.set_ylabel(\"Mean Bias (Forecast - Observation)\")\n        self.ax.legend()\n        return self.ax\n\n    def _plot_single(self, obs, mod, n_bins, label, **kwargs):\n        \"\"\"Helper to plot a single binned bias line.\"\"\"\n        stats = compute_binned_bias(obs, mod, n_bins=n_bins)\n        pdf = stats.compute().dropna(dim=\"bin_center\")\n\n        # Filter for count &gt; 1 to avoid showing bins with only one sample (no std dev)\n        pdf = pdf.where(pdf.bias_count &gt; 1, drop=True)\n\n        if pdf.bin_center.size &gt; 0:\n            self.ax.errorbar(\n                pdf.bin_center,\n                pdf.bias_mean,\n                yerr=pdf.bias_std,\n                fmt=\"o-\",\n                capsize=5,\n                label=label,\n                **kwargs,\n            )\n\n    def hvplot(\n        self,\n        data: Optional[Any] = None,\n        obs_col: Optional[str] = None,\n        fcst_col: Optional[str] = None,\n        n_bins: int = 10,\n        label_col: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Generates an interactive plot using hvPlot.\n\n        Parameters\n        ----------\n        data : Any, optional\n            Input data, overrides self.data if provided.\n        obs_col : str, optional\n            Name of the observation variable.\n        fcst_col : str, optional\n            Name of the forecast variable.\n        n_bins : int, optional\n            Number of bins, by default 10.\n        label_col : str, optional\n            Column name to group by.\n        **kwargs : Any\n            Additional hvPlot arguments.\n\n        Returns\n        -------\n        holoviews.core.Element\n            The interactive plot.\n        \"\"\"\n        import holoviews as hv\n        import hvplot.xarray  # noqa: F401\n\n        plot_data = normalize_data(data) if data is not None else self.data\n        if plot_data is None:\n            raise ValueError(\"No data provided.\")\n\n        if label_col:\n\n            def get_stats(group):\n                return compute_binned_bias(\n                    group[obs_col], group[fcst_col], n_bins=n_bins\n                ).compute()\n\n            # We compute per group for the visualization summary\n            stats_list = []\n            for name, group in plot_data.groupby(label_col):\n                s = get_stats(group)\n                s = s.assign_coords({label_col: name}).expand_dims(label_col)\n                stats_list.append(s)\n            pdf = xr.concat(stats_list, dim=label_col).dropna(dim=\"bin_center\")\n            by = label_col\n        else:\n            if isinstance(plot_data, xr.Dataset):\n                obs = plot_data[obs_col]\n                mod = plot_data[fcst_col]\n            elif isinstance(plot_data, pd.DataFrame):\n                obs = plot_data[obs_col]\n                mod = plot_data[fcst_col]\n            else:\n                mod = plot_data\n                obs = kwargs.pop(\"obs\")\n            pdf = compute_binned_bias(obs, mod, n_bins=n_bins).compute()\n            pdf = pdf.dropna(dim=\"bin_center\")\n            by = None\n\n        xlabel = (\n            plot_data[obs_col].attrs.get(\"long_name\", obs_col)\n            if obs_col\n            else \"Observed Value\"\n        )\n\n        plot = pdf.hvplot.scatter(\n            x=\"bin_center\",\n            y=\"bias_mean\",\n            by=by,\n            xlabel=xlabel,\n            ylabel=\"Mean Bias\",\n            **kwargs,\n        ) * pdf.hvplot.errorbars(x=\"bin_center\", y=\"bias_mean\", yerr1=\"bias_std\", by=by)\n\n        # Add zero line\n        plot *= hv.HLine(0).opts(color=\"black\", line_dash=\"dashed\")\n\n        return plot\n</code></pre>"},{"location":"plots/conditional_bias/#monet_plots.plots.conditional_bias.ConditionalBiasPlot.__init__","title":"<code>__init__(data=None, fig=None, ax=None, **kwargs)</code>","text":"<p>Initializes the plot.</p>"},{"location":"plots/conditional_bias/#monet_plots.plots.conditional_bias.ConditionalBiasPlot.__init__--parameters","title":"Parameters","text":"<p>data : Any, optional     The input data (Dataset, DataArray, DataFrame, or ndarray). fig : matplotlib.figure.Figure, optional     Figure to plot on. ax : matplotlib.axes.Axes, optional     Axes to plot on. **kwargs : Any     Additional keyword arguments for the figure.</p> Source code in <code>src/monet_plots/plots/conditional_bias.py</code> <pre><code>def __init__(self, data: Optional[Any] = None, fig=None, ax=None, **kwargs):\n    \"\"\"\n    Initializes the plot.\n\n    Parameters\n    ----------\n    data : Any, optional\n        The input data (Dataset, DataArray, DataFrame, or ndarray).\n    fig : matplotlib.figure.Figure, optional\n        Figure to plot on.\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot on.\n    **kwargs : Any\n        Additional keyword arguments for the figure.\n    \"\"\"\n    super().__init__(fig=fig, ax=ax, **kwargs)\n    self.data = normalize_data(data) if data is not None else None\n</code></pre>"},{"location":"plots/conditional_bias/#monet_plots.plots.conditional_bias.ConditionalBiasPlot.hvplot","title":"<code>hvplot(data=None, obs_col=None, fcst_col=None, n_bins=10, label_col=None, **kwargs)</code>","text":"<p>Generates an interactive plot using hvPlot.</p>"},{"location":"plots/conditional_bias/#monet_plots.plots.conditional_bias.ConditionalBiasPlot.hvplot--parameters","title":"Parameters","text":"<p>data : Any, optional     Input data, overrides self.data if provided. obs_col : str, optional     Name of the observation variable. fcst_col : str, optional     Name of the forecast variable. n_bins : int, optional     Number of bins, by default 10. label_col : str, optional     Column name to group by. **kwargs : Any     Additional hvPlot arguments.</p>"},{"location":"plots/conditional_bias/#monet_plots.plots.conditional_bias.ConditionalBiasPlot.hvplot--returns","title":"Returns","text":"<p>holoviews.core.Element     The interactive plot.</p> Source code in <code>src/monet_plots/plots/conditional_bias.py</code> <pre><code>def hvplot(\n    self,\n    data: Optional[Any] = None,\n    obs_col: Optional[str] = None,\n    fcst_col: Optional[str] = None,\n    n_bins: int = 10,\n    label_col: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"\n    Generates an interactive plot using hvPlot.\n\n    Parameters\n    ----------\n    data : Any, optional\n        Input data, overrides self.data if provided.\n    obs_col : str, optional\n        Name of the observation variable.\n    fcst_col : str, optional\n        Name of the forecast variable.\n    n_bins : int, optional\n        Number of bins, by default 10.\n    label_col : str, optional\n        Column name to group by.\n    **kwargs : Any\n        Additional hvPlot arguments.\n\n    Returns\n    -------\n    holoviews.core.Element\n        The interactive plot.\n    \"\"\"\n    import holoviews as hv\n    import hvplot.xarray  # noqa: F401\n\n    plot_data = normalize_data(data) if data is not None else self.data\n    if plot_data is None:\n        raise ValueError(\"No data provided.\")\n\n    if label_col:\n\n        def get_stats(group):\n            return compute_binned_bias(\n                group[obs_col], group[fcst_col], n_bins=n_bins\n            ).compute()\n\n        # We compute per group for the visualization summary\n        stats_list = []\n        for name, group in plot_data.groupby(label_col):\n            s = get_stats(group)\n            s = s.assign_coords({label_col: name}).expand_dims(label_col)\n            stats_list.append(s)\n        pdf = xr.concat(stats_list, dim=label_col).dropna(dim=\"bin_center\")\n        by = label_col\n    else:\n        if isinstance(plot_data, xr.Dataset):\n            obs = plot_data[obs_col]\n            mod = plot_data[fcst_col]\n        elif isinstance(plot_data, pd.DataFrame):\n            obs = plot_data[obs_col]\n            mod = plot_data[fcst_col]\n        else:\n            mod = plot_data\n            obs = kwargs.pop(\"obs\")\n        pdf = compute_binned_bias(obs, mod, n_bins=n_bins).compute()\n        pdf = pdf.dropna(dim=\"bin_center\")\n        by = None\n\n    xlabel = (\n        plot_data[obs_col].attrs.get(\"long_name\", obs_col)\n        if obs_col\n        else \"Observed Value\"\n    )\n\n    plot = pdf.hvplot.scatter(\n        x=\"bin_center\",\n        y=\"bias_mean\",\n        by=by,\n        xlabel=xlabel,\n        ylabel=\"Mean Bias\",\n        **kwargs,\n    ) * pdf.hvplot.errorbars(x=\"bin_center\", y=\"bias_mean\", yerr1=\"bias_std\", by=by)\n\n    # Add zero line\n    plot *= hv.HLine(0).opts(color=\"black\", line_dash=\"dashed\")\n\n    return plot\n</code></pre>"},{"location":"plots/conditional_bias/#monet_plots.plots.conditional_bias.ConditionalBiasPlot.plot","title":"<code>plot(data=None, obs_col=None, fcst_col=None, n_bins=10, label='Model', label_col=None, **kwargs)</code>","text":"<p>Generates the static Matplotlib plot.</p>"},{"location":"plots/conditional_bias/#monet_plots.plots.conditional_bias.ConditionalBiasPlot.plot--parameters","title":"Parameters","text":"<p>data : Any, optional     Input data, overrides self.data if provided. obs_col : str, optional     Name of the observation variable. Required for Dataset/DataFrame. fcst_col : str, optional     Name of the forecast variable. Required for Dataset/DataFrame. n_bins : int, optional     Number of bins for observed values, by default 10. label : str, optional     Label for the model data, by default \"Model\". label_col : str, optional     Column name to group by for plotting multiple lines. **kwargs : Any     Additional Matplotlib plotting arguments passed to <code>errorbar</code>.</p>"},{"location":"plots/conditional_bias/#monet_plots.plots.conditional_bias.ConditionalBiasPlot.plot--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The axes object containing the plot.</p> Source code in <code>src/monet_plots/plots/conditional_bias.py</code> <pre><code>def plot(\n    self,\n    data: Optional[Any] = None,\n    obs_col: Optional[str] = None,\n    fcst_col: Optional[str] = None,\n    n_bins: int = 10,\n    label: str = \"Model\",\n    label_col: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"\n    Generates the static Matplotlib plot.\n\n    Parameters\n    ----------\n    data : Any, optional\n        Input data, overrides self.data if provided.\n    obs_col : str, optional\n        Name of the observation variable. Required for Dataset/DataFrame.\n    fcst_col : str, optional\n        Name of the forecast variable. Required for Dataset/DataFrame.\n    n_bins : int, optional\n        Number of bins for observed values, by default 10.\n    label : str, optional\n        Label for the model data, by default \"Model\".\n    label_col : str, optional\n        Column name to group by for plotting multiple lines.\n    **kwargs : Any\n        Additional Matplotlib plotting arguments passed to `errorbar`.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The axes object containing the plot.\n    \"\"\"\n    plot_data = normalize_data(data) if data is not None else self.data\n    if plot_data is None:\n        raise ValueError(\"No data provided.\")\n\n    try:\n        if label_col:\n            # Handle grouping for multiple models/categories\n            for name, group in plot_data.groupby(label_col):\n                obs = group[obs_col]\n                mod = group[fcst_col]\n                self._plot_single(obs, mod, n_bins, label=str(name), **kwargs)\n        else:\n            # Single model plot\n            if isinstance(plot_data, xr.Dataset):\n                obs = plot_data[obs_col]\n                mod = plot_data[fcst_col]\n            elif isinstance(plot_data, xr.DataArray):\n                mod = plot_data\n                obs = kwargs.pop(\"obs\", None)\n                if obs is None:\n                    raise ValueError(\"obs must be provided if data is a DataArray.\")\n            elif isinstance(plot_data, pd.DataFrame):\n                obs = plot_data[obs_col]\n                mod = plot_data[fcst_col]\n            else:\n                # Should have been normalized\n                raise TypeError(f\"Unsupported data type: {type(plot_data)}\")\n\n            self._plot_single(obs, mod, n_bins, label=label, **kwargs)\n    except KeyError as e:\n        raise ValueError(f\"Required column not found: {e}\") from e\n\n    self.ax.axhline(0, color=\"k\", linestyle=\"--\", linewidth=1.5, alpha=0.7)\n    xlabel = (\n        plot_data[obs_col].attrs.get(\"long_name\", obs_col)\n        if obs_col\n        else \"Observed Value\"\n    )\n    self.ax.set_xlabel(xlabel)\n    self.ax.set_ylabel(\"Mean Bias (Forecast - Observation)\")\n    self.ax.legend()\n    return self.ax\n</code></pre>"},{"location":"plots/conditional_quantile/","title":"Conditional Quantile Plot","text":"<p>Plots the distribution (quantiles) of modeled values as a function of binned observed values.</p>"},{"location":"plots/conditional_quantile/#example","title":"Example","text":"<pre><code>from monet_plots.plots import ConditionalQuantilePlot\n\nplot = ConditionalQuantilePlot(df, obs_col='obs', mod_col='mod')\nplot.plot(show_points=True)\n</code></pre>"},{"location":"plots/curtain/","title":"Vertical Curtain Plot","text":"<p>Vertical curtain plots show a 2D cross-section of data, typically with time or distance on the x-axis and altitude or pressure on the y-axis.</p>"},{"location":"plots/curtain/#example","title":"Example","text":"<pre><code>from monet_plots.plots import CurtainPlot\nimport xarray as xr\n\n# da is a 2D DataArray with dimensions (level, time)\nplot = CurtainPlot(da)\nplot.plot(kind='pcolormesh')\n</code></pre>"},{"location":"plots/diurnal_error/","title":"Diurnal Error Heat Map","text":"<p>Visualizes model error (bias) as a function of the hour of day and another temporal dimension (e.g., month, day of week).</p>"},{"location":"plots/diurnal_error/#example","title":"Example","text":"<pre><code>from monet_plots.plots import DiurnalErrorPlot\n\nplot = DiurnalErrorPlot(df, obs_col='obs', mod_col='mod', second_dim='month')\nplot.plot()\n</code></pre>"},{"location":"plots/ensemble/","title":"Ensemble","text":""},{"location":"plots/ensemble/#monet_plots.plots.ensemble.SpreadSkillPlot","title":"<code>SpreadSkillPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a spread-skill plot to evaluate ensemble forecast reliability.</p> <p>This plot compares the standard deviation of the ensemble spread to the root mean squared error (RMSE) of the ensemble mean. A reliable ensemble should have a spread that is proportional to the forecast error.</p> Source code in <code>src/monet_plots/plots/ensemble.py</code> <pre><code>class SpreadSkillPlot(BasePlot):\n    \"\"\"Create a spread-skill plot to evaluate ensemble forecast reliability.\n\n    This plot compares the standard deviation of the ensemble spread to the\n    root mean squared error (RMSE) of the ensemble mean. A reliable ensemble\n    should have a spread that is proportional to the forecast error.\n    \"\"\"\n\n    def __init__(self, spread, skill, *args, **kwargs):\n        \"\"\"\n        Initialize the plot with spread and skill data.\n\n        Args:\n            spread (array-like): The standard deviation of the ensemble forecast.\n            skill (array-like): The root mean squared error of the ensemble mean.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.spread = np.asarray(spread)\n        self.skill = np.asarray(skill)\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the spread-skill plot.\n\n        Additional keyword arguments are passed to the scatter plot.\n        \"\"\"\n        # Plot the spread-skill pairs\n        self.ax.scatter(self.spread, self.skill, **kwargs)\n\n        # Add a 1:1 reference line\n        max_val = max(np.max(self.spread), np.max(self.skill))\n        self.ax.plot([0, max_val], [0, max_val], \"k--\")\n\n        # Set labels and title\n        self.ax.set_xlabel(\"Ensemble Spread (Standard Deviation)\")\n        self.ax.set_ylabel(\"Ensemble Error (RMSE)\")\n        self.ax.set_title(\"Spread-Skill Plot\")\n\n        # Ensure aspect ratio is equal\n        self.ax.set_aspect(\"equal\", \"box\")\n\n        return self.ax\n</code></pre>"},{"location":"plots/ensemble/#monet_plots.plots.ensemble.SpreadSkillPlot.__init__","title":"<code>__init__(spread, skill, *args, **kwargs)</code>","text":"<p>Initialize the plot with spread and skill data.</p> <p>Parameters:</p> Name Type Description Default <code>spread</code> <code>array - like</code> <p>The standard deviation of the ensemble forecast.</p> required <code>skill</code> <code>array - like</code> <p>The root mean squared error of the ensemble mean.</p> required Source code in <code>src/monet_plots/plots/ensemble.py</code> <pre><code>def __init__(self, spread, skill, *args, **kwargs):\n    \"\"\"\n    Initialize the plot with spread and skill data.\n\n    Args:\n        spread (array-like): The standard deviation of the ensemble forecast.\n        skill (array-like): The root mean squared error of the ensemble mean.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.spread = np.asarray(spread)\n    self.skill = np.asarray(skill)\n</code></pre>"},{"location":"plots/ensemble/#monet_plots.plots.ensemble.SpreadSkillPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spread-skill plot.</p> <p>Additional keyword arguments are passed to the scatter plot.</p> Source code in <code>src/monet_plots/plots/ensemble.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the spread-skill plot.\n\n    Additional keyword arguments are passed to the scatter plot.\n    \"\"\"\n    # Plot the spread-skill pairs\n    self.ax.scatter(self.spread, self.skill, **kwargs)\n\n    # Add a 1:1 reference line\n    max_val = max(np.max(self.spread), np.max(self.skill))\n    self.ax.plot([0, max_val], [0, max_val], \"k--\")\n\n    # Set labels and title\n    self.ax.set_xlabel(\"Ensemble Spread (Standard Deviation)\")\n    self.ax.set_ylabel(\"Ensemble Error (RMSE)\")\n    self.ax.set_title(\"Spread-Skill Plot\")\n\n    # Ensure aspect ratio is equal\n    self.ax.set_aspect(\"equal\", \"box\")\n\n    return self.ax\n</code></pre>"},{"location":"plots/facet_grid/","title":"Facet Grids","text":""},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.FacetGridPlot","title":"<code>FacetGridPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Creates a facet grid plot.</p> <p>This class creates a facet grid plot using seaborn's FacetGrid.</p> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>class FacetGridPlot(BasePlot):\n    \"\"\"Creates a facet grid plot.\n\n    This class creates a facet grid plot using seaborn's FacetGrid.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        row: str | None = None,\n        col: str | None = None,\n        hue: str | None = None,\n        col_wrap: int | None = None,\n        height: float = 3,\n        aspect: float = 1,\n        subplot_kws: dict[str, Any] | None = None,\n        style: str | None = \"wiley\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initializes the facet grid.\n\n        Args:\n            data: The data to plot.\n            row (str, optional): Variable to map to row facets. Defaults to None\n            col (str, optional): Variable to map to column facets. Defaults to None\n            hue (str, optional): Variable to map to color mapping. Defaults to None\n            col_wrap (int, optional): Number of columns before wrapping. Defaults to None\n            height (float, optional): Height of each facet in inches. Defaults to 3\n            aspect (float, optional): Aspect ratio of each facet. Defaults to 1\n            subplot_kws (dict, optional): Keyword arguments for subplots (e.g. projection).\n            style (str, optional): Style name to apply. Defaults to 'wiley'.\n            **kwargs: Additional keyword arguments to pass to `FacetGrid`.\n        \"\"\"\n        # Apply style\n        if style:\n            set_style(style)\n\n        # Store facet parameters\n        self.row = row\n        self.col = col\n        self.hue = hue\n        self.col_wrap = col_wrap\n        self.height = height\n        self.aspect = aspect\n\n        # Convert data to pandas DataFrame and ensure coordinates are columns\n        self.raw_data = data\n        self.data = to_dataframe(data).reset_index()\n\n        # Create the FacetGrid (this creates its own figure)\n        self.grid = sns.FacetGrid(\n            self.data,\n            row=self.row,\n            col=self.col,\n            hue=self.hue,\n            col_wrap=self.col_wrap,\n            height=self.height,\n            aspect=self.aspect,\n            subplot_kws=subplot_kws,\n            **kwargs,\n        )\n\n        # Initialize BasePlot with the figure and first axes from the grid\n        axes = self.grid.axes.flatten()\n        super().__init__(fig=self.grid.fig, ax=axes[0], style=None)\n\n        # For compatibility with tests, also store as 'g'\n        self.g = self.grid\n\n    def map_dataframe(self, plot_func: Callable, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Maps a plotting function to the facet grid.\n\n        Args:\n            plot_func (function): The plotting function to map.\n            *args: Positional arguments to pass to the plotting function.\n            **kwargs: Keyword arguments to pass to the plotting function.\n        \"\"\"\n        self.grid.map_dataframe(plot_func, *args, **kwargs)\n\n    def set_titles(self, *args, **kwargs):\n        \"\"\"Sets the titles of the facet grid.\n\n        Args:\n            *args: Positional arguments to pass to `set_titles`.\n            **kwargs: Keyword arguments to pass to `set_titles`.\n        \"\"\"\n        self.grid.set_titles(*args, **kwargs)\n\n    def save(self, filename, **kwargs):\n        \"\"\"Saves the plot to a file.\n\n        Args:\n            filename (str): The name of the file to save the plot to.\n            **kwargs: Additional keyword arguments to pass to `savefig`.\n        \"\"\"\n        self.fig.savefig(filename, **kwargs)\n\n    def plot(self, plot_func=None, *args, **kwargs):\n        \"\"\"Plots the data using the FacetGrid.\n\n        Args:\n            plot_func (function, optional): The plotting function to use.\n            *args: Positional arguments to pass to the plotting function.\n            **kwargs: Keyword arguments to pass to the plotting function.\n        \"\"\"\n        if plot_func is not None:\n            self.grid.map(plot_func, *args, **kwargs)\n\n    def close(self):\n        \"\"\"Closes the plot.\"\"\"\n        plt.close(self.fig)\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.FacetGridPlot.__init__","title":"<code>__init__(data, row=None, col=None, hue=None, col_wrap=None, height=3, aspect=1, subplot_kws=None, style='wiley', **kwargs)</code>","text":"<p>Initializes the facet grid.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to plot.</p> required <code>row</code> <code>str</code> <p>Variable to map to row facets. Defaults to None</p> <code>None</code> <code>col</code> <code>str</code> <p>Variable to map to column facets. Defaults to None</p> <code>None</code> <code>hue</code> <code>str</code> <p>Variable to map to color mapping. Defaults to None</p> <code>None</code> <code>col_wrap</code> <code>int</code> <p>Number of columns before wrapping. Defaults to None</p> <code>None</code> <code>height</code> <code>float</code> <p>Height of each facet in inches. Defaults to 3</p> <code>3</code> <code>aspect</code> <code>float</code> <p>Aspect ratio of each facet. Defaults to 1</p> <code>1</code> <code>subplot_kws</code> <code>dict</code> <p>Keyword arguments for subplots (e.g. projection).</p> <code>None</code> <code>style</code> <code>str</code> <p>Style name to apply. Defaults to 'wiley'.</p> <code>'wiley'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to <code>FacetGrid</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    row: str | None = None,\n    col: str | None = None,\n    hue: str | None = None,\n    col_wrap: int | None = None,\n    height: float = 3,\n    aspect: float = 1,\n    subplot_kws: dict[str, Any] | None = None,\n    style: str | None = \"wiley\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initializes the facet grid.\n\n    Args:\n        data: The data to plot.\n        row (str, optional): Variable to map to row facets. Defaults to None\n        col (str, optional): Variable to map to column facets. Defaults to None\n        hue (str, optional): Variable to map to color mapping. Defaults to None\n        col_wrap (int, optional): Number of columns before wrapping. Defaults to None\n        height (float, optional): Height of each facet in inches. Defaults to 3\n        aspect (float, optional): Aspect ratio of each facet. Defaults to 1\n        subplot_kws (dict, optional): Keyword arguments for subplots (e.g. projection).\n        style (str, optional): Style name to apply. Defaults to 'wiley'.\n        **kwargs: Additional keyword arguments to pass to `FacetGrid`.\n    \"\"\"\n    # Apply style\n    if style:\n        set_style(style)\n\n    # Store facet parameters\n    self.row = row\n    self.col = col\n    self.hue = hue\n    self.col_wrap = col_wrap\n    self.height = height\n    self.aspect = aspect\n\n    # Convert data to pandas DataFrame and ensure coordinates are columns\n    self.raw_data = data\n    self.data = to_dataframe(data).reset_index()\n\n    # Create the FacetGrid (this creates its own figure)\n    self.grid = sns.FacetGrid(\n        self.data,\n        row=self.row,\n        col=self.col,\n        hue=self.hue,\n        col_wrap=self.col_wrap,\n        height=self.height,\n        aspect=self.aspect,\n        subplot_kws=subplot_kws,\n        **kwargs,\n    )\n\n    # Initialize BasePlot with the figure and first axes from the grid\n    axes = self.grid.axes.flatten()\n    super().__init__(fig=self.grid.fig, ax=axes[0], style=None)\n\n    # For compatibility with tests, also store as 'g'\n    self.g = self.grid\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.FacetGridPlot.close","title":"<code>close()</code>","text":"<p>Closes the plot.</p> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def close(self):\n    \"\"\"Closes the plot.\"\"\"\n    plt.close(self.fig)\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.FacetGridPlot.map_dataframe","title":"<code>map_dataframe(plot_func, *args, **kwargs)</code>","text":"<p>Maps a plotting function to the facet grid.</p> <p>Parameters:</p> Name Type Description Default <code>plot_func</code> <code>function</code> <p>The plotting function to map.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the plotting function.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the plotting function.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def map_dataframe(self, plot_func: Callable, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Maps a plotting function to the facet grid.\n\n    Args:\n        plot_func (function): The plotting function to map.\n        *args: Positional arguments to pass to the plotting function.\n        **kwargs: Keyword arguments to pass to the plotting function.\n    \"\"\"\n    self.grid.map_dataframe(plot_func, *args, **kwargs)\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.FacetGridPlot.plot","title":"<code>plot(plot_func=None, *args, **kwargs)</code>","text":"<p>Plots the data using the FacetGrid.</p> <p>Parameters:</p> Name Type Description Default <code>plot_func</code> <code>function</code> <p>The plotting function to use.</p> <code>None</code> <code>*args</code> <p>Positional arguments to pass to the plotting function.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to pass to the plotting function.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def plot(self, plot_func=None, *args, **kwargs):\n    \"\"\"Plots the data using the FacetGrid.\n\n    Args:\n        plot_func (function, optional): The plotting function to use.\n        *args: Positional arguments to pass to the plotting function.\n        **kwargs: Keyword arguments to pass to the plotting function.\n    \"\"\"\n    if plot_func is not None:\n        self.grid.map(plot_func, *args, **kwargs)\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.FacetGridPlot.save","title":"<code>save(filename, **kwargs)</code>","text":"<p>Saves the plot to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save the plot to.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to <code>savefig</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def save(self, filename, **kwargs):\n    \"\"\"Saves the plot to a file.\n\n    Args:\n        filename (str): The name of the file to save the plot to.\n        **kwargs: Additional keyword arguments to pass to `savefig`.\n    \"\"\"\n    self.fig.savefig(filename, **kwargs)\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.FacetGridPlot.set_titles","title":"<code>set_titles(*args, **kwargs)</code>","text":"<p>Sets the titles of the facet grid.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments to pass to <code>set_titles</code>.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to pass to <code>set_titles</code>.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def set_titles(self, *args, **kwargs):\n    \"\"\"Sets the titles of the facet grid.\n\n    Args:\n        *args: Positional arguments to pass to `set_titles`.\n        **kwargs: Keyword arguments to pass to `set_titles`.\n    \"\"\"\n    self.grid.set_titles(*args, **kwargs)\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.SpatialFacetGridPlot","title":"<code>SpatialFacetGridPlot</code>","text":"<p>               Bases: <code>FacetGridPlot</code></p> <p>Geospatial version of FacetGridPlot.</p> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>class SpatialFacetGridPlot(FacetGridPlot):\n    \"\"\"Geospatial version of FacetGridPlot.\"\"\"\n\n    def __init__(\n        self,\n        data: xr.DataArray | xr.Dataset,\n        *,\n        row: str | None = None,\n        col: str | None = None,\n        col_wrap: int | None = None,\n        projection: ccrs.Projection | None = None,\n        height: float = 4,\n        aspect: float = 1.2,\n        style: str | None = \"wiley\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize Spatial Facet Grid.\n\n        Parameters\n        ----------\n        data : xr.DataArray or xr.Dataset\n            Geospatial data to plot.\n        row : str, optional\n            Dimension/variable to map to rows.\n        col : str, optional\n            Dimension/variable to map to columns.\n        col_wrap : int, optional\n            Wrap columns at this number.\n        projection : ccrs.Projection, optional\n            Cartopy projection for the maps. Defaults to PlateCarree.\n        height : float\n            Height of each facet.\n        aspect : float\n            Aspect ratio of each facet.\n        **kwargs : Any\n            Additional arguments for FacetGrid.\n        \"\"\"\n        self.original_data = data\n        import cartopy.crs as ccrs\n\n        self.projection = projection or ccrs.PlateCarree()\n\n        # Handle xr.Dataset by converting to DataArray if faceting by variable\n        self.is_dataset = isinstance(data, xr.Dataset)\n        if self.is_dataset:\n            if row == \"variable\" or col == \"variable\":\n                data = data.to_array(dim=\"variable\", name=\"value\")\n\n        super().__init__(\n            data,\n            row=row,\n            col=col,\n            col_wrap=col_wrap,\n            height=height,\n            aspect=aspect,\n            subplot_kws={\"projection\": self.projection},\n            style=style,\n            **kwargs,\n        )\n\n        # Set default titles\n        self._set_default_titles()\n\n    def _set_default_titles(self) -&gt; None:\n        \"\"\"Format facet titles with metadata and date-time.\"\"\"\n        for ax in self.grid.axes.flatten():\n            if ax is None:\n                continue\n            title = ax.get_title()\n\n            # Handle titles that might have multiple facets (e.g. \"row = val | col = val\")\n            parts = title.split(\" | \")\n            new_parts = []\n\n            for part in parts:\n                if \" = \" in part:\n                    # Use split(\" = \", 1) to handle values that might contain \" = \"\n                    dim_val = part.split(\" = \", 1)\n                    if len(dim_val) == 2:\n                        dim, val = dim_val\n                        dim = dim.strip()\n                        val = val.strip()\n\n                        # Handle date-time formatting\n                        try:\n                            dt = pd.to_datetime(val)\n                            val = dt.strftime(\"%Y-%m-%d %H:%M\")\n                        except (ValueError, TypeError):\n                            pass\n\n                        # Handle long_name for dimensions/variables\n                        if dim == \"variable\" and self.is_dataset:\n                            try:\n                                # self.original_data is the original Dataset\n                                var_obj = self.original_data[val]\n                                long_name = var_obj.attrs.get(\"long_name\", val)\n                                units = var_obj.attrs.get(\"units\", \"\")\n                                val = f\"{long_name} ({units})\" if units else long_name\n                                dim = \"\"\n                            except (KeyError, AttributeError):\n                                pass\n                        elif dim in self.original_data.coords:\n                            try:\n                                coord_obj = self.original_data.coords[dim]\n                                long_name = coord_obj.attrs.get(\"long_name\", dim)\n                                dim = long_name\n                            except (KeyError, AttributeError):\n                                pass\n\n                        new_parts.append(f\"{dim} {val}\".strip())\n                    else:\n                        new_parts.append(part)\n                else:\n                    new_parts.append(part)\n\n            ax.set_title(\" | \".join(new_parts))\n\n    def add_map_features(self, **kwargs: Any) -&gt; None:\n        \"\"\"Add cartopy features to all facets.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Keyword arguments passed to SpatialPlot.add_features.\n            Default is coastlines=True.\n        \"\"\"\n        from .spatial import SpatialPlot\n\n        if \"coastlines\" not in kwargs:\n            kwargs[\"coastlines\"] = True\n\n        for ax in self.grid.axes.flatten():\n            if ax is None:\n                continue\n            # Use SpatialPlot's feature logic on each axis\n            SpatialPlot(ax=ax, projection=self.projection, **kwargs)\n\n    def map_monet(\n        self,\n        plotter_class: type,\n        *,\n        x: str = \"lon\",\n        y: str = \"lat\",\n        var_name: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Map a monet-plots spatial plotter to the grid.\n\n        Parameters\n        ----------\n        plotter_class : type\n            A class from monet_plots.plots (e.g., SpatialImshowPlot).\n        x : str\n            Column name for longitude.\n        y : str\n            Column name for latitude.\n        var_name : str, optional\n            The variable name to plot. If None and faceting by variable,\n            uses 'value'.\n        **kwargs : Any\n            Arguments passed to the plotter and map features.\n        \"\"\"\n        if var_name is None:\n            if \"variable\" in self.data.columns:\n                var_name = \"value\"\n            elif isinstance(self.raw_data, xr.DataArray):\n                var_name = self.raw_data.name\n            elif isinstance(self.raw_data, xr.Dataset):\n                # If not faceting by variable, we need a var_name\n                # For now just pick the first data var if not provided\n                var_name = list(self.raw_data.data_vars)[0]\n\n        def _mapped_plot(*args, **kwargs_inner):\n            data_df = kwargs_inner.pop(\"data\")\n            ax = plt.gca()\n\n            # Reconstruct DataArray from DataFrame\n            # We assume x and y are the coordinates\n            temp_da = data_df.set_index([y, x]).to_xarray()[var_name]\n\n            # Create plotter instance\n            plotter = plotter_class(temp_da, ax=ax, **kwargs_inner)\n            plotter.plot()\n\n        # Separate feature kwargs\n        feature_keys = [\n            \"coastlines\",\n            \"states\",\n            \"countries\",\n            \"ocean\",\n            \"land\",\n            \"lakes\",\n            \"rivers\",\n            \"borders\",\n            \"gridlines\",\n            \"extent\",\n            \"resolution\",\n        ]\n        feature_kwargs = {k: kwargs.pop(k) for k in feature_keys if k in kwargs}\n\n        # Check for colorbar requirement before popping from kwargs\n        add_shared_cb = kwargs.pop(\"add_colorbar\", False)\n\n        self.map_dataframe(_mapped_plot, **kwargs)\n\n        # Add features\n        self.add_map_features(**feature_kwargs)\n\n        # Add shared colorbar if requested\n        if add_shared_cb:\n            self._add_shared_colorbar(**kwargs)\n\n    def _add_shared_colorbar(self, **kwargs: Any) -&gt; None:\n        \"\"\"Add a shared colorbar to the figure.\"\"\"\n        # Find the last mappable object in the facets and the last valid axis\n        mappable = None\n        target_ax = None\n        for ax in reversed(self.grid.axes.flatten()):\n            if ax is None:\n                continue\n            if target_ax is None:\n                target_ax = ax\n            if ax.collections and mappable is None:\n                mappable = ax.collections[0]\n            if ax.images and mappable is None:\n                mappable = ax.images[0]\n\n        if mappable and target_ax:\n            # Add colorbar to the last valid axis\n            self.add_colorbar(\n                mappable,\n                ax=target_ax,\n                label=kwargs.get(\"label\", \"\"),\n            )\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.SpatialFacetGridPlot.__init__","title":"<code>__init__(data, *, row=None, col=None, col_wrap=None, projection=None, height=4, aspect=1.2, style='wiley', **kwargs)</code>","text":"<p>Initialize Spatial Facet Grid.</p>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.SpatialFacetGridPlot.__init__--parameters","title":"Parameters","text":"<p>data : xr.DataArray or xr.Dataset     Geospatial data to plot. row : str, optional     Dimension/variable to map to rows. col : str, optional     Dimension/variable to map to columns. col_wrap : int, optional     Wrap columns at this number. projection : ccrs.Projection, optional     Cartopy projection for the maps. Defaults to PlateCarree. height : float     Height of each facet. aspect : float     Aspect ratio of each facet. **kwargs : Any     Additional arguments for FacetGrid.</p> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def __init__(\n    self,\n    data: xr.DataArray | xr.Dataset,\n    *,\n    row: str | None = None,\n    col: str | None = None,\n    col_wrap: int | None = None,\n    projection: ccrs.Projection | None = None,\n    height: float = 4,\n    aspect: float = 1.2,\n    style: str | None = \"wiley\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize Spatial Facet Grid.\n\n    Parameters\n    ----------\n    data : xr.DataArray or xr.Dataset\n        Geospatial data to plot.\n    row : str, optional\n        Dimension/variable to map to rows.\n    col : str, optional\n        Dimension/variable to map to columns.\n    col_wrap : int, optional\n        Wrap columns at this number.\n    projection : ccrs.Projection, optional\n        Cartopy projection for the maps. Defaults to PlateCarree.\n    height : float\n        Height of each facet.\n    aspect : float\n        Aspect ratio of each facet.\n    **kwargs : Any\n        Additional arguments for FacetGrid.\n    \"\"\"\n    self.original_data = data\n    import cartopy.crs as ccrs\n\n    self.projection = projection or ccrs.PlateCarree()\n\n    # Handle xr.Dataset by converting to DataArray if faceting by variable\n    self.is_dataset = isinstance(data, xr.Dataset)\n    if self.is_dataset:\n        if row == \"variable\" or col == \"variable\":\n            data = data.to_array(dim=\"variable\", name=\"value\")\n\n    super().__init__(\n        data,\n        row=row,\n        col=col,\n        col_wrap=col_wrap,\n        height=height,\n        aspect=aspect,\n        subplot_kws={\"projection\": self.projection},\n        style=style,\n        **kwargs,\n    )\n\n    # Set default titles\n    self._set_default_titles()\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.SpatialFacetGridPlot.add_map_features","title":"<code>add_map_features(**kwargs)</code>","text":"<p>Add cartopy features to all facets.</p>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.SpatialFacetGridPlot.add_map_features--parameters","title":"Parameters","text":"<p>**kwargs : Any     Keyword arguments passed to SpatialPlot.add_features.     Default is coastlines=True.</p> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def add_map_features(self, **kwargs: Any) -&gt; None:\n    \"\"\"Add cartopy features to all facets.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Keyword arguments passed to SpatialPlot.add_features.\n        Default is coastlines=True.\n    \"\"\"\n    from .spatial import SpatialPlot\n\n    if \"coastlines\" not in kwargs:\n        kwargs[\"coastlines\"] = True\n\n    for ax in self.grid.axes.flatten():\n        if ax is None:\n            continue\n        # Use SpatialPlot's feature logic on each axis\n        SpatialPlot(ax=ax, projection=self.projection, **kwargs)\n</code></pre>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.SpatialFacetGridPlot.map_monet","title":"<code>map_monet(plotter_class, *, x='lon', y='lat', var_name=None, **kwargs)</code>","text":"<p>Map a monet-plots spatial plotter to the grid.</p>"},{"location":"plots/facet_grid/#monet_plots.plots.facet_grid.SpatialFacetGridPlot.map_monet--parameters","title":"Parameters","text":"<p>plotter_class : type     A class from monet_plots.plots (e.g., SpatialImshowPlot). x : str     Column name for longitude. y : str     Column name for latitude. var_name : str, optional     The variable name to plot. If None and faceting by variable,     uses 'value'. **kwargs : Any     Arguments passed to the plotter and map features.</p> Source code in <code>src/monet_plots/plots/facet_grid.py</code> <pre><code>def map_monet(\n    self,\n    plotter_class: type,\n    *,\n    x: str = \"lon\",\n    y: str = \"lat\",\n    var_name: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Map a monet-plots spatial plotter to the grid.\n\n    Parameters\n    ----------\n    plotter_class : type\n        A class from monet_plots.plots (e.g., SpatialImshowPlot).\n    x : str\n        Column name for longitude.\n    y : str\n        Column name for latitude.\n    var_name : str, optional\n        The variable name to plot. If None and faceting by variable,\n        uses 'value'.\n    **kwargs : Any\n        Arguments passed to the plotter and map features.\n    \"\"\"\n    if var_name is None:\n        if \"variable\" in self.data.columns:\n            var_name = \"value\"\n        elif isinstance(self.raw_data, xr.DataArray):\n            var_name = self.raw_data.name\n        elif isinstance(self.raw_data, xr.Dataset):\n            # If not faceting by variable, we need a var_name\n            # For now just pick the first data var if not provided\n            var_name = list(self.raw_data.data_vars)[0]\n\n    def _mapped_plot(*args, **kwargs_inner):\n        data_df = kwargs_inner.pop(\"data\")\n        ax = plt.gca()\n\n        # Reconstruct DataArray from DataFrame\n        # We assume x and y are the coordinates\n        temp_da = data_df.set_index([y, x]).to_xarray()[var_name]\n\n        # Create plotter instance\n        plotter = plotter_class(temp_da, ax=ax, **kwargs_inner)\n        plotter.plot()\n\n    # Separate feature kwargs\n    feature_keys = [\n        \"coastlines\",\n        \"states\",\n        \"countries\",\n        \"ocean\",\n        \"land\",\n        \"lakes\",\n        \"rivers\",\n        \"borders\",\n        \"gridlines\",\n        \"extent\",\n        \"resolution\",\n    ]\n    feature_kwargs = {k: kwargs.pop(k) for k in feature_keys if k in kwargs}\n\n    # Check for colorbar requirement before popping from kwargs\n    add_shared_cb = kwargs.pop(\"add_colorbar\", False)\n\n    self.map_dataframe(_mapped_plot, **kwargs)\n\n    # Add features\n    self.add_map_features(**feature_kwargs)\n\n    # Add shared colorbar if requested\n    if add_shared_cb:\n        self._add_shared_colorbar(**kwargs)\n</code></pre>"},{"location":"plots/fingerprint/","title":"Fingerprint Plot","text":"<p>Displays a variable as a heatmap across two different temporal scales, such as hour of day vs. day of year, to reveal periodic patterns.</p>"},{"location":"plots/fingerprint/#example","title":"Example","text":"<pre><code>from monet_plots.plots import FingerprintPlot\n\nplot = FingerprintPlot(df, val_col='concentration', x_scale='hour', y_scale='dayofyear')\nplot.plot()\n</code></pre>"},{"location":"plots/kde/","title":"KDE Plots","text":""},{"location":"plots/kde/#monet_plots.plots.kde.KDEPlot","title":"<code>KDEPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a kernel density estimate plot.</p> <p>This plot shows the distribution of a single variable.</p> Source code in <code>src/monet_plots/plots/kde.py</code> <pre><code>class KDEPlot(BasePlot):\n    \"\"\"Create a kernel density estimate plot.\n\n    This plot shows the distribution of a single variable.\n    \"\"\"\n\n    def __init__(self, df, x, y, title=None, label=None, *args, **kwargs):\n        \"\"\"\n        Initialize the plot with data and plot settings.\n\n        Args:\n            df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with the data to plot.\n            x (str): Column name for the x-axis.\n            y (str): Column name for the y-axis.\n            title (str, optional): Title for the plot.\n            label (str, optional): Label for the plot.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.df = df\n        self.x = x\n        self.y = y\n        self.title = title\n        self.label = label\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the KDE plot.\"\"\"\n        with sns.axes_style(\"ticks\"):\n            self.ax = sns.kdeplot(\n                data=self.df, x=self.x, y=self.y, ax=self.ax, label=self.label, **kwargs\n            )\n            if self.title:\n                self.ax.set_title(self.title)\n            sns.despine()\n        return self.ax\n</code></pre>"},{"location":"plots/kde/#monet_plots.plots.kde.KDEPlot.__init__","title":"<code>__init__(df, x, y, title=None, label=None, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and plot settings.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>DataFrame with the data to plot.</p> required <code>x</code> <code>str</code> <p>Column name for the x-axis.</p> required <code>y</code> <code>str</code> <p>Column name for the y-axis.</p> required <code>title</code> <code>str</code> <p>Title for the plot.</p> <code>None</code> <code>label</code> <code>str</code> <p>Label for the plot.</p> <code>None</code> Source code in <code>src/monet_plots/plots/kde.py</code> <pre><code>def __init__(self, df, x, y, title=None, label=None, *args, **kwargs):\n    \"\"\"\n    Initialize the plot with data and plot settings.\n\n    Args:\n        df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with the data to plot.\n        x (str): Column name for the x-axis.\n        y (str): Column name for the y-axis.\n        title (str, optional): Title for the plot.\n        label (str, optional): Label for the plot.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.df = df\n    self.x = x\n    self.y = y\n    self.title = title\n    self.label = label\n</code></pre>"},{"location":"plots/kde/#monet_plots.plots.kde.KDEPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the KDE plot.</p> Source code in <code>src/monet_plots/plots/kde.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the KDE plot.\"\"\"\n    with sns.axes_style(\"ticks\"):\n        self.ax = sns.kdeplot(\n            data=self.df, x=self.x, y=self.y, ax=self.ax, label=self.label, **kwargs\n        )\n        if self.title:\n            self.ax.set_title(self.title)\n        sns.despine()\n    return self.ax\n</code></pre>"},{"location":"plots/performance_diagram/","title":"Performance Diagram","text":""},{"location":"plots/performance_diagram/#monet_plots.plots.performance_diagram.PerformanceDiagramPlot","title":"<code>PerformanceDiagramPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Performance Diagram Plot (Roebber).</p> <p>Visualizes the relationship between Probability of Detection (POD), Success Ratio (SR), Critical Success Index (CSI), and Bias.</p> <p>Functional Requirements: 1. Plot POD (y-axis) vs Success Ratio (x-axis). 2. Draw background isolines for CSI and Bias. 3. Support input as pre-calculated metrics or contingency table counts. 4. Handle multiple models/configurations via grouping.</p> <p>Edge Cases: - SR or POD being 0 or 1 (division by zero in bias/CSI calculations). - Empty DataFrame. - Missing required columns.</p> Source code in <code>src/monet_plots/plots/performance_diagram.py</code> <pre><code>class PerformanceDiagramPlot(BasePlot):\n    \"\"\"\n    Performance Diagram Plot (Roebber).\n\n    Visualizes the relationship between Probability of Detection (POD),\n    Success Ratio (SR),\n    Critical Success Index (CSI), and Bias.\n\n    Functional Requirements:\n    1. Plot POD (y-axis) vs Success Ratio (x-axis).\n    2. Draw background isolines for CSI and Bias.\n    3. Support input as pre-calculated metrics or contingency table counts.\n    4. Handle multiple models/configurations via grouping.\n\n    Edge Cases:\n    - SR or POD being 0 or 1 (division by zero in bias/CSI calculations).\n    - Empty DataFrame.\n    - Missing required columns.\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        x_col: str = \"success_ratio\",\n        y_col: str = \"pod\",\n        counts_cols: Optional[List[str]] = None,\n        label_col: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data.\n            x_col (str): Column name for Success Ratio (1-FAR).\n            y_col (str): Column name for POD.\n            counts_cols (list, optional): List of columns [hits, misses, fa, cn]\n                                        to calculate metrics if x_col/y_col not present.\n            label_col (str, optional): Column to use for legend labels.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        # TDD Anchor: Test validation raises error on missing cols\n        self._validate_inputs(df, x_col, y_col, counts_cols)\n\n        # Data Preparation\n        df_plot = self._prepare_data(df, x_col, y_col, counts_cols)\n\n        # Plot Background (Isolines)\n        self._draw_background()\n\n        # Plot Data\n        # TDD Anchor: Verify scatter points match input data coordinates\n        if label_col:\n            for name, group in df_plot.groupby(label_col):\n                self.ax.plot(\n                    group[x_col],\n                    group[y_col],\n                    marker=\"o\",\n                    label=name,\n                    linestyle=\"none\",\n                    **kwargs,\n                )\n            self.ax.legend(loc=\"best\")\n        else:\n            self.ax.plot(\n                df_plot[x_col], df_plot[y_col], marker=\"o\", linestyle=\"none\", **kwargs\n            )\n\n        # Formatting\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 1)\n        self.ax.set_xlabel(\"Success Ratio (1-FAR)\")\n        self.ax.set_ylabel(\"Probability of Detection (POD)\")\n        self.ax.set_aspect(\"equal\")\n\n    def _validate_inputs(self, data, x, y, counts):\n        \"\"\"Validates input dataframe structure.\"\"\"\n        if counts:\n            validate_dataframe(data, required_columns=counts)\n        else:\n            validate_dataframe(data, required_columns=[x, y])\n\n    def _prepare_data(self, data, x, y, counts):\n        \"\"\"\n        Calculates metrics if counts provided, otherwise returns subset.\n        TDD Anchor: Test calculation logic: SR = hits/(hits+fa), POD = hits/(hits+miss).\n        \"\"\"\n        df = data.copy()\n        if counts:\n            hits_col, misses_col, fa_col, cn_col = counts\n            df[x] = compute_success_ratio(df[hits_col], df[fa_col])\n            df[y] = compute_pod(df[hits_col], df[misses_col])\n        return df\n\n    def _draw_background(self):\n        \"\"\"\n        Draws CSI and Bias isolines.\n\n        Pseudocode:\n        1. Create meshgrid for x (SR) and y (POD) from 0.01 to 1.\n        2. Calculate CSI = 1 / (1/SR + 1/POD - 1).\n        3. Calculate Bias = POD / SR.\n        4. Contour plot CSI (dashed).\n        5. Contour plot Bias (dotted).\n        6. Label contours.\n        \"\"\"\n        # Avoid division by zero at boundaries\n        xx, yy = np.meshgrid(np.linspace(0.01, 0.99, 50), np.linspace(0.01, 0.99, 50))\n        csi = (xx * yy) / (xx + yy - xx * yy)\n        bias = yy / xx\n\n        # CSI contours (dashed, lightgray)\n        cs_csi = self.ax.contour(\n            xx,\n            yy,\n            csi,\n            levels=np.arange(0.1, 0.95, 0.1),\n            colors=\"lightgray\",\n            linestyles=\"--\",\n            alpha=0.6,\n        )\n        self.ax.clabel(cs_csi, inline=True, fontsize=8, fmt=\"%.1f\")\n\n        # Bias contours (dotted, darkgray)\n        cs_bias = self.ax.contour(\n            xx,\n            yy,\n            bias,\n            levels=[0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0],\n            colors=\"darkgray\",\n            linestyles=\":\",\n            alpha=0.6,\n        )\n        self.ax.clabel(cs_bias, inline=True, fontsize=8, fmt=\"%.1f\")\n\n        # Perfect forecast line\n        self.ax.plot([0.01, 0.99], [0.01, 0.99], \"k-\", linewidth=1.5, alpha=0.8)\n</code></pre>"},{"location":"plots/performance_diagram/#monet_plots.plots.performance_diagram.PerformanceDiagramPlot.plot","title":"<code>plot(data, x_col='success_ratio', y_col='pod', counts_cols=None, label_col=None, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Input data.</p> required <code>x_col</code> <code>str</code> <p>Column name for Success Ratio (1-FAR).</p> <code>'success_ratio'</code> <code>y_col</code> <code>str</code> <p>Column name for POD.</p> <code>'pod'</code> <code>counts_cols</code> <code>list</code> <p>List of columns [hits, misses, fa, cn]                         to calculate metrics if x_col/y_col not present.</p> <code>None</code> <code>label_col</code> <code>str</code> <p>Column to use for legend labels.</p> <code>None</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/performance_diagram.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    x_col: str = \"success_ratio\",\n    y_col: str = \"pod\",\n    counts_cols: Optional[List[str]] = None,\n    label_col: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data.\n        x_col (str): Column name for Success Ratio (1-FAR).\n        y_col (str): Column name for POD.\n        counts_cols (list, optional): List of columns [hits, misses, fa, cn]\n                                    to calculate metrics if x_col/y_col not present.\n        label_col (str, optional): Column to use for legend labels.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    # TDD Anchor: Test validation raises error on missing cols\n    self._validate_inputs(df, x_col, y_col, counts_cols)\n\n    # Data Preparation\n    df_plot = self._prepare_data(df, x_col, y_col, counts_cols)\n\n    # Plot Background (Isolines)\n    self._draw_background()\n\n    # Plot Data\n    # TDD Anchor: Verify scatter points match input data coordinates\n    if label_col:\n        for name, group in df_plot.groupby(label_col):\n            self.ax.plot(\n                group[x_col],\n                group[y_col],\n                marker=\"o\",\n                label=name,\n                linestyle=\"none\",\n                **kwargs,\n            )\n        self.ax.legend(loc=\"best\")\n    else:\n        self.ax.plot(\n            df_plot[x_col], df_plot[y_col], marker=\"o\", linestyle=\"none\", **kwargs\n        )\n\n    # Formatting\n    self.ax.set_xlim(0, 1)\n    self.ax.set_ylim(0, 1)\n    self.ax.set_xlabel(\"Success Ratio (1-FAR)\")\n    self.ax.set_ylabel(\"Probability of Detection (POD)\")\n    self.ax.set_aspect(\"equal\")\n</code></pre>"},{"location":"plots/polar/","title":"Bivariate Polar Plot","text":"<p>Shows how a variable varies with wind speed and wind direction using polar coordinates.</p>"},{"location":"plots/polar/#example","title":"Example","text":"<pre><code>from monet_plots.plots import BivariatePolarPlot\n\nplot = BivariatePolarPlot(df, ws_col='ws', wd_col='wd', val_col='conc')\nplot.plot()\n</code></pre>"},{"location":"plots/profile/","title":"Profile Plots","text":""},{"location":"plots/profile/#profileplot","title":"ProfilePlot","text":"<p>               Bases: <code>BasePlot</code></p> <p>Profile or cross-section plot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>class ProfilePlot(BasePlot):\n    \"\"\"Profile or cross-section plot.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        x: np.ndarray,\n        y: np.ndarray,\n        z: np.ndarray | None = None,\n        alt_adjust: float | None = None,\n        **kwargs: t.Any,\n    ) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        x\n            X-axis data.\n        y\n            Y-axis data.\n        z\n            Optional Z-axis data for contour plots.\n        alt_adjust\n            Value to subtract from the y-axis data for altitude adjustment.\n        **kwargs\n            Keyword arguments passed to the parent class.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.x = x\n        if alt_adjust is not None:\n            self.y = y - alt_adjust\n        else:\n            self.y = y\n        self.z = z\n\n    def plot(self, **kwargs: t.Any) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        **kwargs\n            Keyword arguments passed to `matplotlib.pyplot.plot` or\n            `matplotlib.pyplot.contourf`.\n        \"\"\"\n        if self.ax is None:\n            if self.fig is None:\n                self.fig = plt.figure()\n            self.ax = self.fig.add_subplot()\n\n        if self.z is not None:\n            self.ax.contourf(self.x, self.y, self.z, **kwargs)\n        else:\n            self.ax.plot(self.x, self.y, **kwargs)\n</code></pre>"},{"location":"plots/profile/#monet_plots.plots.profile.ProfilePlot.__init__","title":"<code>__init__(*, x, y, z=None, alt_adjust=None, **kwargs)</code>","text":""},{"location":"plots/profile/#monet_plots.plots.profile.ProfilePlot.__init__--parameters","title":"Parameters","text":"<p>x     X-axis data. y     Y-axis data. z     Optional Z-axis data for contour plots. alt_adjust     Value to subtract from the y-axis data for altitude adjustment. **kwargs     Keyword arguments passed to the parent class.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def __init__(\n    self,\n    *,\n    x: np.ndarray,\n    y: np.ndarray,\n    z: np.ndarray | None = None,\n    alt_adjust: float | None = None,\n    **kwargs: t.Any,\n) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    x\n        X-axis data.\n    y\n        Y-axis data.\n    z\n        Optional Z-axis data for contour plots.\n    alt_adjust\n        Value to subtract from the y-axis data for altitude adjustment.\n    **kwargs\n        Keyword arguments passed to the parent class.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.x = x\n    if alt_adjust is not None:\n        self.y = y - alt_adjust\n    else:\n        self.y = y\n    self.z = z\n</code></pre>"},{"location":"plots/profile/#monet_plots.plots.profile.ProfilePlot.plot","title":"<code>plot(**kwargs)</code>","text":""},{"location":"plots/profile/#monet_plots.plots.profile.ProfilePlot.plot--parameters","title":"Parameters","text":"<p>**kwargs     Keyword arguments passed to <code>matplotlib.pyplot.plot</code> or     <code>matplotlib.pyplot.contourf</code>.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def plot(self, **kwargs: t.Any) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    **kwargs\n        Keyword arguments passed to `matplotlib.pyplot.plot` or\n        `matplotlib.pyplot.contourf`.\n    \"\"\"\n    if self.ax is None:\n        if self.fig is None:\n            self.fig = plt.figure()\n        self.ax = self.fig.add_subplot()\n\n    if self.z is not None:\n        self.ax.contourf(self.x, self.y, self.z, **kwargs)\n    else:\n        self.ax.plot(self.x, self.y, **kwargs)\n</code></pre>"},{"location":"plots/profile/#verticalslice","title":"VerticalSlice","text":"<p>               Bases: <code>ProfilePlot</code></p> <p>Vertical cross-section plot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>class VerticalSlice(ProfilePlot):\n    \"\"\"Vertical cross-section plot.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize the vertical slice plot.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n    def plot(self, **kwargs: t.Any) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        **kwargs\n            Keyword arguments passed to `matplotlib.pyplot.contourf`.\n        \"\"\"\n        if self.ax is None:\n            if self.fig is None:\n                self.fig = plt.figure()\n            self.ax = self.fig.add_subplot()\n\n        self.ax.contourf(self.x, self.y, self.z, **kwargs)\n</code></pre>"},{"location":"plots/profile/#monet_plots.plots.profile.VerticalSlice.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the vertical slice plot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Initialize the vertical slice plot.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"plots/profile/#monet_plots.plots.profile.VerticalSlice.plot","title":"<code>plot(**kwargs)</code>","text":""},{"location":"plots/profile/#monet_plots.plots.profile.VerticalSlice.plot--parameters","title":"Parameters","text":"<p>**kwargs     Keyword arguments passed to <code>matplotlib.pyplot.contourf</code>.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def plot(self, **kwargs: t.Any) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    **kwargs\n        Keyword arguments passed to `matplotlib.pyplot.contourf`.\n    \"\"\"\n    if self.ax is None:\n        if self.fig is None:\n            self.fig = plt.figure()\n        self.ax = self.fig.add_subplot()\n\n    self.ax.contourf(self.x, self.y, self.z, **kwargs)\n</code></pre>"},{"location":"plots/profile/#example","title":"Example","text":"<pre><code>import numpy as np\nfrom monet_plots.plots import VerticalSlice\n\n# Create sample data\nx = np.linspace(0, 10, 100)\ny = np.linspace(0, 10, 100)\nX, Y = np.meshgrid(x, y)\nZ = np.sin(X) * np.cos(Y)\n\n# Create the plot\nplot = VerticalSlice(x=X, y=Y, z=Z)\nplot.plot()\n</code></pre>"},{"location":"plots/profile/#stickplot","title":"StickPlot","text":"<p>               Bases: <code>BasePlot</code></p> <p>Vertical stick plot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>class StickPlot(BasePlot):\n    \"\"\"Vertical stick plot.\"\"\"\n\n    def __init__(self, u, v, y, *args, **kwargs):\n        \"\"\"\n        Initialize the stick plot.\n        Args:\n            u (np.ndarray, pd.Series, xr.DataArray): U-component of the vector.\n            v (np.ndarray, pd.Series, xr.DataArray): V-component of the vector.\n            y (np.ndarray, pd.Series, xr.DataArray): Vertical coordinate.\n            **kwargs: Additional keyword arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.u = u\n        self.v = v\n        self.y = y\n        self.x = np.zeros_like(self.y)\n\n    def plot(self, **kwargs: t.Any) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        **kwargs\n            Keyword arguments passed to `matplotlib.pyplot.quiver`.\n        \"\"\"\n        if self.ax is None:\n            if self.fig is None:\n                self.fig = plt.figure()\n            self.ax = self.fig.add_subplot()\n\n        return self.ax.quiver(self.x, self.y, self.u, self.v, **kwargs)\n</code></pre>"},{"location":"plots/profile/#monet_plots.plots.profile.StickPlot.__init__","title":"<code>__init__(u, v, y, *args, **kwargs)</code>","text":"<p>Initialize the stick plot. Args:     u (np.ndarray, pd.Series, xr.DataArray): U-component of the vector.     v (np.ndarray, pd.Series, xr.DataArray): V-component of the vector.     y (np.ndarray, pd.Series, xr.DataArray): Vertical coordinate.     **kwargs: Additional keyword arguments passed to BasePlot.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def __init__(self, u, v, y, *args, **kwargs):\n    \"\"\"\n    Initialize the stick plot.\n    Args:\n        u (np.ndarray, pd.Series, xr.DataArray): U-component of the vector.\n        v (np.ndarray, pd.Series, xr.DataArray): V-component of the vector.\n        y (np.ndarray, pd.Series, xr.DataArray): Vertical coordinate.\n        **kwargs: Additional keyword arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.u = u\n    self.v = v\n    self.y = y\n    self.x = np.zeros_like(self.y)\n</code></pre>"},{"location":"plots/profile/#monet_plots.plots.profile.StickPlot.plot","title":"<code>plot(**kwargs)</code>","text":""},{"location":"plots/profile/#monet_plots.plots.profile.StickPlot.plot--parameters","title":"Parameters","text":"<p>**kwargs     Keyword arguments passed to <code>matplotlib.pyplot.quiver</code>.</p> Source code in <code>src/monet_plots/plots/profile.py</code> <pre><code>def plot(self, **kwargs: t.Any) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    **kwargs\n        Keyword arguments passed to `matplotlib.pyplot.quiver`.\n    \"\"\"\n    if self.ax is None:\n        if self.fig is None:\n            self.fig = plt.figure()\n        self.ax = self.fig.add_subplot()\n\n    return self.ax.quiver(self.x, self.y, self.u, self.v, **kwargs)\n</code></pre>"},{"location":"plots/profile/#example_1","title":"Example","text":"<pre><code>import numpy as np\nfrom monet_plots.plots import StickPlot\n\n# Create sample data\nu = np.random.rand(10)\nv = np.random.rand(10)\ny = np.arange(10)\n\n# Create the plot\nplot = StickPlot(u, v, y)\nplot.plot()\n</code></pre>"},{"location":"plots/rank_histogram/","title":"Rank Histogram","text":""},{"location":"plots/rank_histogram/#monet_plots.plots.rank_histogram.RankHistogramPlot","title":"<code>RankHistogramPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Rank Histogram (Talagrand Diagram).</p> <p>Visualizes the distribution of observation ranks within an ensemble.</p> <p>Functional Requirements: 1. Plot bar chart of rank frequencies. 2. Draw horizontal line for \"Perfect Flatness\" (uniform distribution). 3. Support normalizing frequencies (relative frequency) or raw counts. 4. Interpret shapes: U-shape (underdispersed), A-shape (overdispersed), Bias (slope).</p> <p>Edge Cases: - Unequal ensemble sizes (requires binning or normalization logic, but typically preprocessing handles this). - Missing ranks (should be 0 height bars).</p> Source code in <code>src/monet_plots/plots/rank_histogram.py</code> <pre><code>class RankHistogramPlot(BasePlot):\n    \"\"\"\n    Rank Histogram (Talagrand Diagram).\n\n    Visualizes the distribution of observation ranks within an ensemble.\n\n    Functional Requirements:\n    1. Plot bar chart of rank frequencies.\n    2. Draw horizontal line for \"Perfect Flatness\" (uniform distribution).\n    3. Support normalizing frequencies (relative frequency) or raw counts.\n    4. Interpret shapes: U-shape (underdispersed), A-shape (overdispersed), Bias (slope).\n\n    Edge Cases:\n    - Unequal ensemble sizes (requires binning or normalization logic, but typically preprocessing handles this).\n    - Missing ranks (should be 0 height bars).\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        rank_col: str = \"rank\",\n        n_members: Optional[int] = None,\n        label_col: Optional[str] = None,\n        normalize: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Data containing ranks (0 to n_members).\n            rank_col (str): Column containing the rank of the observation.\n            n_members (Optional[int]): Number of ensemble members (defines n_bins = n_members + 1).\n                                      Inferred from max(rank) if None.\n            label_col (Optional[str]): Grouping for multiple histograms (e.g., lead times).\n            normalize (bool): If True, plot relative frequency; else raw counts.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        validate_dataframe(df, required_columns=[rank_col])\n\n        if n_members is None:\n            n_members = int(df[rank_col].max())\n\n        num_bins = n_members + 1\n\n        if normalize:\n            expected = 1.0 / num_bins\n        else:\n            expected = len(df) / num_bins\n\n        # TDD Anchor: Validate inputs\n\n        if label_col:\n            for name, group in df.groupby(label_col):\n                counts = (\n                    group[rank_col]\n                    .value_counts()\n                    .reindex(np.arange(num_bins), fill_value=0)\n                )\n                total = counts.sum()\n                freq = counts / total if normalize else counts\n                self.ax.bar(\n                    counts.index, freq.values, label=str(name), alpha=0.7, **kwargs\n                )\n            self.ax.legend()\n        else:\n            counts = (\n                df[rank_col].value_counts().reindex(np.arange(num_bins), fill_value=0)\n            )\n            total = counts.sum()\n            freq = counts / total if normalize else counts\n            self.ax.bar(counts.index, freq.values, alpha=0.7, **kwargs)\n\n        # Expected uniform line\n        self.ax.axhline(\n            expected, color=\"k\", linestyle=\"--\", linewidth=2, label=\"Expected (Uniform)\"\n        )\n        self.ax.legend()\n\n        # Formatting\n        self.ax.set_xlabel(\"Rank\")\n        self.ax.set_ylabel(\"Relative Frequency\" if normalize else \"Count\")\n        self.ax.set_xticks(np.arange(n_members + 1))\n        self.ax.set_xlim(-0.5, n_members + 0.5)\n        self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"plots/rank_histogram/#monet_plots.plots.rank_histogram.RankHistogramPlot.plot","title":"<code>plot(data, rank_col='rank', n_members=None, label_col=None, normalize=True, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Data containing ranks (0 to n_members).</p> required <code>rank_col</code> <code>str</code> <p>Column containing the rank of the observation.</p> <code>'rank'</code> <code>n_members</code> <code>Optional[int]</code> <p>Number of ensemble members (defines n_bins = n_members + 1).                       Inferred from max(rank) if None.</p> <code>None</code> <code>label_col</code> <code>Optional[str]</code> <p>Grouping for multiple histograms (e.g., lead times).</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If True, plot relative frequency; else raw counts.</p> <code>True</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/rank_histogram.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    rank_col: str = \"rank\",\n    n_members: Optional[int] = None,\n    label_col: Optional[str] = None,\n    normalize: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Data containing ranks (0 to n_members).\n        rank_col (str): Column containing the rank of the observation.\n        n_members (Optional[int]): Number of ensemble members (defines n_bins = n_members + 1).\n                                  Inferred from max(rank) if None.\n        label_col (Optional[str]): Grouping for multiple histograms (e.g., lead times).\n        normalize (bool): If True, plot relative frequency; else raw counts.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    validate_dataframe(df, required_columns=[rank_col])\n\n    if n_members is None:\n        n_members = int(df[rank_col].max())\n\n    num_bins = n_members + 1\n\n    if normalize:\n        expected = 1.0 / num_bins\n    else:\n        expected = len(df) / num_bins\n\n    # TDD Anchor: Validate inputs\n\n    if label_col:\n        for name, group in df.groupby(label_col):\n            counts = (\n                group[rank_col]\n                .value_counts()\n                .reindex(np.arange(num_bins), fill_value=0)\n            )\n            total = counts.sum()\n            freq = counts / total if normalize else counts\n            self.ax.bar(\n                counts.index, freq.values, label=str(name), alpha=0.7, **kwargs\n            )\n        self.ax.legend()\n    else:\n        counts = (\n            df[rank_col].value_counts().reindex(np.arange(num_bins), fill_value=0)\n        )\n        total = counts.sum()\n        freq = counts / total if normalize else counts\n        self.ax.bar(counts.index, freq.values, alpha=0.7, **kwargs)\n\n    # Expected uniform line\n    self.ax.axhline(\n        expected, color=\"k\", linestyle=\"--\", linewidth=2, label=\"Expected (Uniform)\"\n    )\n    self.ax.legend()\n\n    # Formatting\n    self.ax.set_xlabel(\"Rank\")\n    self.ax.set_ylabel(\"Relative Frequency\" if normalize else \"Count\")\n    self.ax.set_xticks(np.arange(n_members + 1))\n    self.ax.set_xlim(-0.5, n_members + 0.5)\n    self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"plots/reliability_diagram/","title":"Reliability Diagram","text":""},{"location":"plots/reliability_diagram/#monet_plots.plots.reliability_diagram.ReliabilityDiagramPlot","title":"<code>ReliabilityDiagramPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Reliability Diagram Plot (Attributes Diagram).</p> <p>Visualizes Observed Frequency vs Forecast Probability.</p> <p>Functional Requirements: 1. Plot Observed Frequency (y-axis) vs Forecast Probability (x-axis). 2. Draw \"Perfect Reliability\" diagonal (1:1). 3. Draw \"No Skill\" line (horizontal at climatology/sample mean). 4. Shade \"Skill\" areas (where Brier Skill Score &gt; 0). 5. Include inset histogram of forecast usage (Sharpness) if requested.</p> <p>Edge Cases: - Empty bins (no forecasts with that probability). - Climatology not provided (cannot draw skill regions correctly).</p> Source code in <code>src/monet_plots/plots/reliability_diagram.py</code> <pre><code>class ReliabilityDiagramPlot(BasePlot):\n    \"\"\"\n    Reliability Diagram Plot (Attributes Diagram).\n\n    Visualizes Observed Frequency vs Forecast Probability.\n\n    Functional Requirements:\n    1. Plot Observed Frequency (y-axis) vs Forecast Probability (x-axis).\n    2. Draw \"Perfect Reliability\" diagonal (1:1).\n    3. Draw \"No Skill\" line (horizontal at climatology/sample mean).\n    4. Shade \"Skill\" areas (where Brier Skill Score &gt; 0).\n    5. Include inset histogram of forecast usage (Sharpness) if requested.\n\n    Edge Cases:\n    - Empty bins (no forecasts with that probability).\n    - Climatology not provided (cannot draw skill regions correctly).\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        x_col: str = \"prob\",\n        y_col: str = \"freq\",\n        forecasts_col: Optional[str] = None,\n        observations_col: Optional[str] = None,\n        n_bins: int = 10,\n        climatology: Optional[float] = None,\n        label_col: Optional[str] = None,\n        show_hist: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data: Input data.\n            x_col (str): Forecast Probability bin center (for pre-binned).\n            y_col (str): Observed Frequency in bin (for pre-binned).\n            forecasts_col (str, optional): Column of raw forecast probabilities [0,1].\n            observations_col (str, optional): Column of binary observations {0,1}.\n            n_bins (int): Number of bins for reliability curve computation.\n            climatology (Optional[float]): Sample climatology (mean(observations)).\n            label_col (str, optional): Grouping column.\n            show_hist (bool): Whether to show frequency of usage histogram.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        # Compute if raw data provided\n        if forecasts_col and observations_col:\n            if climatology is None:\n                climatology = float(df[observations_col].mean())\n            bin_centers, obs_freq, bin_counts = compute_reliability_curve(\n                np.asarray(df[forecasts_col]), np.asarray(df[observations_col]), n_bins\n            )\n            plot_data = pd.DataFrame(\n                {x_col: bin_centers, y_col: obs_freq, \"count\": bin_counts}\n            )\n        else:\n            validate_dataframe(df, required_columns=[x_col, y_col])\n            plot_data = df\n\n        # Draw Reference Lines\n        self.ax.plot([0, 1], [0, 1], \"k--\", label=\"Perfect Reliability\")\n        if climatology is not None:\n            self.ax.axhline(\n                climatology, color=\"gray\", linestyle=\":\", label=\"Climatology\"\n            )\n            self._draw_skill_regions(climatology)\n\n        # Plot Data\n        if label_col:\n            for name, group in plot_data.groupby(label_col):\n                # pop label from kwargs if it exists to avoid multiple values\n                k = kwargs.copy()\n                k.pop(\"label\", None)\n                self.ax.plot(group[x_col], group[y_col], marker=\"o\", label=name, **k)\n        else:\n            k = kwargs.copy()\n            label = k.pop(\"label\", \"Model\")\n            self.ax.plot(\n                plot_data[x_col], plot_data[y_col], marker=\"o\", label=label, **k\n            )\n\n        # Histogram Overlay (Sharpness)\n        if show_hist and \"count\" in plot_data.columns:\n            self._add_sharpness_histogram(plot_data, x_col)\n\n        # Formatting\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 1)\n        self.ax.set_xlabel(\"Forecast Probability\")\n        self.ax.set_ylabel(\"Observed Relative Frequency\")\n        self.ax.set_aspect(\"equal\")\n        self.ax.grid(True, alpha=0.3)\n        self.ax.legend()\n\n    def _draw_skill_regions(self, clim):\n        \"\"\"Shades areas where BSS &gt; 0.\"\"\"\n        x = np.linspace(0, 1, 100)\n        y_no_skill = np.full_like(x, clim)\n        y_perfect = x\n\n        # Shade skill region (above no-skill towards perfect)\n        self.ax.fill_between(\n            x, y_no_skill, y_perfect, alpha=0.1, color=\"green\", label=\"Skill Region\"\n        )\n\n    def _add_sharpness_histogram(self, data, x_col):\n        \"\"\"Adds a small inset axes for sharpness histogram.\"\"\"\n        from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\n        inset_ax = inset_axes(self.ax, width=1.5, height=1.2, loc=\"upper right\")\n        inset_ax.bar(data[x_col], data[\"count\"], alpha=0.5, color=\"blue\", width=0.08)\n        inset_ax.set_title(\"Sharpness\")\n        inset_ax.set_xlabel(x_col)\n        inset_ax.set_ylabel(\"Count\")\n</code></pre>"},{"location":"plots/reliability_diagram/#monet_plots.plots.reliability_diagram.ReliabilityDiagramPlot.plot","title":"<code>plot(data, x_col='prob', y_col='freq', forecasts_col=None, observations_col=None, n_bins=10, climatology=None, label_col=None, show_hist=False, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Input data.</p> required <code>x_col</code> <code>str</code> <p>Forecast Probability bin center (for pre-binned).</p> <code>'prob'</code> <code>y_col</code> <code>str</code> <p>Observed Frequency in bin (for pre-binned).</p> <code>'freq'</code> <code>forecasts_col</code> <code>str</code> <p>Column of raw forecast probabilities [0,1].</p> <code>None</code> <code>observations_col</code> <code>str</code> <p>Column of binary observations {0,1}.</p> <code>None</code> <code>n_bins</code> <code>int</code> <p>Number of bins for reliability curve computation.</p> <code>10</code> <code>climatology</code> <code>Optional[float]</code> <p>Sample climatology (mean(observations)).</p> <code>None</code> <code>label_col</code> <code>str</code> <p>Grouping column.</p> <code>None</code> <code>show_hist</code> <code>bool</code> <p>Whether to show frequency of usage histogram.</p> <code>False</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/reliability_diagram.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    x_col: str = \"prob\",\n    y_col: str = \"freq\",\n    forecasts_col: Optional[str] = None,\n    observations_col: Optional[str] = None,\n    n_bins: int = 10,\n    climatology: Optional[float] = None,\n    label_col: Optional[str] = None,\n    show_hist: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data: Input data.\n        x_col (str): Forecast Probability bin center (for pre-binned).\n        y_col (str): Observed Frequency in bin (for pre-binned).\n        forecasts_col (str, optional): Column of raw forecast probabilities [0,1].\n        observations_col (str, optional): Column of binary observations {0,1}.\n        n_bins (int): Number of bins for reliability curve computation.\n        climatology (Optional[float]): Sample climatology (mean(observations)).\n        label_col (str, optional): Grouping column.\n        show_hist (bool): Whether to show frequency of usage histogram.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    # Compute if raw data provided\n    if forecasts_col and observations_col:\n        if climatology is None:\n            climatology = float(df[observations_col].mean())\n        bin_centers, obs_freq, bin_counts = compute_reliability_curve(\n            np.asarray(df[forecasts_col]), np.asarray(df[observations_col]), n_bins\n        )\n        plot_data = pd.DataFrame(\n            {x_col: bin_centers, y_col: obs_freq, \"count\": bin_counts}\n        )\n    else:\n        validate_dataframe(df, required_columns=[x_col, y_col])\n        plot_data = df\n\n    # Draw Reference Lines\n    self.ax.plot([0, 1], [0, 1], \"k--\", label=\"Perfect Reliability\")\n    if climatology is not None:\n        self.ax.axhline(\n            climatology, color=\"gray\", linestyle=\":\", label=\"Climatology\"\n        )\n        self._draw_skill_regions(climatology)\n\n    # Plot Data\n    if label_col:\n        for name, group in plot_data.groupby(label_col):\n            # pop label from kwargs if it exists to avoid multiple values\n            k = kwargs.copy()\n            k.pop(\"label\", None)\n            self.ax.plot(group[x_col], group[y_col], marker=\"o\", label=name, **k)\n    else:\n        k = kwargs.copy()\n        label = k.pop(\"label\", \"Model\")\n        self.ax.plot(\n            plot_data[x_col], plot_data[y_col], marker=\"o\", label=label, **k\n        )\n\n    # Histogram Overlay (Sharpness)\n    if show_hist and \"count\" in plot_data.columns:\n        self._add_sharpness_histogram(plot_data, x_col)\n\n    # Formatting\n    self.ax.set_xlim(0, 1)\n    self.ax.set_ylim(0, 1)\n    self.ax.set_xlabel(\"Forecast Probability\")\n    self.ax.set_ylabel(\"Observed Relative Frequency\")\n    self.ax.set_aspect(\"equal\")\n    self.ax.grid(True, alpha=0.3)\n    self.ax.legend()\n</code></pre>"},{"location":"plots/rev/","title":"REV","text":""},{"location":"plots/rev/#monet_plots.plots.rev.RelativeEconomicValuePlot","title":"<code>RelativeEconomicValuePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Relative Economic Value (REV) Plot.</p> <p>Visualizes the potential economic value of a forecast system relative to climatology.</p> <p>Functional Requirements: 1. Plot Value (y-axis) vs Cost/Loss Ratio (x-axis). 2. Calculate REV based on Hits, Misses, False Alarms, Correct Negatives. 3. Support multiple models. 4. X-axis usually logarithmic or specific range [0, 1].</p> <p>Edge Cases: - C/L ratio 0 or 1 (value is 0). - No events observed (metrics undefined).</p> Source code in <code>src/monet_plots/plots/rev.py</code> <pre><code>class RelativeEconomicValuePlot(BasePlot):\n    \"\"\"\n    Relative Economic Value (REV) Plot.\n\n    Visualizes the potential economic value of a forecast system relative to climatology.\n\n    Functional Requirements:\n    1. Plot Value (y-axis) vs Cost/Loss Ratio (x-axis).\n    2. Calculate REV based on Hits, Misses, False Alarms, Correct Negatives.\n    3. Support multiple models.\n    4. X-axis usually logarithmic or specific range [0, 1].\n\n    Edge Cases:\n    - C/L ratio 0 or 1 (value is 0).\n    - No events observed (metrics undefined).\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        counts_cols: List[str] = [\"hits\", \"misses\", \"fa\", \"cn\"],\n        climatology: Optional[float] = None,\n        label_col: Optional[str] = None,\n        cost_loss_ratios: Optional[np.ndarray] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data with contingency table counts.\n            counts_cols (List[str]): Contingency table columns [hits, misses, fa, cn].\n            climatology (Optional[float]): Sample climatology (base rate). Computed if None.\n            label_col (Optional[str]): Grouping column for multiple curves.\n            cost_loss_ratios (Optional[np.ndarray]): Array of C/L ratios. Default linspace(0.001,0.999,100).\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        validate_dataframe(df, required_columns=counts_cols)\n\n        if climatology is None:\n            total_events = df[counts_cols[0]].sum() + df[counts_cols[1]].sum()\n            total = total_events + df[counts_cols[2]].sum() + df[counts_cols[3]].sum()\n            climatology = total_events / total if total &gt; 0 else 0.5\n\n        if cost_loss_ratios is None:\n            cost_loss_ratios = np.linspace(0.001, 0.999, 100)\n\n        # TDD Anchor: Test REV calculation logic\n\n        if label_col:\n            for name, group in df.groupby(label_col):\n                rev_values = self._calculate_rev(\n                    group, counts_cols, cost_loss_ratios, climatology\n                )\n                self.ax.plot(cost_loss_ratios, rev_values, label=str(name), **kwargs)\n            self.ax.legend(loc=\"best\")\n        else:\n            rev_values = self._calculate_rev(\n                df, counts_cols, cost_loss_ratios, climatology\n            )\n            self.ax.plot(cost_loss_ratios, rev_values, label=\"Model\", **kwargs)\n\n        self.ax.set_xlabel(\"Cost/Loss Ratio\")\n        self.ax.set_ylabel(\"Relative Economic Value (REV)\")\n        self.ax.set_ylim(-0.2, 1.05)\n        self.ax.axhline(0, color=\"k\", linestyle=\"--\", alpha=0.7, label=\"Climatology\")\n        self.ax.axhline(1, color=\"gray\", linestyle=\":\", alpha=0.7, label=\"Perfect\")\n        self.ax.legend()\n        self.ax.grid(True, alpha=0.3)\n\n    def _calculate_rev(self, df, cols, ratios, clim):\n        \"\"\"\n        Calculates REV for given ratios.\n        \"\"\"\n        hits = df[cols[0]].sum()\n        misses = df[cols[1]].sum()\n        fa = df[cols[2]].sum()\n        cn = df[cols[3]].sum()\n        return compute_rev(hits, misses, fa, cn, ratios, clim)\n</code></pre>"},{"location":"plots/rev/#monet_plots.plots.rev.RelativeEconomicValuePlot.plot","title":"<code>plot(data, counts_cols=['hits', 'misses', 'fa', 'cn'], climatology=None, label_col=None, cost_loss_ratios=None, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Input data with contingency table counts.</p> required <code>counts_cols</code> <code>List[str]</code> <p>Contingency table columns [hits, misses, fa, cn].</p> <code>['hits', 'misses', 'fa', 'cn']</code> <code>climatology</code> <code>Optional[float]</code> <p>Sample climatology (base rate). Computed if None.</p> <code>None</code> <code>label_col</code> <code>Optional[str]</code> <p>Grouping column for multiple curves.</p> <code>None</code> <code>cost_loss_ratios</code> <code>Optional[ndarray]</code> <p>Array of C/L ratios. Default linspace(0.001,0.999,100).</p> <code>None</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/rev.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    counts_cols: List[str] = [\"hits\", \"misses\", \"fa\", \"cn\"],\n    climatology: Optional[float] = None,\n    label_col: Optional[str] = None,\n    cost_loss_ratios: Optional[np.ndarray] = None,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data with contingency table counts.\n        counts_cols (List[str]): Contingency table columns [hits, misses, fa, cn].\n        climatology (Optional[float]): Sample climatology (base rate). Computed if None.\n        label_col (Optional[str]): Grouping column for multiple curves.\n        cost_loss_ratios (Optional[np.ndarray]): Array of C/L ratios. Default linspace(0.001,0.999,100).\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    validate_dataframe(df, required_columns=counts_cols)\n\n    if climatology is None:\n        total_events = df[counts_cols[0]].sum() + df[counts_cols[1]].sum()\n        total = total_events + df[counts_cols[2]].sum() + df[counts_cols[3]].sum()\n        climatology = total_events / total if total &gt; 0 else 0.5\n\n    if cost_loss_ratios is None:\n        cost_loss_ratios = np.linspace(0.001, 0.999, 100)\n\n    # TDD Anchor: Test REV calculation logic\n\n    if label_col:\n        for name, group in df.groupby(label_col):\n            rev_values = self._calculate_rev(\n                group, counts_cols, cost_loss_ratios, climatology\n            )\n            self.ax.plot(cost_loss_ratios, rev_values, label=str(name), **kwargs)\n        self.ax.legend(loc=\"best\")\n    else:\n        rev_values = self._calculate_rev(\n            df, counts_cols, cost_loss_ratios, climatology\n        )\n        self.ax.plot(cost_loss_ratios, rev_values, label=\"Model\", **kwargs)\n\n    self.ax.set_xlabel(\"Cost/Loss Ratio\")\n    self.ax.set_ylabel(\"Relative Economic Value (REV)\")\n    self.ax.set_ylim(-0.2, 1.05)\n    self.ax.axhline(0, color=\"k\", linestyle=\"--\", alpha=0.7, label=\"Climatology\")\n    self.ax.axhline(1, color=\"gray\", linestyle=\":\", alpha=0.7, label=\"Perfect\")\n    self.ax.legend()\n    self.ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"plots/ridgeline/","title":"Ridgeline Plot","text":"<p>Ridgeline (joyplot) plot implementation.</p>"},{"location":"plots/ridgeline/#monet_plots.plots.ridgeline.RidgelinePlot","title":"<code>RidgelinePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Creates a ridgeline plot (joyplot) from an xarray DataArray or pandas DataFrame.</p> <p>A ridgeline plot shows the distribution of a numeric value for several groups. Each group has its own distribution curve, often overlapping with others.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>DataArray | Dataset | DataFrame</code> <p>Normalized input data.</p> <code>group_dim</code> <code>str</code> <p>The dimension or column to group by for the Y-axis.</p> <code>x</code> <code>str | None</code> <p>The column name for values if data is a DataFrame or Dataset.</p> <code>x_range</code> <code>tuple | None</code> <p>Tuple (min, max) for the x-axis limits.</p> <code>scale_factor</code> <code>float</code> <p>Height scaling of the curves.</p> <code>overlap</code> <code>float</code> <p>Vertical spacing between curves.</p> <code>cmap_name</code> <code>str</code> <p>Colormap name for coloring curves.</p> <code>title</code> <code>str | None</code> <p>Plot title.</p> Source code in <code>src/monet_plots/plots/ridgeline.py</code> <pre><code>class RidgelinePlot(BasePlot):\n    \"\"\"\n    Creates a ridgeline plot (joyplot) from an xarray DataArray or pandas DataFrame.\n\n    A ridgeline plot shows the distribution of a numeric value for several groups.\n    Each group has its own distribution curve, often overlapping with others.\n\n    Attributes:\n        data (xr.DataArray | xr.Dataset | pd.DataFrame): Normalized input data.\n        group_dim (str): The dimension or column to group by for the Y-axis.\n        x (str | None): The column name for values if data is a DataFrame or Dataset.\n        x_range (tuple | None): Tuple (min, max) for the x-axis limits.\n        scale_factor (float): Height scaling of the curves.\n        overlap (float): Vertical spacing between curves.\n        cmap_name (str): Colormap name for coloring curves.\n        title (str | None): Plot title.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any,\n        group_dim: str,\n        x: Optional[str] = None,\n        *,\n        x_range: Optional[Tuple[float, float]] = None,\n        scale_factor: float = 1.0,\n        overlap: float = 0.5,\n        cmap: str = \"RdBu_r\",\n        title: Optional[str] = None,\n        bw_method: Optional[Any] = None,\n        alpha: float = 0.8,\n        quantiles: Optional[list[float]] = None,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initializes the ridgeline plot with data and settings.\n\n        Args:\n            data (Any): The data to plot (xr.DataArray, xr.Dataset, or pd.DataFrame).\n            group_dim (str): The dimension or column to group by for the Y-axis.\n            x (str, optional): The variable/column to plot distributions of.\n                Required if data is a Dataset or DataFrame with multiple variables.\n            x_range (tuple[float, float], optional): Tuple (min, max) for the x-axis limits.\n                If None, auto-calculated.\n            scale_factor (float): Height scaling of the curves. Defaults to 1.0.\n            overlap (float): Vertical spacing between curves. Higher values mean more overlap.\n                Defaults to 0.5.\n            cmap (str): Colormap name for coloring curves. Defaults to 'RdBu_r'.\n            title (str, optional): Plot title.\n            bw_method (Any, optional): KDE bandwidth method (passed to scipy.stats.gaussian_kde).\n            alpha (float): Transparency of the ridges. Defaults to 0.8.\n            quantiles (list[float], optional): List of quantiles to display (e.g., [0.5]).\n            **kwargs: Additional keyword arguments for BasePlot (figure/axes creation).\n        \"\"\"\n        super().__init__(**kwargs)\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1)\n\n        self.data = normalize_data(data)\n        self.group_dim = group_dim\n        self.x = x\n        self.x_range = x_range\n        self.scale_factor = scale_factor\n        self.overlap = overlap\n        self.cmap_name = cmap\n        self.title = title\n        self.bw_method = bw_method\n        self.alpha = alpha\n        self.quantiles = quantiles\n\n    def plot(\n        self, gradient: bool = True, color_by_group: bool = False, **kwargs: Any\n    ) -&gt; matplotlib.axes.Axes:\n        \"\"\"\n        Generate the ridgeline plot.\n\n        Args:\n            gradient (bool): If True, fill curves with a gradient based on x-values.\n            color_by_group (bool): If True, color each ridge by its group category.\n                Takes precedence over gradient if True.\n            **kwargs: Additional keyword arguments for formatting.\n\n        Returns:\n            matplotlib.axes.Axes: The axes object containing the plot.\n        \"\"\"\n        import matplotlib.pyplot as plt\n\n        from ..verification_metrics import _update_history\n\n        # 1. Prepare Data and Groups\n        if isinstance(self.data, xr.DataArray):\n            da = self.data\n            da_sorted = da.sortby(self.group_dim, ascending=False)\n            groups = da_sorted[self.group_dim].values\n            data_name = str(da.name) if da.name else \"Value\"\n\n            if self.x_range is None:\n                vmin = float(da.min().compute())\n                vmax = float(da.max().compute())\n            else:\n                vmin, vmax = self.x_range\n\n            if np.isnan(vmin) or np.isnan(vmax):\n                raise ValueError(\"No valid data points found to plot.\")\n\n        elif isinstance(self.data, xr.Dataset):\n            if self.x is None:\n                self.x = list(self.data.data_vars)[0]\n            da = self.data[self.x]\n            da_sorted = da.sortby(self.group_dim, ascending=False)\n            groups = da_sorted[self.group_dim].values\n            data_name = str(da.name) if da.name else self.x\n\n            if self.x_range is None:\n                vmin = float(da.min().compute())\n                vmax = float(da.max().compute())\n            else:\n                vmin, vmax = self.x_range\n\n            if np.isnan(vmin) or np.isnan(vmax):\n                raise ValueError(\"No valid data points found to plot.\")\n\n        else:\n            # Pandas DataFrame\n            df = self.data\n            if self.x is None:\n                # Try to find a numeric column that is not group_dim\n                numeric_cols = df.select_dtypes(include=[np.number]).columns\n                cols_to_use = [c for c in numeric_cols if c != self.group_dim]\n                if not cols_to_use:\n                    raise ValueError(\"No numeric columns found in DataFrame to plot.\")\n                self.x = cols_to_use[0]\n\n            df_sorted = df.sort_values(self.group_dim, ascending=False)\n            groups = df_sorted[self.group_dim].unique()\n            data_name = str(self.x)\n\n            if self.x_range is None:\n                vmin = float(df[self.x].min())\n                vmax = float(df[self.x].max())\n            else:\n                vmin, vmax = self.x_range\n\n            if np.isnan(vmin) or np.isnan(vmax):\n                raise ValueError(\"No valid data points found to plot.\")\n\n        # Setup X-axis grid for density calculation\n        if self.x_range is None:\n            pad = (vmax - vmin) * 0.1\n            x_grid = np.linspace(vmin - pad, vmax + pad, 200)\n        else:\n            x_grid = np.linspace(vmin, vmax, 200)\n\n        # Setup Colors\n        cmap, norm = get_linear_scale(None, cmap=self.cmap_name, vmin=vmin, vmax=vmax)\n\n        # 2. Iterate and Plot\n        for i, val in enumerate(groups):\n            if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n                # Handle DataArray/Dataset slice\n                data_slice = da_sorted.sel({self.group_dim: val}).values.flatten()\n            else:\n                # Handle DataFrame slice\n                data_slice = df_sorted[df_sorted[self.group_dim] == val][\n                    self.x\n                ].values.flatten()\n\n            data_slice = data_slice[~np.isnan(data_slice)]\n\n            if len(data_slice) &lt; 2:\n                continue\n\n            try:\n                kde = gaussian_kde(data_slice, bw_method=self.bw_method)\n                y_density = kde(x_grid)\n            except (np.linalg.LinAlgError, ValueError):\n                continue\n\n            # Scale density and calculate vertical baseline\n            y_density_scaled = y_density * self.scale_factor\n            baseline = -i * self.overlap\n            y_final = baseline + y_density_scaled\n\n            # Plot filling\n            if color_by_group:\n                # Use qualitative cmap or indexed colors\n                color = plt.get_cmap(\"tab10\")(i % 10)\n                self.ax.fill_between(\n                    x_grid,\n                    baseline,\n                    y_final,\n                    facecolor=color,\n                    edgecolor=\"white\",\n                    linewidth=0.5,\n                    alpha=self.alpha,\n                    zorder=len(groups) - i,\n                )\n                self.ax.plot(\n                    x_grid,\n                    y_final,\n                    color=\"black\",\n                    linewidth=0.5,\n                    zorder=len(groups) - i + 0.1,\n                )\n            elif gradient:\n                # Plot in segments to create a gradient effect\n                for j in range(len(x_grid) - 1):\n                    self.ax.fill_between(\n                        x_grid[j : j + 2],\n                        baseline,\n                        y_final[j : j + 2],\n                        facecolor=cmap(norm(x_grid[j])),\n                        edgecolor=\"none\",\n                        alpha=self.alpha,\n                        zorder=len(groups) - i,\n                    )\n                # Add a clean top outline\n                self.ax.plot(\n                    x_grid,\n                    y_final,\n                    color=\"black\",\n                    linewidth=0.5,\n                    zorder=len(groups) - i + 0.1,\n                )\n            else:\n                # Single color based on the mean of this slice\n                slice_mean = np.mean(data_slice)\n                color = cmap(norm(slice_mean))\n                self.ax.fill_between(\n                    x_grid,\n                    baseline,\n                    y_final,\n                    facecolor=color,\n                    edgecolor=\"white\",\n                    linewidth=0.5,\n                    alpha=self.alpha,\n                    zorder=len(groups) - i,\n                )\n                self.ax.plot(\n                    x_grid,\n                    y_final,\n                    color=\"black\",\n                    linewidth=0.5,\n                    zorder=len(groups) - i + 0.1,\n                )\n\n            # 3. Add Quantiles\n            if self.quantiles is not None:\n                q_values = np.quantile(data_slice, self.quantiles)\n                q_densities = kde(q_values) * self.scale_factor\n                for qv, qd in zip(q_values, q_densities):\n                    self.ax.vlines(\n                        qv,\n                        baseline,\n                        baseline + qd,\n                        color=\"black\",\n                        linestyle=\"--\",\n                        linewidth=0.8,\n                        zorder=len(groups) - i + 0.2,\n                    )\n\n        # 3. Final Formatting\n        self.ax.set_yticks([-i * self.overlap for i in range(len(groups))])\n        self.ax.set_yticklabels(groups)\n        self.ax.set_xlabel(data_name)\n        if self.title:\n            self.ax.set_title(self.title, pad=20)\n\n        # Add Colorbar matching the x-axis scale if not coloring by group\n        if not color_by_group:\n            mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n            self.add_colorbar(mappable, label=data_name)\n\n        # Add vertical gridlines as seen in the reference\n        self.ax.xaxis.grid(True, linestyle=\"-\", alpha=0.3)\n\n        # Add a vertical zero line if the range crosses zero\n        if x_grid.min() &lt; 0 and x_grid.max() &gt; 0:\n            self.ax.axvline(0, color=\"black\", alpha=0.3, linestyle=\"--\", linewidth=1)\n\n        # Remove unnecessary spines\n        self.ax.spines[\"top\"].set_visible(False)\n        self.ax.spines[\"right\"].set_visible(False)\n        self.ax.spines[\"left\"].set_visible(False)\n\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            _update_history(self.data, f\"Created ridgeline plot for {data_name}\")\n\n        return self.ax\n</code></pre>"},{"location":"plots/ridgeline/#monet_plots.plots.ridgeline.RidgelinePlot.__init__","title":"<code>__init__(data, group_dim, x=None, *, x_range=None, scale_factor=1.0, overlap=0.5, cmap='RdBu_r', title=None, bw_method=None, alpha=0.8, quantiles=None, **kwargs)</code>","text":"<p>Initializes the ridgeline plot with data and settings.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to plot (xr.DataArray, xr.Dataset, or pd.DataFrame).</p> required <code>group_dim</code> <code>str</code> <p>The dimension or column to group by for the Y-axis.</p> required <code>x</code> <code>str</code> <p>The variable/column to plot distributions of. Required if data is a Dataset or DataFrame with multiple variables.</p> <code>None</code> <code>x_range</code> <code>tuple[float, float]</code> <p>Tuple (min, max) for the x-axis limits. If None, auto-calculated.</p> <code>None</code> <code>scale_factor</code> <code>float</code> <p>Height scaling of the curves. Defaults to 1.0.</p> <code>1.0</code> <code>overlap</code> <code>float</code> <p>Vertical spacing between curves. Higher values mean more overlap. Defaults to 0.5.</p> <code>0.5</code> <code>cmap</code> <code>str</code> <p>Colormap name for coloring curves. Defaults to 'RdBu_r'.</p> <code>'RdBu_r'</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>None</code> <code>bw_method</code> <code>Any</code> <p>KDE bandwidth method (passed to scipy.stats.gaussian_kde).</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Transparency of the ridges. Defaults to 0.8.</p> <code>0.8</code> <code>quantiles</code> <code>list[float]</code> <p>List of quantiles to display (e.g., [0.5]).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for BasePlot (figure/axes creation).</p> <code>{}</code> Source code in <code>src/monet_plots/plots/ridgeline.py</code> <pre><code>def __init__(\n    self,\n    data: Any,\n    group_dim: str,\n    x: Optional[str] = None,\n    *,\n    x_range: Optional[Tuple[float, float]] = None,\n    scale_factor: float = 1.0,\n    overlap: float = 0.5,\n    cmap: str = \"RdBu_r\",\n    title: Optional[str] = None,\n    bw_method: Optional[Any] = None,\n    alpha: float = 0.8,\n    quantiles: Optional[list[float]] = None,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initializes the ridgeline plot with data and settings.\n\n    Args:\n        data (Any): The data to plot (xr.DataArray, xr.Dataset, or pd.DataFrame).\n        group_dim (str): The dimension or column to group by for the Y-axis.\n        x (str, optional): The variable/column to plot distributions of.\n            Required if data is a Dataset or DataFrame with multiple variables.\n        x_range (tuple[float, float], optional): Tuple (min, max) for the x-axis limits.\n            If None, auto-calculated.\n        scale_factor (float): Height scaling of the curves. Defaults to 1.0.\n        overlap (float): Vertical spacing between curves. Higher values mean more overlap.\n            Defaults to 0.5.\n        cmap (str): Colormap name for coloring curves. Defaults to 'RdBu_r'.\n        title (str, optional): Plot title.\n        bw_method (Any, optional): KDE bandwidth method (passed to scipy.stats.gaussian_kde).\n        alpha (float): Transparency of the ridges. Defaults to 0.8.\n        quantiles (list[float], optional): List of quantiles to display (e.g., [0.5]).\n        **kwargs: Additional keyword arguments for BasePlot (figure/axes creation).\n    \"\"\"\n    super().__init__(**kwargs)\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1)\n\n    self.data = normalize_data(data)\n    self.group_dim = group_dim\n    self.x = x\n    self.x_range = x_range\n    self.scale_factor = scale_factor\n    self.overlap = overlap\n    self.cmap_name = cmap\n    self.title = title\n    self.bw_method = bw_method\n    self.alpha = alpha\n    self.quantiles = quantiles\n</code></pre>"},{"location":"plots/ridgeline/#monet_plots.plots.ridgeline.RidgelinePlot.plot","title":"<code>plot(gradient=True, color_by_group=False, **kwargs)</code>","text":"<p>Generate the ridgeline plot.</p> <p>Parameters:</p> Name Type Description Default <code>gradient</code> <code>bool</code> <p>If True, fill curves with a gradient based on x-values.</p> <code>True</code> <code>color_by_group</code> <code>bool</code> <p>If True, color each ridge by its group category. Takes precedence over gradient if True.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for formatting.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>matplotlib.axes.Axes: The axes object containing the plot.</p> Source code in <code>src/monet_plots/plots/ridgeline.py</code> <pre><code>def plot(\n    self, gradient: bool = True, color_by_group: bool = False, **kwargs: Any\n) -&gt; matplotlib.axes.Axes:\n    \"\"\"\n    Generate the ridgeline plot.\n\n    Args:\n        gradient (bool): If True, fill curves with a gradient based on x-values.\n        color_by_group (bool): If True, color each ridge by its group category.\n            Takes precedence over gradient if True.\n        **kwargs: Additional keyword arguments for formatting.\n\n    Returns:\n        matplotlib.axes.Axes: The axes object containing the plot.\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    from ..verification_metrics import _update_history\n\n    # 1. Prepare Data and Groups\n    if isinstance(self.data, xr.DataArray):\n        da = self.data\n        da_sorted = da.sortby(self.group_dim, ascending=False)\n        groups = da_sorted[self.group_dim].values\n        data_name = str(da.name) if da.name else \"Value\"\n\n        if self.x_range is None:\n            vmin = float(da.min().compute())\n            vmax = float(da.max().compute())\n        else:\n            vmin, vmax = self.x_range\n\n        if np.isnan(vmin) or np.isnan(vmax):\n            raise ValueError(\"No valid data points found to plot.\")\n\n    elif isinstance(self.data, xr.Dataset):\n        if self.x is None:\n            self.x = list(self.data.data_vars)[0]\n        da = self.data[self.x]\n        da_sorted = da.sortby(self.group_dim, ascending=False)\n        groups = da_sorted[self.group_dim].values\n        data_name = str(da.name) if da.name else self.x\n\n        if self.x_range is None:\n            vmin = float(da.min().compute())\n            vmax = float(da.max().compute())\n        else:\n            vmin, vmax = self.x_range\n\n        if np.isnan(vmin) or np.isnan(vmax):\n            raise ValueError(\"No valid data points found to plot.\")\n\n    else:\n        # Pandas DataFrame\n        df = self.data\n        if self.x is None:\n            # Try to find a numeric column that is not group_dim\n            numeric_cols = df.select_dtypes(include=[np.number]).columns\n            cols_to_use = [c for c in numeric_cols if c != self.group_dim]\n            if not cols_to_use:\n                raise ValueError(\"No numeric columns found in DataFrame to plot.\")\n            self.x = cols_to_use[0]\n\n        df_sorted = df.sort_values(self.group_dim, ascending=False)\n        groups = df_sorted[self.group_dim].unique()\n        data_name = str(self.x)\n\n        if self.x_range is None:\n            vmin = float(df[self.x].min())\n            vmax = float(df[self.x].max())\n        else:\n            vmin, vmax = self.x_range\n\n        if np.isnan(vmin) or np.isnan(vmax):\n            raise ValueError(\"No valid data points found to plot.\")\n\n    # Setup X-axis grid for density calculation\n    if self.x_range is None:\n        pad = (vmax - vmin) * 0.1\n        x_grid = np.linspace(vmin - pad, vmax + pad, 200)\n    else:\n        x_grid = np.linspace(vmin, vmax, 200)\n\n    # Setup Colors\n    cmap, norm = get_linear_scale(None, cmap=self.cmap_name, vmin=vmin, vmax=vmax)\n\n    # 2. Iterate and Plot\n    for i, val in enumerate(groups):\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            # Handle DataArray/Dataset slice\n            data_slice = da_sorted.sel({self.group_dim: val}).values.flatten()\n        else:\n            # Handle DataFrame slice\n            data_slice = df_sorted[df_sorted[self.group_dim] == val][\n                self.x\n            ].values.flatten()\n\n        data_slice = data_slice[~np.isnan(data_slice)]\n\n        if len(data_slice) &lt; 2:\n            continue\n\n        try:\n            kde = gaussian_kde(data_slice, bw_method=self.bw_method)\n            y_density = kde(x_grid)\n        except (np.linalg.LinAlgError, ValueError):\n            continue\n\n        # Scale density and calculate vertical baseline\n        y_density_scaled = y_density * self.scale_factor\n        baseline = -i * self.overlap\n        y_final = baseline + y_density_scaled\n\n        # Plot filling\n        if color_by_group:\n            # Use qualitative cmap or indexed colors\n            color = plt.get_cmap(\"tab10\")(i % 10)\n            self.ax.fill_between(\n                x_grid,\n                baseline,\n                y_final,\n                facecolor=color,\n                edgecolor=\"white\",\n                linewidth=0.5,\n                alpha=self.alpha,\n                zorder=len(groups) - i,\n            )\n            self.ax.plot(\n                x_grid,\n                y_final,\n                color=\"black\",\n                linewidth=0.5,\n                zorder=len(groups) - i + 0.1,\n            )\n        elif gradient:\n            # Plot in segments to create a gradient effect\n            for j in range(len(x_grid) - 1):\n                self.ax.fill_between(\n                    x_grid[j : j + 2],\n                    baseline,\n                    y_final[j : j + 2],\n                    facecolor=cmap(norm(x_grid[j])),\n                    edgecolor=\"none\",\n                    alpha=self.alpha,\n                    zorder=len(groups) - i,\n                )\n            # Add a clean top outline\n            self.ax.plot(\n                x_grid,\n                y_final,\n                color=\"black\",\n                linewidth=0.5,\n                zorder=len(groups) - i + 0.1,\n            )\n        else:\n            # Single color based on the mean of this slice\n            slice_mean = np.mean(data_slice)\n            color = cmap(norm(slice_mean))\n            self.ax.fill_between(\n                x_grid,\n                baseline,\n                y_final,\n                facecolor=color,\n                edgecolor=\"white\",\n                linewidth=0.5,\n                alpha=self.alpha,\n                zorder=len(groups) - i,\n            )\n            self.ax.plot(\n                x_grid,\n                y_final,\n                color=\"black\",\n                linewidth=0.5,\n                zorder=len(groups) - i + 0.1,\n            )\n\n        # 3. Add Quantiles\n        if self.quantiles is not None:\n            q_values = np.quantile(data_slice, self.quantiles)\n            q_densities = kde(q_values) * self.scale_factor\n            for qv, qd in zip(q_values, q_densities):\n                self.ax.vlines(\n                    qv,\n                    baseline,\n                    baseline + qd,\n                    color=\"black\",\n                    linestyle=\"--\",\n                    linewidth=0.8,\n                    zorder=len(groups) - i + 0.2,\n                )\n\n    # 3. Final Formatting\n    self.ax.set_yticks([-i * self.overlap for i in range(len(groups))])\n    self.ax.set_yticklabels(groups)\n    self.ax.set_xlabel(data_name)\n    if self.title:\n        self.ax.set_title(self.title, pad=20)\n\n    # Add Colorbar matching the x-axis scale if not coloring by group\n    if not color_by_group:\n        mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n        self.add_colorbar(mappable, label=data_name)\n\n    # Add vertical gridlines as seen in the reference\n    self.ax.xaxis.grid(True, linestyle=\"-\", alpha=0.3)\n\n    # Add a vertical zero line if the range crosses zero\n    if x_grid.min() &lt; 0 and x_grid.max() &gt; 0:\n        self.ax.axvline(0, color=\"black\", alpha=0.3, linestyle=\"--\", linewidth=1)\n\n    # Remove unnecessary spines\n    self.ax.spines[\"top\"].set_visible(False)\n    self.ax.spines[\"right\"].set_visible(False)\n    self.ax.spines[\"left\"].set_visible(False)\n\n    if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n        _update_history(self.data, f\"Created ridgeline plot for {data_name}\")\n\n    return self.ax\n</code></pre>"},{"location":"plots/roc_curve/","title":"ROC Curve","text":""},{"location":"plots/roc_curve/#monet_plots.plots.roc_curve.ROCCurvePlot","title":"<code>ROCCurvePlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Receiver Operating Characteristic (ROC) Curve Plot.</p> <p>Visualizes the trade-off between Probability of Detection (POD) and Probability of False Detection (POFD).</p> <p>Functional Requirements: 1. Plot POD (y-axis) vs POFD (x-axis). 2. Draw diagonal \"no skill\" line (0,0) to (1,1). 3. Calculate and display Area Under Curve (AUC) in legend. 4. Support multiple models/curves via grouping.</p> <p>Edge Cases: - Non-monotonic data points (should sort by threshold/prob). - Single point provided (cannot calculate AUC properly, return NaN or handle gracefully). - Missing columns.</p> Source code in <code>src/monet_plots/plots/roc_curve.py</code> <pre><code>class ROCCurvePlot(BasePlot):\n    \"\"\"\n    Receiver Operating Characteristic (ROC) Curve Plot.\n\n    Visualizes the trade-off between Probability of Detection (POD) and\n    Probability of False Detection (POFD).\n\n    Functional Requirements:\n    1. Plot POD (y-axis) vs POFD (x-axis).\n    2. Draw diagonal \"no skill\" line (0,0) to (1,1).\n    3. Calculate and display Area Under Curve (AUC) in legend.\n    4. Support multiple models/curves via grouping.\n\n    Edge Cases:\n    - Non-monotonic data points (should sort by threshold/prob).\n    - Single point provided (cannot calculate AUC properly, return NaN or handle gracefully).\n    - Missing columns.\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        x_col: str = \"pofd\",\n        y_col: str = \"pod\",\n        label_col: Optional[str] = None,\n        show_auc: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data containing ROC points.\n            x_col (str): Column name for POFD (False Alarm Rate).\n            y_col (str): Column name for POD (Hit Rate).\n            label_col (str, optional): Column for grouping different curves.\n            show_auc (bool): Whether to calculate and append AUC to labels.\n            **kwargs: Matplotlib kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        # TDD Anchor: Test validation raises error on missing cols\n        validate_dataframe(df, required_columns=[x_col, y_col])\n\n        # Draw No Skill Line\n        self.ax.plot([0, 1], [0, 1], \"k--\", label=\"No Skill\", alpha=0.5)\n        self.ax.grid(True, alpha=0.3)\n\n        if label_col:\n            groups = df.groupby(label_col)\n            for name, group in groups:\n                self._plot_single_curve(\n                    group, x_col, y_col, label=str(name), show_auc=show_auc, **kwargs\n                )\n            self.ax.legend(loc=\"lower right\")\n        else:\n            self._plot_single_curve(\n                df, x_col, y_col, label=\"Model\", show_auc=show_auc, **kwargs\n            )\n\n        # Formatting\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 1)\n        self.ax.set_xlabel(\"Probability of False Detection (POFD)\")\n        self.ax.set_ylabel(\"Probability of Detection (POD)\")\n        self.ax.set_aspect(\"equal\")\n\n    def _plot_single_curve(self, df, x_col, y_col, label, show_auc, **kwargs):\n        \"\"\"\n        Helper to plot a single ROC curve and calc AUC.\n\n        Pseudocode:\n        1. Sort df by x_col (POFD) ascending.\n        2. Get x (POFD) and y (POD) arrays.\n        3. If show_auc:\n            auc = trapz(y, x)\n            label += f\" (AUC={auc:.3f})\"\n        4. self.ax.plot(x, y, label=label, **kwargs)\n        \"\"\"\n        # TDD Anchor: Test AUC calculation against sklearn.metrics.auc or manual known\n        # values.\n        # TDD Anchor: Ensure sorting is applied correctly.\n\n        df_sorted = df.sort_values(by=x_col).dropna(subset=[x_col, y_col])\n        x = df_sorted[x_col].values\n        y = df_sorted[y_col].values\n\n        auc_str = \"\"\n        if len(x) &gt;= 2 and show_auc:\n            auc = compute_auc(x, y)\n            auc_str = f\" (AUC={auc:.3f})\"\n\n        full_label = label + auc_str\n        self.ax.plot(x, y, label=full_label, **kwargs)\n        self.ax.fill_between(x, 0, y, alpha=0.2, **kwargs)\n</code></pre>"},{"location":"plots/roc_curve/#monet_plots.plots.roc_curve.ROCCurvePlot.plot","title":"<code>plot(data, x_col='pofd', y_col='pod', label_col=None, show_auc=True, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Input data containing ROC points.</p> required <code>x_col</code> <code>str</code> <p>Column name for POFD (False Alarm Rate).</p> <code>'pofd'</code> <code>y_col</code> <code>str</code> <p>Column name for POD (Hit Rate).</p> <code>'pod'</code> <code>label_col</code> <code>str</code> <p>Column for grouping different curves.</p> <code>None</code> <code>show_auc</code> <code>bool</code> <p>Whether to calculate and append AUC to labels.</p> <code>True</code> <code>**kwargs</code> <p>Matplotlib kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/roc_curve.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    x_col: str = \"pofd\",\n    y_col: str = \"pod\",\n    label_col: Optional[str] = None,\n    show_auc: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Input data containing ROC points.\n        x_col (str): Column name for POFD (False Alarm Rate).\n        y_col (str): Column name for POD (Hit Rate).\n        label_col (str, optional): Column for grouping different curves.\n        show_auc (bool): Whether to calculate and append AUC to labels.\n        **kwargs: Matplotlib kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    # TDD Anchor: Test validation raises error on missing cols\n    validate_dataframe(df, required_columns=[x_col, y_col])\n\n    # Draw No Skill Line\n    self.ax.plot([0, 1], [0, 1], \"k--\", label=\"No Skill\", alpha=0.5)\n    self.ax.grid(True, alpha=0.3)\n\n    if label_col:\n        groups = df.groupby(label_col)\n        for name, group in groups:\n            self._plot_single_curve(\n                group, x_col, y_col, label=str(name), show_auc=show_auc, **kwargs\n            )\n        self.ax.legend(loc=\"lower right\")\n    else:\n        self._plot_single_curve(\n            df, x_col, y_col, label=\"Model\", show_auc=show_auc, **kwargs\n        )\n\n    # Formatting\n    self.ax.set_xlim(0, 1)\n    self.ax.set_ylim(0, 1)\n    self.ax.set_xlabel(\"Probability of False Detection (POFD)\")\n    self.ax.set_ylabel(\"Probability of Detection (POD)\")\n    self.ax.set_aspect(\"equal\")\n</code></pre>"},{"location":"plots/scatter/","title":"Scatter Plots","text":"<p>Scatter plot with regression line supporting lazy evaluation.</p>"},{"location":"plots/scatter/#monet_plots.plots.scatter.ScatterPlot","title":"<code>ScatterPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a scatter plot with a regression line.</p> <p>This plot shows the relationship between two variables and includes a linear regression model fit. It supports lazy evaluation for large Xarray/Dask datasets by delaying computation until the plot call.</p>"},{"location":"plots/scatter/#monet_plots.plots.scatter.ScatterPlot--attributes","title":"Attributes","text":"<p>data : Union[xr.Dataset, xr.DataArray, pd.DataFrame]     The input data for the plot. x : str     The name of the variable for the x-axis. y : List[str]     The names of the variables for the y-axis. c : Optional[str]     The name of the variable used for colorizing points. colorbar : bool     Whether to add a colorbar to the plot. title : Optional[str]     The title for the plot.</p> Source code in <code>src/monet_plots/plots/scatter.py</code> <pre><code>class ScatterPlot(BasePlot):\n    \"\"\"Create a scatter plot with a regression line.\n\n    This plot shows the relationship between two variables and includes a\n    linear regression model fit. It supports lazy evaluation for large\n    Xarray/Dask datasets by delaying computation until the plot call.\n\n    Attributes\n    ----------\n    data : Union[xr.Dataset, xr.DataArray, pd.DataFrame]\n        The input data for the plot.\n    x : str\n        The name of the variable for the x-axis.\n    y : List[str]\n        The names of the variables for the y-axis.\n    c : Optional[str]\n        The name of the variable used for colorizing points.\n    colorbar : bool\n        Whether to add a colorbar to the plot.\n    title : Optional[str]\n        The title for the plot.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: Any = None,\n        x: Optional[str] = None,\n        y: Optional[Union[str, List[str]]] = None,\n        c: Optional[str] = None,\n        colorbar: bool = False,\n        title: Optional[str] = None,\n        fig: Optional[matplotlib.figure.Figure] = None,\n        ax: Optional[matplotlib.axes.Axes] = None,\n        df: Any = None,  # Backward compatibility alias\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the scatter plot.\n\n        Parameters\n        ----------\n        data : Any, optional\n            Input data. Can be a pandas DataFrame, xarray DataArray,\n            xarray Dataset, or numpy ndarray.\n        x : str, optional\n            Variable name for the x-axis.\n        y : Union[str, List[str]], optional\n            Variable name(s) for the y-axis.\n        c : str, optional\n            Variable name for colorizing the points, by default None.\n        colorbar : bool, optional\n            Whether to add a colorbar, by default False.\n        title : str, optional\n            Title for the plot, by default None.\n        fig : matplotlib.figure.Figure, optional\n            An existing Figure object.\n        ax : matplotlib.axes.Axes, optional\n            An existing Axes object.\n        df : Any, optional\n            Alias for `data` for backward compatibility.\n        **kwargs : Any\n            Additional keyword arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(fig=fig, ax=ax, **kwargs)\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1)\n\n        self.data = normalize_data(data if data is not None else df)\n        self.x = x\n        self.y = [y] if isinstance(y, str) else (y if y is not None else [])\n        self.c = c\n        self.colorbar = colorbar\n        self.title = title\n\n        if not self.x or not self.y:\n            raise ValueError(\"Parameters 'x' and 'y' must be provided.\")\n\n        # Update history for provenance if Xarray\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            history = self.data.attrs.get(\"history\", \"\")\n            self.data.attrs[\"history\"] = f\"Initialized ScatterPlot; {history}\"\n\n    def _get_regression_line(\n        self, x_val: np.ndarray, y_val: np.ndarray\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Calculate regression line points using only endpoints.\n\n        Parameters\n        ----------\n        x_val : np.ndarray\n            The concrete x-axis data.\n        y_val : np.ndarray\n            The concrete y-axis data.\n\n        Returns\n        -------\n        tuple[np.ndarray, np.ndarray]\n            The x and y values for the regression line endpoints.\n        \"\"\"\n        mask = ~np.isnan(x_val) &amp; ~np.isnan(y_val)\n        if not np.any(mask):\n            return np.array([np.nan, np.nan]), np.array([np.nan, np.nan])\n\n        m, b = np.polyfit(x_val[mask], y_val[mask], 1)\n        x_min, x_max = np.nanmin(x_val), np.nanmax(x_val)\n        x_reg = np.array([x_min, x_max])\n        y_reg = m * x_reg + b\n        return x_reg, y_reg\n\n    def plot(\n        self,\n        scatter_kws: Optional[dict[str, Any]] = None,\n        line_kws: Optional[dict[str, Any]] = None,\n        **kwargs: Any,\n    ) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the scatter plot.\n\n        Parameters\n        ----------\n        scatter_kws : dict, optional\n            Additional keyword arguments for `ax.scatter`.\n        line_kws : dict, optional\n            Additional keyword arguments for the regression `ax.plot`.\n        **kwargs : Any\n            Secondary way to pass keyword arguments to `ax.scatter`.\n            Merged with `scatter_kws`.\n\n        Returns\n        -------\n        matplotlib.axes.Axes\n            The axes object with the scatter plot.\n\n        Notes\n        -----\n        For massive datasets (&gt; RAM), consider using Track B (Exploration)\n        tools like `hvplot` with `rasterize=True`.\n        \"\"\"\n        from ..plot_utils import get_plot_kwargs\n\n        # Combine scatter_kws and kwargs\n        s_kws = scatter_kws.copy() if scatter_kws is not None else {}\n        s_kws.update(kwargs)\n\n        l_kws = line_kws.copy() if line_kws is not None else {}\n\n        # Aero Protocol Requirement: Mandatory transform for GeoAxes\n        is_geo = hasattr(self.ax, \"projection\")\n        if is_geo:\n            s_kws.setdefault(\"transform\", ccrs.PlateCarree())\n            l_kws.setdefault(\"transform\", ccrs.PlateCarree())\n\n        transform = s_kws.get(\"transform\")\n\n        # Performance: Compute required variables once to avoid double work\n        cols = [self.x] + self.y\n        if self.c:\n            cols.append(self.c)\n\n        if hasattr(self.data, \"compute\"):\n            # Sub-selection before compute to minimize data transfer\n            subset = self.data[cols]\n            concrete_data = subset.compute()\n        else:\n            concrete_data = self.data\n\n        x_plot = concrete_data[self.x].values.flatten()\n\n        for y_col in self.y:\n            y_plot = concrete_data[y_col].values.flatten()\n\n            if self.c is not None:\n                c_plot = concrete_data[self.c].values.flatten()\n\n                final_s_kwargs = get_plot_kwargs(c=c_plot, **s_kws)\n                mappable = self.ax.scatter(x_plot, y_plot, **final_s_kwargs)\n\n                if self.colorbar:\n                    self.add_colorbar(mappable)\n            else:\n                final_s_kwargs = s_kws.copy()\n                final_s_kwargs.setdefault(\"label\", y_col)\n                self.ax.scatter(x_plot, y_plot, **final_s_kwargs)\n\n            # Add regression line using endpoints\n            x_reg, y_reg = self._get_regression_line(x_plot, y_plot)\n\n            final_l_kwargs = {\n                \"color\": \"red\",\n                \"linestyle\": \"--\",\n                \"label\": \"Fit\" if (self.c is None and len(self.y) == 1) else None,\n            }\n            final_l_kwargs.update(l_kws)\n            if transform:\n                final_l_kwargs.setdefault(\"transform\", transform)\n\n            self.ax.plot(x_reg, y_reg, **final_l_kwargs)\n\n        if len(self.y) &gt; 1 and self.c is None:\n            self.ax.legend()\n\n        if self.title:\n            self.ax.set_title(self.title)\n        else:\n            self.ax.set_title(f\"Scatter: {self.x} vs {', '.join(self.y)}\")\n\n        self.ax.set_xlabel(self.x)\n        self.ax.set_ylabel(\", \".join(self.y) if len(self.y) &gt; 1 else self.y[0])\n\n        # Update history for provenance\n        if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n            history = self.data.attrs.get(\"history\", \"\")\n            self.data.attrs[\"history\"] = f\"Generated ScatterPlot; {history}\"\n\n        return self.ax\n</code></pre>"},{"location":"plots/scatter/#monet_plots.plots.scatter.ScatterPlot.__init__","title":"<code>__init__(data=None, x=None, y=None, c=None, colorbar=False, title=None, fig=None, ax=None, df=None, **kwargs)</code>","text":"<p>Initialize the scatter plot.</p>"},{"location":"plots/scatter/#monet_plots.plots.scatter.ScatterPlot.__init__--parameters","title":"Parameters","text":"<p>data : Any, optional     Input data. Can be a pandas DataFrame, xarray DataArray,     xarray Dataset, or numpy ndarray. x : str, optional     Variable name for the x-axis. y : Union[str, List[str]], optional     Variable name(s) for the y-axis. c : str, optional     Variable name for colorizing the points, by default None. colorbar : bool, optional     Whether to add a colorbar, by default False. title : str, optional     Title for the plot, by default None. fig : matplotlib.figure.Figure, optional     An existing Figure object. ax : matplotlib.axes.Axes, optional     An existing Axes object. df : Any, optional     Alias for <code>data</code> for backward compatibility. **kwargs : Any     Additional keyword arguments passed to BasePlot.</p> Source code in <code>src/monet_plots/plots/scatter.py</code> <pre><code>def __init__(\n    self,\n    data: Any = None,\n    x: Optional[str] = None,\n    y: Optional[Union[str, List[str]]] = None,\n    c: Optional[str] = None,\n    colorbar: bool = False,\n    title: Optional[str] = None,\n    fig: Optional[matplotlib.figure.Figure] = None,\n    ax: Optional[matplotlib.axes.Axes] = None,\n    df: Any = None,  # Backward compatibility alias\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the scatter plot.\n\n    Parameters\n    ----------\n    data : Any, optional\n        Input data. Can be a pandas DataFrame, xarray DataArray,\n        xarray Dataset, or numpy ndarray.\n    x : str, optional\n        Variable name for the x-axis.\n    y : Union[str, List[str]], optional\n        Variable name(s) for the y-axis.\n    c : str, optional\n        Variable name for colorizing the points, by default None.\n    colorbar : bool, optional\n        Whether to add a colorbar, by default False.\n    title : str, optional\n        Title for the plot, by default None.\n    fig : matplotlib.figure.Figure, optional\n        An existing Figure object.\n    ax : matplotlib.axes.Axes, optional\n        An existing Axes object.\n    df : Any, optional\n        Alias for `data` for backward compatibility.\n    **kwargs : Any\n        Additional keyword arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(fig=fig, ax=ax, **kwargs)\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1)\n\n    self.data = normalize_data(data if data is not None else df)\n    self.x = x\n    self.y = [y] if isinstance(y, str) else (y if y is not None else [])\n    self.c = c\n    self.colorbar = colorbar\n    self.title = title\n\n    if not self.x or not self.y:\n        raise ValueError(\"Parameters 'x' and 'y' must be provided.\")\n\n    # Update history for provenance if Xarray\n    if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n        history = self.data.attrs.get(\"history\", \"\")\n        self.data.attrs[\"history\"] = f\"Initialized ScatterPlot; {history}\"\n</code></pre>"},{"location":"plots/scatter/#monet_plots.plots.scatter.ScatterPlot.plot","title":"<code>plot(scatter_kws=None, line_kws=None, **kwargs)</code>","text":"<p>Generate the scatter plot.</p>"},{"location":"plots/scatter/#monet_plots.plots.scatter.ScatterPlot.plot--parameters","title":"Parameters","text":"<p>scatter_kws : dict, optional     Additional keyword arguments for <code>ax.scatter</code>. line_kws : dict, optional     Additional keyword arguments for the regression <code>ax.plot</code>. **kwargs : Any     Secondary way to pass keyword arguments to <code>ax.scatter</code>.     Merged with <code>scatter_kws</code>.</p>"},{"location":"plots/scatter/#monet_plots.plots.scatter.ScatterPlot.plot--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The axes object with the scatter plot.</p>"},{"location":"plots/scatter/#monet_plots.plots.scatter.ScatterPlot.plot--notes","title":"Notes","text":"<p>For massive datasets (&gt; RAM), consider using Track B (Exploration) tools like <code>hvplot</code> with <code>rasterize=True</code>.</p> Source code in <code>src/monet_plots/plots/scatter.py</code> <pre><code>def plot(\n    self,\n    scatter_kws: Optional[dict[str, Any]] = None,\n    line_kws: Optional[dict[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the scatter plot.\n\n    Parameters\n    ----------\n    scatter_kws : dict, optional\n        Additional keyword arguments for `ax.scatter`.\n    line_kws : dict, optional\n        Additional keyword arguments for the regression `ax.plot`.\n    **kwargs : Any\n        Secondary way to pass keyword arguments to `ax.scatter`.\n        Merged with `scatter_kws`.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The axes object with the scatter plot.\n\n    Notes\n    -----\n    For massive datasets (&gt; RAM), consider using Track B (Exploration)\n    tools like `hvplot` with `rasterize=True`.\n    \"\"\"\n    from ..plot_utils import get_plot_kwargs\n\n    # Combine scatter_kws and kwargs\n    s_kws = scatter_kws.copy() if scatter_kws is not None else {}\n    s_kws.update(kwargs)\n\n    l_kws = line_kws.copy() if line_kws is not None else {}\n\n    # Aero Protocol Requirement: Mandatory transform for GeoAxes\n    is_geo = hasattr(self.ax, \"projection\")\n    if is_geo:\n        s_kws.setdefault(\"transform\", ccrs.PlateCarree())\n        l_kws.setdefault(\"transform\", ccrs.PlateCarree())\n\n    transform = s_kws.get(\"transform\")\n\n    # Performance: Compute required variables once to avoid double work\n    cols = [self.x] + self.y\n    if self.c:\n        cols.append(self.c)\n\n    if hasattr(self.data, \"compute\"):\n        # Sub-selection before compute to minimize data transfer\n        subset = self.data[cols]\n        concrete_data = subset.compute()\n    else:\n        concrete_data = self.data\n\n    x_plot = concrete_data[self.x].values.flatten()\n\n    for y_col in self.y:\n        y_plot = concrete_data[y_col].values.flatten()\n\n        if self.c is not None:\n            c_plot = concrete_data[self.c].values.flatten()\n\n            final_s_kwargs = get_plot_kwargs(c=c_plot, **s_kws)\n            mappable = self.ax.scatter(x_plot, y_plot, **final_s_kwargs)\n\n            if self.colorbar:\n                self.add_colorbar(mappable)\n        else:\n            final_s_kwargs = s_kws.copy()\n            final_s_kwargs.setdefault(\"label\", y_col)\n            self.ax.scatter(x_plot, y_plot, **final_s_kwargs)\n\n        # Add regression line using endpoints\n        x_reg, y_reg = self._get_regression_line(x_plot, y_plot)\n\n        final_l_kwargs = {\n            \"color\": \"red\",\n            \"linestyle\": \"--\",\n            \"label\": \"Fit\" if (self.c is None and len(self.y) == 1) else None,\n        }\n        final_l_kwargs.update(l_kws)\n        if transform:\n            final_l_kwargs.setdefault(\"transform\", transform)\n\n        self.ax.plot(x_reg, y_reg, **final_l_kwargs)\n\n    if len(self.y) &gt; 1 and self.c is None:\n        self.ax.legend()\n\n    if self.title:\n        self.ax.set_title(self.title)\n    else:\n        self.ax.set_title(f\"Scatter: {self.x} vs {', '.join(self.y)}\")\n\n    self.ax.set_xlabel(self.x)\n    self.ax.set_ylabel(\", \".join(self.y) if len(self.y) &gt; 1 else self.y[0])\n\n    # Update history for provenance\n    if isinstance(self.data, (xr.DataArray, xr.Dataset)):\n        history = self.data.attrs.get(\"history\", \"\")\n        self.data.attrs[\"history\"] = f\"Generated ScatterPlot; {history}\"\n\n    return self.ax\n</code></pre>"},{"location":"plots/scorecard/","title":"Scorecard","text":""},{"location":"plots/scorecard/#monet_plots.plots.scorecard.ScorecardPlot","title":"<code>ScorecardPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Scorecard Plot.</p> <p>Heatmap table displaying performance metrics across multiple dimensions (e.g., Variables vs Lead Times), colored by performance relative to a baseline.</p> <p>Functional Requirements: 1. Heatmap grid: Rows (Variables/Regions), Cols (Lead Times/Levels). 2. Color cells based on statistic (e.g., Difference from Baseline, RMSE ratio). 3. Annotate cells with symbols (+/-) or values indicating significance. 4. Handle Green (Better) / Red (Worse) color schemes correctly.</p> <p>Edge Cases: - Missing data for some cells (show as white/gray). - Infinite values (clip or mask).</p> Source code in <code>src/monet_plots/plots/scorecard.py</code> <pre><code>class ScorecardPlot(BasePlot):\n    \"\"\"\n    Scorecard Plot.\n\n    Heatmap table displaying performance metrics across multiple dimensions\n    (e.g., Variables vs Lead Times), colored by performance relative to a baseline.\n\n    Functional Requirements:\n    1. Heatmap grid: Rows (Variables/Regions), Cols (Lead Times/Levels).\n    2. Color cells based on statistic (e.g., Difference from Baseline, RMSE ratio).\n    3. Annotate cells with symbols (+/-) or values indicating significance.\n    4. Handle Green (Better) / Red (Worse) color schemes correctly.\n\n    Edge Cases:\n    - Missing data for some cells (show as white/gray).\n    - Infinite values (clip or mask).\n    \"\"\"\n\n    def __init__(self, fig=None, ax=None, **kwargs):\n        super().__init__(fig=fig, ax=ax, **kwargs)\n\n    def plot(\n        self,\n        data: Any,\n        x_col: str,\n        y_col: str,\n        val_col: str,\n        sig_col: Optional[str] = None,\n        cmap: str = \"RdYlGn\",\n        center: float = 0.0,\n        **kwargs,\n    ):\n        \"\"\"\n        Main plotting method.\n\n        Args:\n            data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Long-format dataframe.\n            x_col (str): Column for x-axis (Columns).\n            y_col (str): Column for y-axis (Rows).\n            val_col (str): Column for cell values (color).\n            sig_col (str, optional): Column for significance (marker).\n            cmap (str): Colormap.\n            center (float): Center value for colormap divergence.\n            **kwargs: Seaborn heatmap kwargs.\n        \"\"\"\n        df = to_dataframe(data)\n        validate_dataframe(df, required_columns=[x_col, y_col, val_col])\n\n        # Pivot Data\n        pivot_data = df.pivot(index=y_col, columns=x_col, values=val_col)\n\n        # TDD Anchor: Test pivot structure\n\n        # Plot Heatmap\n        sns.heatmap(\n            pivot_data,\n            ax=self.ax,\n            cmap=cmap,\n            center=center,\n            annot=True,\n            fmt=\".2f\",\n            cbar_kws={\"label\": \"Relative Performance\"},\n            **kwargs,\n        )\n\n        # Add Significance Markers\n        if sig_col:\n            pivot_sig = df.pivot(index=y_col, columns=x_col, values=sig_col)\n            self._overlay_significance(pivot_data, pivot_sig)\n\n        self.ax.set_xlabel(x_col.title())\n        self.ax.set_ylabel(y_col.title())\n        self.ax.tick_params(axis=\"x\", rotation=45)\n        self.ax.set_title(\"Performance Scorecard\")\n\n    def _overlay_significance(self, data_grid, sig_grid):\n        \"\"\"\n        Overlays markers for significant differences.\n\n        Assumes sig_grid contains boolean or truthy values for significance.\n        \"\"\"\n        rows, cols = data_grid.shape\n        for i in range(rows):\n            for j in range(cols):\n                sig_val = sig_grid.iloc[i, j]\n                if pd.notna(sig_val) and bool(sig_val):\n                    # Position at center of cell\n                    self.ax.text(\n                        j + 0.5,\n                        rows - i - 0.5,\n                        \"*\",\n                        ha=\"center\",\n                        va=\"center\",\n                        fontweight=\"bold\",\n                        fontsize=12,\n                        color=\"black\",\n                        zorder=5,\n                    )\n</code></pre>"},{"location":"plots/scorecard/#monet_plots.plots.scorecard.ScorecardPlot.plot","title":"<code>plot(data, x_col, y_col, val_col, sig_col=None, cmap='RdYlGn', center=0.0, **kwargs)</code>","text":"<p>Main plotting method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>Long-format dataframe.</p> required <code>x_col</code> <code>str</code> <p>Column for x-axis (Columns).</p> required <code>y_col</code> <code>str</code> <p>Column for y-axis (Rows).</p> required <code>val_col</code> <code>str</code> <p>Column for cell values (color).</p> required <code>sig_col</code> <code>str</code> <p>Column for significance (marker).</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Colormap.</p> <code>'RdYlGn'</code> <code>center</code> <code>float</code> <p>Center value for colormap divergence.</p> <code>0.0</code> <code>**kwargs</code> <p>Seaborn heatmap kwargs.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/scorecard.py</code> <pre><code>def plot(\n    self,\n    data: Any,\n    x_col: str,\n    y_col: str,\n    val_col: str,\n    sig_col: Optional[str] = None,\n    cmap: str = \"RdYlGn\",\n    center: float = 0.0,\n    **kwargs,\n):\n    \"\"\"\n    Main plotting method.\n\n    Args:\n        data (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): Long-format dataframe.\n        x_col (str): Column for x-axis (Columns).\n        y_col (str): Column for y-axis (Rows).\n        val_col (str): Column for cell values (color).\n        sig_col (str, optional): Column for significance (marker).\n        cmap (str): Colormap.\n        center (float): Center value for colormap divergence.\n        **kwargs: Seaborn heatmap kwargs.\n    \"\"\"\n    df = to_dataframe(data)\n    validate_dataframe(df, required_columns=[x_col, y_col, val_col])\n\n    # Pivot Data\n    pivot_data = df.pivot(index=y_col, columns=x_col, values=val_col)\n\n    # TDD Anchor: Test pivot structure\n\n    # Plot Heatmap\n    sns.heatmap(\n        pivot_data,\n        ax=self.ax,\n        cmap=cmap,\n        center=center,\n        annot=True,\n        fmt=\".2f\",\n        cbar_kws={\"label\": \"Relative Performance\"},\n        **kwargs,\n    )\n\n    # Add Significance Markers\n    if sig_col:\n        pivot_sig = df.pivot(index=y_col, columns=x_col, values=sig_col)\n        self._overlay_significance(pivot_data, pivot_sig)\n\n    self.ax.set_xlabel(x_col.title())\n    self.ax.set_ylabel(y_col.title())\n    self.ax.tick_params(axis=\"x\", rotation=45)\n    self.ax.set_title(\"Performance Scorecard\")\n</code></pre>"},{"location":"plots/soccer/","title":"Soccer Plot","text":"<p>The Soccer Plot is a model evaluation tool that plots model bias against error. It typically shows Mean Fractional Bias (MFB) or Normalized Mean Bias (NMB) on the x-axis and Mean Fractional Error (MFE) or Normalized Mean Error (NME) on the y-axis.</p>"},{"location":"plots/soccer/#example","title":"Example","text":"<pre><code>from monet_plots.plots import SoccerPlot\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'obs': [10, 20, 30],\n    'mod': [12, 18, 35]\n})\n\nplot = SoccerPlot(df, obs_col='obs', mod_col='mod')\nplot.plot()\n</code></pre>"},{"location":"plots/soccer/#parameters","title":"Parameters","text":"<ul> <li><code>data</code>: Input data (DataFrame, DataArray, etc.)</li> <li><code>obs_col</code>: Column name for observations.</li> <li><code>mod_col</code>: Column name for model values.</li> <li><code>goal</code>: Dictionary with 'bias' and 'error' thresholds for the goal zone.</li> <li><code>criteria</code>: Dictionary with 'bias' and 'error' thresholds for the criteria zone.</li> </ul>"},{"location":"plots/spatial/","title":"Spatial Plots","text":""},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialPlot","title":"<code>SpatialPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>A base class for creating spatial plots with cartopy.</p> <p>This class provides a high-level interface for geospatial plots, handling the setup of cartopy axes and the addition of common map features like coastlines, states, and gridlines.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialPlot--attributes","title":"Attributes","text":"<p>resolution : str     The resolution of the cartopy features (e.g., '50m').</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>class SpatialPlot(BasePlot):\n    \"\"\"A base class for creating spatial plots with cartopy.\n\n    This class provides a high-level interface for geospatial plots, handling\n    the setup of cartopy axes and the addition of common map features like\n    coastlines, states, and gridlines.\n\n    Attributes\n    ----------\n    resolution : str\n        The resolution of the cartopy features (e.g., '50m').\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        projection: ccrs.Projection = ccrs.PlateCarree(),\n        fig: matplotlib.figure.Figure | None = None,\n        ax: matplotlib.axes.Axes | None = None,\n        figsize: tuple[float, float] | None = None,\n        subplot_kw: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize the spatial plot and draw map features.\n\n        This constructor sets up the matplotlib Figure and cartopy GeoAxes,\n        and provides a single interface to draw common map features like\n        coastlines and states.\n\n        Parameters\n        ----------\n        projection : ccrs.Projection, optional\n            The cartopy projection for the map, by default ccrs.PlateCarree().\n        fig : plt.Figure | None, optional\n            An existing matplotlib Figure object. If None, a new one is\n            created, by default None.\n        ax : plt.Axes | None, optional\n            An existing matplotlib Axes object. If None, a new one is created,\n            by default None.\n        figsize : tuple[float, float] | None, optional\n             Width, height in inches. If not provided, the matplotlib default\n             will be used.\n        subplot_kw : dict[str, Any] | None, optional\n            Keyword arguments passed to `fig.add_subplot`, by default None.\n            The 'projection' is added to these keywords automatically.\n        **kwargs : Any\n            Keyword arguments for map features, passed to `add_features`.\n            Common options include `coastlines`, `states`, `countries`,\n            `ocean`, `land`, `lakes`, `rivers`, `borders`, `gridlines`,\n            `extent`, and `resolution`.\n\n        Attributes\n        ----------\n        fig : plt.Figure\n            The matplotlib Figure object.\n        ax : plt.Axes\n            The matplotlib Axes (or GeoAxes) object.\n        resolution : str\n            The default resolution for cartopy features.\n        \"\"\"\n        # Ensure 'projection' is correctly passed to subplot creation.\n        current_subplot_kw = subplot_kw.copy() if subplot_kw else {}\n        current_subplot_kw[\"projection\"] = projection\n\n        self.resolution = kwargs.pop(\"resolution\", \"50m\")\n        style = kwargs.pop(\"style\", \"wiley\")\n\n        # Ensure coastlines are enabled by default if not specified.\n        if \"coastlines\" not in kwargs:\n            kwargs[\"coastlines\"] = True\n\n        # Initialize the base plot, which creates the figure and axes.\n        super().__init__(\n            fig=fig, ax=ax, figsize=figsize, style=style, subplot_kw=current_subplot_kw\n        )\n\n        # If BasePlot didn't create an axes (e.g. because fig was provided),\n        # create one now.\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1, **current_subplot_kw)\n\n        # If BasePlot didn't create an axes (e.g. because fig was provided),\n        # create one now.\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1, **current_subplot_kw)\n\n        # Add features from kwargs\n        self.add_features(**kwargs)\n\n    def _get_feature_registry(self, resolution: str) -&gt; dict[str, dict[str, Any]]:\n        \"\"\"Return a registry of cartopy features and their default styles.\n\n        This approach centralizes feature management, making it easier to\n        add new features and maintain existing ones.\n\n        Parameters\n        ----------\n        resolution : str\n            The resolution for the cartopy features (e.g., '10m', '50m').\n\n        Returns\n        -------\n        dict[str, dict[str, Any]]\n            A dictionary mapping feature names to a specification dictionary\n            containing the feature object and its default styling.\n        \"\"\"\n        from cartopy.feature import (\n            BORDERS,\n            COASTLINE,\n            LAKES,\n            LAND,\n            OCEAN,\n            RIVERS,\n            STATES,\n        )\n\n        # Define default styles, falling back to sane defaults if not in rcParams.\n        coastline_defaults = {\n            \"linewidth\": get_style_setting(\"coastline.width\", 0.5),\n            \"edgecolor\": get_style_setting(\"coastline.color\", \"black\"),\n            \"facecolor\": \"none\",\n        }\n        states_defaults = {\n            \"linewidth\": get_style_setting(\"states.width\", 0.5),\n            \"edgecolor\": get_style_setting(\"states.color\", \"black\"),\n            \"facecolor\": \"none\",\n        }\n        borders_defaults = {\n            \"linewidth\": get_style_setting(\"borders.width\", 0.5),\n            \"edgecolor\": get_style_setting(\"borders.color\", \"black\"),\n            \"facecolor\": \"none\",\n        }\n\n        feature_mapping = {\n            \"coastlines\": {\n                \"feature\": COASTLINE.with_scale(resolution),\n                \"defaults\": coastline_defaults,\n            },\n            \"countries\": {\n                \"feature\": BORDERS.with_scale(resolution),\n                \"defaults\": borders_defaults,\n            },\n            \"states\": {\n                \"feature\": STATES.with_scale(resolution),\n                \"defaults\": states_defaults,\n            },\n            \"borders\": {\n                \"feature\": BORDERS.with_scale(resolution),\n                \"defaults\": borders_defaults,\n            },\n            \"ocean\": {\"feature\": OCEAN.with_scale(resolution), \"defaults\": {}},\n            \"land\": {\"feature\": LAND.with_scale(resolution), \"defaults\": {}},\n            \"rivers\": {\"feature\": RIVERS.with_scale(resolution), \"defaults\": {}},\n            \"lakes\": {\"feature\": LAKES.with_scale(resolution), \"defaults\": {}},\n            \"counties\": {\n                \"feature\": cfeature.NaturalEarthFeature(\n                    category=\"cultural\",\n                    name=\"admin_2_counties\",\n                    scale=resolution,\n                    facecolor=\"none\",\n                ),\n                \"defaults\": borders_defaults,\n            },\n        }\n        return feature_mapping\n\n    @staticmethod\n    def _get_style(\n        style: bool | dict[str, Any], defaults: dict[str, Any] | None = None\n    ) -&gt; dict[str, Any]:\n        \"\"\"Get a style dictionary for a feature.\n\n        Parameters\n        ----------\n        style : bool or dict[str, Any]\n            The user-provided style. If True, use defaults. If a dict, use it.\n        defaults : dict[str, Any], optional\n            The default style to apply if `style` is True.\n\n        Returns\n        -------\n        dict[str, Any]\n            The resolved keyword arguments for styling.\n        \"\"\"\n        if isinstance(style, dict):\n            return style\n        if style and defaults:\n            # Return a copy to prevent modifying the defaults dictionary in place\n            return defaults.copy()\n        return {}\n\n    def _draw_single_feature(\n        self, style_arg: bool | dict[str, Any], feature_spec: dict[str, Any]\n    ) -&gt; None:\n        \"\"\"Draw a single cartopy feature on the axes.\n\n        Parameters\n        ----------\n        style_arg : bool or dict[str, Any]\n            The user-provided style for the feature.\n        feature_spec : dict[str, Any]\n            A dictionary containing the feature object and default styles.\n        \"\"\"\n        if not style_arg:  # Allows for `coastlines=False`\n            return\n\n        style_kwargs = self._get_style(style_arg, feature_spec[\"defaults\"])\n        feature = feature_spec[\"feature\"]\n        self.ax.add_feature(feature, **style_kwargs)\n\n    def add_features(self, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Add and style cartopy features on the map axes.\n\n        This method provides a flexible, data-driven interface to add common\n        map features. Features can be enabled with a boolean flag (e.g.,\n        `coastlines=True`) or styled with a dictionary of keyword arguments\n        (e.g., `states=dict(linewidth=2, edgecolor='red')`).\n\n        The `extent` keyword is also supported to set the map boundaries.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Keyword arguments controlling the features to add and their\n            styles. Common options include `coastlines`, `states`,\n            `countries`, `ocean`, `land`, `lakes`, `rivers`, `borders`,\n            and `gridlines`.\n\n        Returns\n        -------\n        dict[str, Any]\n            A dictionary of the keyword arguments that were not used for\n            adding features. This can be useful for passing remaining\n            arguments to other functions.\n        \"\"\"\n        # Note: The order of these calls is important.\n        # Extent must be set before gridlines are drawn to ensure labels\n        # are placed correctly.\n        if \"extent\" in kwargs:\n            extent = kwargs.pop(\"extent\")\n            self._set_extent(extent)\n\n        if \"gridlines\" in kwargs:\n            gridline_style = kwargs.pop(\"gridlines\")\n            self._draw_gridlines(gridline_style)\n\n        # The rest of the kwargs are assumed to be for vector features.\n        remaining_kwargs = self._draw_features(**kwargs)\n\n        return remaining_kwargs\n\n    def _set_extent(self, extent: tuple[float, float, float, float] | None) -&gt; None:\n        \"\"\"Set the geographic extent of the map.\n\n        Parameters\n        ----------\n        extent : tuple[float, float, float, float] | None\n            The extent of the map as a tuple of (x_min, x_max, y_min, y_max).\n            If None, the extent is not changed.\n        \"\"\"\n        if extent is not None:\n            self.ax.set_extent(extent)\n\n    def _draw_features(self, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Draw vector features on the map.\n\n        This is the primary feature-drawing loop, responsible for adding\n        elements like coastlines, states, and borders.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Keyword arguments controlling the features to add and their\n            styles.\n\n        Returns\n        -------\n        dict[str, Any]\n            A dictionary of the keyword arguments that were not used for\n            adding features.\n        \"\"\"\n        resolution = kwargs.pop(\"resolution\", self.resolution)\n        feature_registry = self._get_feature_registry(resolution)\n\n        # If natural_earth is True, enable a standard set of features\n        if kwargs.pop(\"natural_earth\", False):\n            for feature in [\"ocean\", \"land\", \"lakes\", \"rivers\"]:\n                kwargs.setdefault(feature, True)\n\n        # Main feature-drawing loop\n        for key, feature_spec in feature_registry.items():\n            if key in kwargs:\n                style_arg = kwargs.pop(key)\n                self._draw_single_feature(style_arg, feature_spec)\n\n        return kwargs\n\n    def _draw_gridlines(self, style: bool | dict[str, Any]) -&gt; None:\n        \"\"\"Draw gridlines on the map.\n\n        Parameters\n        ----------\n        style : bool or dict[str, Any]\n            The style for the gridlines. If True, use defaults. If a dict,\n            use it as keyword arguments. If False, do nothing.\n        \"\"\"\n        if not style:\n            return\n\n        gridline_defaults = {\n            \"draw_labels\": True,\n            \"linestyle\": \"--\",\n            \"color\": \"gray\",\n        }\n        gridline_kwargs = self._get_style(style, gridline_defaults)\n        self.ax.gridlines(**gridline_kwargs)\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialPlot.__init__","title":"<code>__init__(*, projection=ccrs.PlateCarree(), fig=None, ax=None, figsize=None, subplot_kw=None, **kwargs)</code>","text":"<p>Initialize the spatial plot and draw map features.</p> <p>This constructor sets up the matplotlib Figure and cartopy GeoAxes, and provides a single interface to draw common map features like coastlines and states.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialPlot.__init__--parameters","title":"Parameters","text":"<p>projection : ccrs.Projection, optional     The cartopy projection for the map, by default ccrs.PlateCarree(). fig : plt.Figure | None, optional     An existing matplotlib Figure object. If None, a new one is     created, by default None. ax : plt.Axes | None, optional     An existing matplotlib Axes object. If None, a new one is created,     by default None. figsize : tuple[float, float] | None, optional      Width, height in inches. If not provided, the matplotlib default      will be used. subplot_kw : dict[str, Any] | None, optional     Keyword arguments passed to <code>fig.add_subplot</code>, by default None.     The 'projection' is added to these keywords automatically. **kwargs : Any     Keyword arguments for map features, passed to <code>add_features</code>.     Common options include <code>coastlines</code>, <code>states</code>, <code>countries</code>,     <code>ocean</code>, <code>land</code>, <code>lakes</code>, <code>rivers</code>, <code>borders</code>, <code>gridlines</code>,     <code>extent</code>, and <code>resolution</code>.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialPlot.__init__--attributes","title":"Attributes","text":"<p>fig : plt.Figure     The matplotlib Figure object. ax : plt.Axes     The matplotlib Axes (or GeoAxes) object. resolution : str     The default resolution for cartopy features.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def __init__(\n    self,\n    *,\n    projection: ccrs.Projection = ccrs.PlateCarree(),\n    fig: matplotlib.figure.Figure | None = None,\n    ax: matplotlib.axes.Axes | None = None,\n    figsize: tuple[float, float] | None = None,\n    subplot_kw: dict[str, Any] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize the spatial plot and draw map features.\n\n    This constructor sets up the matplotlib Figure and cartopy GeoAxes,\n    and provides a single interface to draw common map features like\n    coastlines and states.\n\n    Parameters\n    ----------\n    projection : ccrs.Projection, optional\n        The cartopy projection for the map, by default ccrs.PlateCarree().\n    fig : plt.Figure | None, optional\n        An existing matplotlib Figure object. If None, a new one is\n        created, by default None.\n    ax : plt.Axes | None, optional\n        An existing matplotlib Axes object. If None, a new one is created,\n        by default None.\n    figsize : tuple[float, float] | None, optional\n         Width, height in inches. If not provided, the matplotlib default\n         will be used.\n    subplot_kw : dict[str, Any] | None, optional\n        Keyword arguments passed to `fig.add_subplot`, by default None.\n        The 'projection' is added to these keywords automatically.\n    **kwargs : Any\n        Keyword arguments for map features, passed to `add_features`.\n        Common options include `coastlines`, `states`, `countries`,\n        `ocean`, `land`, `lakes`, `rivers`, `borders`, `gridlines`,\n        `extent`, and `resolution`.\n\n    Attributes\n    ----------\n    fig : plt.Figure\n        The matplotlib Figure object.\n    ax : plt.Axes\n        The matplotlib Axes (or GeoAxes) object.\n    resolution : str\n        The default resolution for cartopy features.\n    \"\"\"\n    # Ensure 'projection' is correctly passed to subplot creation.\n    current_subplot_kw = subplot_kw.copy() if subplot_kw else {}\n    current_subplot_kw[\"projection\"] = projection\n\n    self.resolution = kwargs.pop(\"resolution\", \"50m\")\n    style = kwargs.pop(\"style\", \"wiley\")\n\n    # Ensure coastlines are enabled by default if not specified.\n    if \"coastlines\" not in kwargs:\n        kwargs[\"coastlines\"] = True\n\n    # Initialize the base plot, which creates the figure and axes.\n    super().__init__(\n        fig=fig, ax=ax, figsize=figsize, style=style, subplot_kw=current_subplot_kw\n    )\n\n    # If BasePlot didn't create an axes (e.g. because fig was provided),\n    # create one now.\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1, **current_subplot_kw)\n\n    # If BasePlot didn't create an axes (e.g. because fig was provided),\n    # create one now.\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1, **current_subplot_kw)\n\n    # Add features from kwargs\n    self.add_features(**kwargs)\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialPlot.add_features","title":"<code>add_features(**kwargs)</code>","text":"<p>Add and style cartopy features on the map axes.</p> <p>This method provides a flexible, data-driven interface to add common map features. Features can be enabled with a boolean flag (e.g., <code>coastlines=True</code>) or styled with a dictionary of keyword arguments (e.g., <code>states=dict(linewidth=2, edgecolor='red')</code>).</p> <p>The <code>extent</code> keyword is also supported to set the map boundaries.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialPlot.add_features--parameters","title":"Parameters","text":"<p>**kwargs : Any     Keyword arguments controlling the features to add and their     styles. Common options include <code>coastlines</code>, <code>states</code>,     <code>countries</code>, <code>ocean</code>, <code>land</code>, <code>lakes</code>, <code>rivers</code>, <code>borders</code>,     and <code>gridlines</code>.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialPlot.add_features--returns","title":"Returns","text":"<p>dict[str, Any]     A dictionary of the keyword arguments that were not used for     adding features. This can be useful for passing remaining     arguments to other functions.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def add_features(self, **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Add and style cartopy features on the map axes.\n\n    This method provides a flexible, data-driven interface to add common\n    map features. Features can be enabled with a boolean flag (e.g.,\n    `coastlines=True`) or styled with a dictionary of keyword arguments\n    (e.g., `states=dict(linewidth=2, edgecolor='red')`).\n\n    The `extent` keyword is also supported to set the map boundaries.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Keyword arguments controlling the features to add and their\n        styles. Common options include `coastlines`, `states`,\n        `countries`, `ocean`, `land`, `lakes`, `rivers`, `borders`,\n        and `gridlines`.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary of the keyword arguments that were not used for\n        adding features. This can be useful for passing remaining\n        arguments to other functions.\n    \"\"\"\n    # Note: The order of these calls is important.\n    # Extent must be set before gridlines are drawn to ensure labels\n    # are placed correctly.\n    if \"extent\" in kwargs:\n        extent = kwargs.pop(\"extent\")\n        self._set_extent(extent)\n\n    if \"gridlines\" in kwargs:\n        gridline_style = kwargs.pop(\"gridlines\")\n        self._draw_gridlines(gridline_style)\n\n    # The rest of the kwargs are assumed to be for vector features.\n    remaining_kwargs = self._draw_features(**kwargs)\n\n    return remaining_kwargs\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack","title":"<code>SpatialTrack</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Plot a trajectory from an xarray.DataArray on a map.</p> <p>This class provides an xarray-native interface for visualizing paths, such as flight trajectories or pollutant tracks, where a variable (e.g., altitude, concentration) is plotted along the path.</p> <p>It inherits from :class:<code>SpatialPlot</code> to provide the underlying map canvas.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack--attributes","title":"Attributes","text":"<p>data : xr.DataArray     The trajectory data being plotted. lon_coord : str     The name of the longitude coordinate in the DataArray. lat_coord : str     The name of the latitude coordinate in the DataArray.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>class SpatialTrack(SpatialPlot):\n    \"\"\"Plot a trajectory from an xarray.DataArray on a map.\n\n    This class provides an xarray-native interface for visualizing paths,\n    such as flight trajectories or pollutant tracks, where a variable\n    (e.g., altitude, concentration) is plotted along the path.\n\n    It inherits from :class:`SpatialPlot` to provide the underlying map canvas.\n\n    Attributes\n    ----------\n    data : xr.DataArray\n        The trajectory data being plotted.\n    lon_coord : str\n        The name of the longitude coordinate in the DataArray.\n    lat_coord : str\n        The name of the latitude coordinate in the DataArray.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: xr.DataArray,\n        *,\n        lon_coord: str = \"lon\",\n        lat_coord: str = \"lat\",\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize the SpatialTrack plot.\n\n        This constructor validates the input data and sets up the map canvas\n        by initializing the parent `SpatialPlot` and adding map features.\n\n        Parameters\n        ----------\n        data : xr.DataArray\n            The input trajectory data. Must be an xarray DataArray with\n            coordinates for longitude and latitude.\n        lon_coord : str, optional\n            Name of the longitude coordinate in the DataArray, by default 'lon'.\n        lat_coord : str, optional\n            Name of the latitude coordinate in the DataArray, by default 'lat'.\n        **kwargs : Any\n            Keyword arguments passed to :class:`SpatialPlot`. These control\n            the map projection, figure size, and cartopy features. For example:\n            `projection=ccrs.LambertConformal()`, `figsize=(10, 8)`,\n            `states=True`, `extent=[-125, -70, 25, 50]`.\n        \"\"\"\n        if not isinstance(data, xr.DataArray):\n            raise TypeError(\"Input 'data' must be an xarray.DataArray.\")\n        if lon_coord not in data.coords:\n            raise ValueError(\n                f\"Longitude coordinate '{lon_coord}' not found in DataArray.\"\n            )\n        if lat_coord not in data.coords:\n            raise ValueError(\n                f\"Latitude coordinate '{lat_coord}' not found in DataArray.\"\n            )\n\n        # Initialize the parent SpatialPlot, which creates the map canvas\n        # and draws features from the keyword arguments.\n        super().__init__(**kwargs)\n\n        # Set data and update history for provenance\n        self.data = data\n        self.lon_coord = lon_coord\n        self.lat_coord = lat_coord\n        history = self.data.attrs.get(\"history\", \"\")\n        self.data.attrs[\"history\"] = f\"Plotted with monet-plots.SpatialTrack; {history}\"\n\n    def plot(self, **kwargs: Any) -&gt; plt.Artist:\n        \"\"\"Plot the trajectory on the map.\n\n        The track is rendered as a scatter plot, where each point is colored\n        according to the `data` values.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Keyword arguments passed to `matplotlib.pyplot.scatter`.\n            Common options include `cmap`, `s` (size), and `alpha`.\n            A `transform` keyword (e.g., `transform=ccrs.PlateCarree()`)\n            is highly recommended for geospatial accuracy.\n            The `cmap` argument can be a string, a Colormap object, or a\n            (colormap, norm) tuple from the scaling tools in `colorbars.py`.\n            Map features (e.g., `coastlines=True`) can also be passed here.\n\n        Returns\n        -------\n        plt.Artist\n            The scatter plot artist created by `ax.scatter`.\n        \"\"\"\n        from ..plot_utils import get_plot_kwargs\n\n        # Automatically compute extent if not provided\n        if \"extent\" not in kwargs:\n            lon = self.data[self.lon_coord]\n            lat = self.data[self.lat_coord]\n            # Add a small buffer to the extent.\n            # Use dask.compute for efficient parallel calculation of min/max\n            # if the data is chunked.\n            import dask\n\n            lon_min, lon_max, lat_min, lat_max = dask.compute(\n                lon.min(), lon.max(), lat.min(), lat.max()\n            )\n            # Ensure they are scalar values (handles both numpy and dask returns)\n            lon_min, lon_max = float(lon_min), float(lon_max)\n            lat_min, lat_max = float(lat_min), float(lat_max)\n\n            lon_buf = (lon_max - lon_min) * 0.1 if lon_max &gt; lon_min else 1.0\n            lat_buf = (lat_max - lat_min) * 0.1 if lat_max &gt; lat_min else 1.0\n            kwargs[\"extent\"] = [\n                lon_min - lon_buf,\n                lon_max + lon_buf,\n                lat_min - lat_buf,\n                lat_max + lat_buf,\n            ]\n\n        # Add features and get remaining kwargs for scatter\n        scatter_kwargs = self.add_features(**kwargs)\n\n        scatter_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        # For coordinates and values, we pass the xarray objects directly.\n        # This allows Matplotlib to handle the conversion, maintaining\n        # compatibility with existing tests that check for lazy objects.\n        longitude = self.data[self.lon_coord]\n        latitude = self.data[self.lat_coord]\n\n        # Use get_plot_kwargs to handle (cmap, norm) tuples\n        final_kwargs = get_plot_kwargs(c=self.data, **scatter_kwargs)\n\n        sc = self.ax.scatter(longitude, latitude, **final_kwargs)\n        return sc\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.__init__","title":"<code>__init__(data, *, lon_coord='lon', lat_coord='lat', **kwargs)</code>","text":"<p>Initialize the SpatialTrack plot.</p> <p>This constructor validates the input data and sets up the map canvas by initializing the parent <code>SpatialPlot</code> and adding map features.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.__init__--parameters","title":"Parameters","text":"<p>data : xr.DataArray     The input trajectory data. Must be an xarray DataArray with     coordinates for longitude and latitude. lon_coord : str, optional     Name of the longitude coordinate in the DataArray, by default 'lon'. lat_coord : str, optional     Name of the latitude coordinate in the DataArray, by default 'lat'. **kwargs : Any     Keyword arguments passed to :class:<code>SpatialPlot</code>. These control     the map projection, figure size, and cartopy features. For example:     <code>projection=ccrs.LambertConformal()</code>, <code>figsize=(10, 8)</code>,     <code>states=True</code>, <code>extent=[-125, -70, 25, 50]</code>.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def __init__(\n    self,\n    data: xr.DataArray,\n    *,\n    lon_coord: str = \"lon\",\n    lat_coord: str = \"lat\",\n    **kwargs: Any,\n):\n    \"\"\"Initialize the SpatialTrack plot.\n\n    This constructor validates the input data and sets up the map canvas\n    by initializing the parent `SpatialPlot` and adding map features.\n\n    Parameters\n    ----------\n    data : xr.DataArray\n        The input trajectory data. Must be an xarray DataArray with\n        coordinates for longitude and latitude.\n    lon_coord : str, optional\n        Name of the longitude coordinate in the DataArray, by default 'lon'.\n    lat_coord : str, optional\n        Name of the latitude coordinate in the DataArray, by default 'lat'.\n    **kwargs : Any\n        Keyword arguments passed to :class:`SpatialPlot`. These control\n        the map projection, figure size, and cartopy features. For example:\n        `projection=ccrs.LambertConformal()`, `figsize=(10, 8)`,\n        `states=True`, `extent=[-125, -70, 25, 50]`.\n    \"\"\"\n    if not isinstance(data, xr.DataArray):\n        raise TypeError(\"Input 'data' must be an xarray.DataArray.\")\n    if lon_coord not in data.coords:\n        raise ValueError(\n            f\"Longitude coordinate '{lon_coord}' not found in DataArray.\"\n        )\n    if lat_coord not in data.coords:\n        raise ValueError(\n            f\"Latitude coordinate '{lat_coord}' not found in DataArray.\"\n        )\n\n    # Initialize the parent SpatialPlot, which creates the map canvas\n    # and draws features from the keyword arguments.\n    super().__init__(**kwargs)\n\n    # Set data and update history for provenance\n    self.data = data\n    self.lon_coord = lon_coord\n    self.lat_coord = lat_coord\n    history = self.data.attrs.get(\"history\", \"\")\n    self.data.attrs[\"history\"] = f\"Plotted with monet-plots.SpatialTrack; {history}\"\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Plot the trajectory on the map.</p> <p>The track is rendered as a scatter plot, where each point is colored according to the <code>data</code> values.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.plot--parameters","title":"Parameters","text":"<p>**kwargs : Any     Keyword arguments passed to <code>matplotlib.pyplot.scatter</code>.     Common options include <code>cmap</code>, <code>s</code> (size), and <code>alpha</code>.     A <code>transform</code> keyword (e.g., <code>transform=ccrs.PlateCarree()</code>)     is highly recommended for geospatial accuracy.     The <code>cmap</code> argument can be a string, a Colormap object, or a     (colormap, norm) tuple from the scaling tools in <code>colorbars.py</code>.     Map features (e.g., <code>coastlines=True</code>) can also be passed here.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.plot--returns","title":"Returns","text":"<p>plt.Artist     The scatter plot artist created by <code>ax.scatter</code>.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; plt.Artist:\n    \"\"\"Plot the trajectory on the map.\n\n    The track is rendered as a scatter plot, where each point is colored\n    according to the `data` values.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Keyword arguments passed to `matplotlib.pyplot.scatter`.\n        Common options include `cmap`, `s` (size), and `alpha`.\n        A `transform` keyword (e.g., `transform=ccrs.PlateCarree()`)\n        is highly recommended for geospatial accuracy.\n        The `cmap` argument can be a string, a Colormap object, or a\n        (colormap, norm) tuple from the scaling tools in `colorbars.py`.\n        Map features (e.g., `coastlines=True`) can also be passed here.\n\n    Returns\n    -------\n    plt.Artist\n        The scatter plot artist created by `ax.scatter`.\n    \"\"\"\n    from ..plot_utils import get_plot_kwargs\n\n    # Automatically compute extent if not provided\n    if \"extent\" not in kwargs:\n        lon = self.data[self.lon_coord]\n        lat = self.data[self.lat_coord]\n        # Add a small buffer to the extent.\n        # Use dask.compute for efficient parallel calculation of min/max\n        # if the data is chunked.\n        import dask\n\n        lon_min, lon_max, lat_min, lat_max = dask.compute(\n            lon.min(), lon.max(), lat.min(), lat.max()\n        )\n        # Ensure they are scalar values (handles both numpy and dask returns)\n        lon_min, lon_max = float(lon_min), float(lon_max)\n        lat_min, lat_max = float(lat_min), float(lat_max)\n\n        lon_buf = (lon_max - lon_min) * 0.1 if lon_max &gt; lon_min else 1.0\n        lat_buf = (lat_max - lat_min) * 0.1 if lat_max &gt; lat_min else 1.0\n        kwargs[\"extent\"] = [\n            lon_min - lon_buf,\n            lon_max + lon_buf,\n            lat_min - lat_buf,\n            lat_max + lat_buf,\n        ]\n\n    # Add features and get remaining kwargs for scatter\n    scatter_kwargs = self.add_features(**kwargs)\n\n    scatter_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    # For coordinates and values, we pass the xarray objects directly.\n    # This allows Matplotlib to handle the conversion, maintaining\n    # compatibility with existing tests that check for lazy objects.\n    longitude = self.data[self.lon_coord]\n    latitude = self.data[self.lat_coord]\n\n    # Use get_plot_kwargs to handle (cmap, norm) tuples\n    final_kwargs = get_plot_kwargs(c=self.data, **scatter_kwargs)\n\n    sc = self.ax.scatter(longitude, latitude, **final_kwargs)\n    return sc\n</code></pre>"},{"location":"plots/spatial/#spatialtrack","title":"SpatialTrack","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Plot a trajectory from an xarray.DataArray on a map.</p> <p>This class provides an xarray-native interface for visualizing paths, such as flight trajectories or pollutant tracks, where a variable (e.g., altitude, concentration) is plotted along the path.</p> <p>It inherits from :class:<code>SpatialPlot</code> to provide the underlying map canvas.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack--attributes","title":"Attributes","text":"<p>data : xr.DataArray     The trajectory data being plotted. lon_coord : str     The name of the longitude coordinate in the DataArray. lat_coord : str     The name of the latitude coordinate in the DataArray.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>class SpatialTrack(SpatialPlot):\n    \"\"\"Plot a trajectory from an xarray.DataArray on a map.\n\n    This class provides an xarray-native interface for visualizing paths,\n    such as flight trajectories or pollutant tracks, where a variable\n    (e.g., altitude, concentration) is plotted along the path.\n\n    It inherits from :class:`SpatialPlot` to provide the underlying map canvas.\n\n    Attributes\n    ----------\n    data : xr.DataArray\n        The trajectory data being plotted.\n    lon_coord : str\n        The name of the longitude coordinate in the DataArray.\n    lat_coord : str\n        The name of the latitude coordinate in the DataArray.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: xr.DataArray,\n        *,\n        lon_coord: str = \"lon\",\n        lat_coord: str = \"lat\",\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize the SpatialTrack plot.\n\n        This constructor validates the input data and sets up the map canvas\n        by initializing the parent `SpatialPlot` and adding map features.\n\n        Parameters\n        ----------\n        data : xr.DataArray\n            The input trajectory data. Must be an xarray DataArray with\n            coordinates for longitude and latitude.\n        lon_coord : str, optional\n            Name of the longitude coordinate in the DataArray, by default 'lon'.\n        lat_coord : str, optional\n            Name of the latitude coordinate in the DataArray, by default 'lat'.\n        **kwargs : Any\n            Keyword arguments passed to :class:`SpatialPlot`. These control\n            the map projection, figure size, and cartopy features. For example:\n            `projection=ccrs.LambertConformal()`, `figsize=(10, 8)`,\n            `states=True`, `extent=[-125, -70, 25, 50]`.\n        \"\"\"\n        if not isinstance(data, xr.DataArray):\n            raise TypeError(\"Input 'data' must be an xarray.DataArray.\")\n        if lon_coord not in data.coords:\n            raise ValueError(\n                f\"Longitude coordinate '{lon_coord}' not found in DataArray.\"\n            )\n        if lat_coord not in data.coords:\n            raise ValueError(\n                f\"Latitude coordinate '{lat_coord}' not found in DataArray.\"\n            )\n\n        # Initialize the parent SpatialPlot, which creates the map canvas\n        # and draws features from the keyword arguments.\n        super().__init__(**kwargs)\n\n        # Set data and update history for provenance\n        self.data = data\n        self.lon_coord = lon_coord\n        self.lat_coord = lat_coord\n        history = self.data.attrs.get(\"history\", \"\")\n        self.data.attrs[\"history\"] = f\"Plotted with monet-plots.SpatialTrack; {history}\"\n\n    def plot(self, **kwargs: Any) -&gt; plt.Artist:\n        \"\"\"Plot the trajectory on the map.\n\n        The track is rendered as a scatter plot, where each point is colored\n        according to the `data` values.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Keyword arguments passed to `matplotlib.pyplot.scatter`.\n            Common options include `cmap`, `s` (size), and `alpha`.\n            A `transform` keyword (e.g., `transform=ccrs.PlateCarree()`)\n            is highly recommended for geospatial accuracy.\n            The `cmap` argument can be a string, a Colormap object, or a\n            (colormap, norm) tuple from the scaling tools in `colorbars.py`.\n            Map features (e.g., `coastlines=True`) can also be passed here.\n\n        Returns\n        -------\n        plt.Artist\n            The scatter plot artist created by `ax.scatter`.\n        \"\"\"\n        from ..plot_utils import get_plot_kwargs\n\n        # Automatically compute extent if not provided\n        if \"extent\" not in kwargs:\n            lon = self.data[self.lon_coord]\n            lat = self.data[self.lat_coord]\n            # Add a small buffer to the extent.\n            # Use dask.compute for efficient parallel calculation of min/max\n            # if the data is chunked.\n            import dask\n\n            lon_min, lon_max, lat_min, lat_max = dask.compute(\n                lon.min(), lon.max(), lat.min(), lat.max()\n            )\n            # Ensure they are scalar values (handles both numpy and dask returns)\n            lon_min, lon_max = float(lon_min), float(lon_max)\n            lat_min, lat_max = float(lat_min), float(lat_max)\n\n            lon_buf = (lon_max - lon_min) * 0.1 if lon_max &gt; lon_min else 1.0\n            lat_buf = (lat_max - lat_min) * 0.1 if lat_max &gt; lat_min else 1.0\n            kwargs[\"extent\"] = [\n                lon_min - lon_buf,\n                lon_max + lon_buf,\n                lat_min - lat_buf,\n                lat_max + lat_buf,\n            ]\n\n        # Add features and get remaining kwargs for scatter\n        scatter_kwargs = self.add_features(**kwargs)\n\n        scatter_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        # For coordinates and values, we pass the xarray objects directly.\n        # This allows Matplotlib to handle the conversion, maintaining\n        # compatibility with existing tests that check for lazy objects.\n        longitude = self.data[self.lon_coord]\n        latitude = self.data[self.lat_coord]\n\n        # Use get_plot_kwargs to handle (cmap, norm) tuples\n        final_kwargs = get_plot_kwargs(c=self.data, **scatter_kwargs)\n\n        sc = self.ax.scatter(longitude, latitude, **final_kwargs)\n        return sc\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.__init__","title":"<code>__init__(data, *, lon_coord='lon', lat_coord='lat', **kwargs)</code>","text":"<p>Initialize the SpatialTrack plot.</p> <p>This constructor validates the input data and sets up the map canvas by initializing the parent <code>SpatialPlot</code> and adding map features.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.__init__--parameters","title":"Parameters","text":"<p>data : xr.DataArray     The input trajectory data. Must be an xarray DataArray with     coordinates for longitude and latitude. lon_coord : str, optional     Name of the longitude coordinate in the DataArray, by default 'lon'. lat_coord : str, optional     Name of the latitude coordinate in the DataArray, by default 'lat'. **kwargs : Any     Keyword arguments passed to :class:<code>SpatialPlot</code>. These control     the map projection, figure size, and cartopy features. For example:     <code>projection=ccrs.LambertConformal()</code>, <code>figsize=(10, 8)</code>,     <code>states=True</code>, <code>extent=[-125, -70, 25, 50]</code>.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def __init__(\n    self,\n    data: xr.DataArray,\n    *,\n    lon_coord: str = \"lon\",\n    lat_coord: str = \"lat\",\n    **kwargs: Any,\n):\n    \"\"\"Initialize the SpatialTrack plot.\n\n    This constructor validates the input data and sets up the map canvas\n    by initializing the parent `SpatialPlot` and adding map features.\n\n    Parameters\n    ----------\n    data : xr.DataArray\n        The input trajectory data. Must be an xarray DataArray with\n        coordinates for longitude and latitude.\n    lon_coord : str, optional\n        Name of the longitude coordinate in the DataArray, by default 'lon'.\n    lat_coord : str, optional\n        Name of the latitude coordinate in the DataArray, by default 'lat'.\n    **kwargs : Any\n        Keyword arguments passed to :class:`SpatialPlot`. These control\n        the map projection, figure size, and cartopy features. For example:\n        `projection=ccrs.LambertConformal()`, `figsize=(10, 8)`,\n        `states=True`, `extent=[-125, -70, 25, 50]`.\n    \"\"\"\n    if not isinstance(data, xr.DataArray):\n        raise TypeError(\"Input 'data' must be an xarray.DataArray.\")\n    if lon_coord not in data.coords:\n        raise ValueError(\n            f\"Longitude coordinate '{lon_coord}' not found in DataArray.\"\n        )\n    if lat_coord not in data.coords:\n        raise ValueError(\n            f\"Latitude coordinate '{lat_coord}' not found in DataArray.\"\n        )\n\n    # Initialize the parent SpatialPlot, which creates the map canvas\n    # and draws features from the keyword arguments.\n    super().__init__(**kwargs)\n\n    # Set data and update history for provenance\n    self.data = data\n    self.lon_coord = lon_coord\n    self.lat_coord = lat_coord\n    history = self.data.attrs.get(\"history\", \"\")\n    self.data.attrs[\"history\"] = f\"Plotted with monet-plots.SpatialTrack; {history}\"\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Plot the trajectory on the map.</p> <p>The track is rendered as a scatter plot, where each point is colored according to the <code>data</code> values.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.plot--parameters","title":"Parameters","text":"<p>**kwargs : Any     Keyword arguments passed to <code>matplotlib.pyplot.scatter</code>.     Common options include <code>cmap</code>, <code>s</code> (size), and <code>alpha</code>.     A <code>transform</code> keyword (e.g., <code>transform=ccrs.PlateCarree()</code>)     is highly recommended for geospatial accuracy.     The <code>cmap</code> argument can be a string, a Colormap object, or a     (colormap, norm) tuple from the scaling tools in <code>colorbars.py</code>.     Map features (e.g., <code>coastlines=True</code>) can also be passed here.</p>"},{"location":"plots/spatial/#monet_plots.plots.spatial.SpatialTrack.plot--returns","title":"Returns","text":"<p>plt.Artist     The scatter plot artist created by <code>ax.scatter</code>.</p> Source code in <code>src/monet_plots/plots/spatial.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; plt.Artist:\n    \"\"\"Plot the trajectory on the map.\n\n    The track is rendered as a scatter plot, where each point is colored\n    according to the `data` values.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Keyword arguments passed to `matplotlib.pyplot.scatter`.\n        Common options include `cmap`, `s` (size), and `alpha`.\n        A `transform` keyword (e.g., `transform=ccrs.PlateCarree()`)\n        is highly recommended for geospatial accuracy.\n        The `cmap` argument can be a string, a Colormap object, or a\n        (colormap, norm) tuple from the scaling tools in `colorbars.py`.\n        Map features (e.g., `coastlines=True`) can also be passed here.\n\n    Returns\n    -------\n    plt.Artist\n        The scatter plot artist created by `ax.scatter`.\n    \"\"\"\n    from ..plot_utils import get_plot_kwargs\n\n    # Automatically compute extent if not provided\n    if \"extent\" not in kwargs:\n        lon = self.data[self.lon_coord]\n        lat = self.data[self.lat_coord]\n        # Add a small buffer to the extent.\n        # Use dask.compute for efficient parallel calculation of min/max\n        # if the data is chunked.\n        import dask\n\n        lon_min, lon_max, lat_min, lat_max = dask.compute(\n            lon.min(), lon.max(), lat.min(), lat.max()\n        )\n        # Ensure they are scalar values (handles both numpy and dask returns)\n        lon_min, lon_max = float(lon_min), float(lon_max)\n        lat_min, lat_max = float(lat_min), float(lat_max)\n\n        lon_buf = (lon_max - lon_min) * 0.1 if lon_max &gt; lon_min else 1.0\n        lat_buf = (lat_max - lat_min) * 0.1 if lat_max &gt; lat_min else 1.0\n        kwargs[\"extent\"] = [\n            lon_min - lon_buf,\n            lon_max + lon_buf,\n            lat_min - lat_buf,\n            lat_max + lat_buf,\n        ]\n\n    # Add features and get remaining kwargs for scatter\n    scatter_kwargs = self.add_features(**kwargs)\n\n    scatter_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    # For coordinates and values, we pass the xarray objects directly.\n    # This allows Matplotlib to handle the conversion, maintaining\n    # compatibility with existing tests that check for lazy objects.\n    longitude = self.data[self.lon_coord]\n    latitude = self.data[self.lat_coord]\n\n    # Use get_plot_kwargs to handle (cmap, norm) tuples\n    final_kwargs = get_plot_kwargs(c=self.data, **scatter_kwargs)\n\n    sc = self.ax.scatter(longitude, latitude, **final_kwargs)\n    return sc\n</code></pre>"},{"location":"plots/spatial/#example","title":"Example","text":"<pre><code>import numpy as np\nfrom monet_plots.plots import SpatialTrack\n\n# Create sample data\nlon = np.linspace(-120, -80, 100)\nlat = np.linspace(30, 40, 100)\ndata = np.random.rand(100)\n\n# Create the plot\nplot = SpatialTrack(lon, lat, data)\nplot.plot()\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial_contour.SpatialContourPlot","title":"<code>SpatialContourPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a contour plot on a map with an optional discrete colorbar.</p> <p>This plot is useful for visualizing spatial data with continuous values.</p> Source code in <code>src/monet_plots/plots/spatial_contour.py</code> <pre><code>class SpatialContourPlot(SpatialPlot):\n    \"\"\"Create a contour plot on a map with an optional discrete colorbar.\n\n    This plot is useful for visualizing spatial data with continuous values.\n    \"\"\"\n\n    def __init__(\n        self,\n        modelvar: Any,\n        gridobj,\n        date=None,\n        discrete: bool = True,\n        ncolors: int = None,\n        dtype: str = \"int\",\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n                2D model variable array to contour.\n            modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n                2D model variable array to contour.\n            gridobj (object): Object with LAT and LON variables.\n            date (datetime.datetime): Date/time for the plot title.\n            discrete (bool): If True, use a discrete colorbar.\n            ncolors (int, optional): Number of discrete colors.\n            dtype (str): Data type for colorbar tick labels.\n            **kwargs: Keyword arguments passed to SpatialPlot for\n                projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.modelvar = np.asarray(modelvar)\n        self.gridobj = gridobj\n        self.date = date\n        self.discrete = discrete\n        self.ncolors = ncolors\n        self.dtype = dtype\n\n    def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the spatial contour plot.\"\"\"\n        # Draw map features and get remaining kwargs for contourf\n        plot_kwargs = self.add_features(**kwargs)\n\n        # Try to handle different gridobj structures\n        if hasattr(self.gridobj, \"variables\"):\n            lat_var = self.gridobj.variables[\"LAT\"]\n            lon_var = self.gridobj.variables[\"LON\"]\n\n            # Flexible indexing based on dimension count\n            if lat_var.ndim == 4:\n                lat = lat_var[0, 0, :, :].squeeze()\n                lon = lon_var[0, 0, :, :].squeeze()\n            elif lat_var.ndim == 3:\n                lat = lat_var[0, :, :].squeeze()\n                lon = lon_var[0, :, :].squeeze()\n            else:\n                lat = lat_var.squeeze()\n                lon = lon_var.squeeze()\n        else:\n            # Assume it's already an array or similar\n            lat = self.gridobj.LAT\n            lon = self.gridobj.LON\n\n        # Data is in lat/lon, so specify transform\n        plot_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        mesh = self.ax.contourf(lon, lat, self.modelvar, **plot_kwargs)\n\n        cmap = plot_kwargs.get(\"cmap\")\n        levels = plot_kwargs.get(\"levels\")\n\n        if self.discrete:\n            ncolors = self.ncolors\n            if ncolors is None and levels is not None:\n                # If levels is an int, convert to a sequence for len()\n                if isinstance(levels, int):\n                    ncolors = levels - 1\n                    levels_seq = np.linspace(\n                        np.nanmin(self.modelvar), np.nanmax(self.modelvar), levels\n                    )\n                else:\n                    ncolors = len(levels) - 1\n                    levels_seq = levels\n            else:\n                levels_seq = levels\n            c, _ = colorbar_index(\n                ncolors,\n                cmap,\n                minval=levels_seq[0],\n                maxval=levels_seq[-1],\n                dtype=self.dtype,\n                ax=self.ax,\n            )\n        else:\n            self.add_colorbar(mesh)\n\n        if self.date:\n            titstring = self.date.strftime(\"%B %d %Y %H\")\n            self.ax.set_title(titstring)\n        self.fig.tight_layout()\n        return self.ax\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial_contour.SpatialContourPlot.__init__","title":"<code>__init__(modelvar, gridobj, date=None, discrete=True, ncolors=None, dtype='int', *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>modelvar</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D model variable array to contour.</p> required <code>modelvar</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D model variable array to contour.</p> required <code>gridobj</code> <code>object</code> <p>Object with LAT and LON variables.</p> required <code>date</code> <code>datetime</code> <p>Date/time for the plot title.</p> <code>None</code> <code>discrete</code> <code>bool</code> <p>If True, use a discrete colorbar.</p> <code>True</code> <code>ncolors</code> <code>int</code> <p>Number of discrete colors.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>Data type for colorbar tick labels.</p> <code>'int'</code> <code>**kwargs</code> <p>Keyword arguments passed to SpatialPlot for projection and features.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/spatial_contour.py</code> <pre><code>def __init__(\n    self,\n    modelvar: Any,\n    gridobj,\n    date=None,\n    discrete: bool = True,\n    ncolors: int = None,\n    dtype: str = \"int\",\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n            2D model variable array to contour.\n        modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n            2D model variable array to contour.\n        gridobj (object): Object with LAT and LON variables.\n        date (datetime.datetime): Date/time for the plot title.\n        discrete (bool): If True, use a discrete colorbar.\n        ncolors (int, optional): Number of discrete colors.\n        dtype (str): Data type for colorbar tick labels.\n        **kwargs: Keyword arguments passed to SpatialPlot for\n            projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.modelvar = np.asarray(modelvar)\n    self.gridobj = gridobj\n    self.date = date\n    self.discrete = discrete\n    self.ncolors = ncolors\n    self.dtype = dtype\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial_contour.SpatialContourPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spatial contour plot.</p> Source code in <code>src/monet_plots/plots/spatial_contour.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the spatial contour plot.\"\"\"\n    # Draw map features and get remaining kwargs for contourf\n    plot_kwargs = self.add_features(**kwargs)\n\n    # Try to handle different gridobj structures\n    if hasattr(self.gridobj, \"variables\"):\n        lat_var = self.gridobj.variables[\"LAT\"]\n        lon_var = self.gridobj.variables[\"LON\"]\n\n        # Flexible indexing based on dimension count\n        if lat_var.ndim == 4:\n            lat = lat_var[0, 0, :, :].squeeze()\n            lon = lon_var[0, 0, :, :].squeeze()\n        elif lat_var.ndim == 3:\n            lat = lat_var[0, :, :].squeeze()\n            lon = lon_var[0, :, :].squeeze()\n        else:\n            lat = lat_var.squeeze()\n            lon = lon_var.squeeze()\n    else:\n        # Assume it's already an array or similar\n        lat = self.gridobj.LAT\n        lon = self.gridobj.LON\n\n    # Data is in lat/lon, so specify transform\n    plot_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    mesh = self.ax.contourf(lon, lat, self.modelvar, **plot_kwargs)\n\n    cmap = plot_kwargs.get(\"cmap\")\n    levels = plot_kwargs.get(\"levels\")\n\n    if self.discrete:\n        ncolors = self.ncolors\n        if ncolors is None and levels is not None:\n            # If levels is an int, convert to a sequence for len()\n            if isinstance(levels, int):\n                ncolors = levels - 1\n                levels_seq = np.linspace(\n                    np.nanmin(self.modelvar), np.nanmax(self.modelvar), levels\n                )\n            else:\n                ncolors = len(levels) - 1\n                levels_seq = levels\n        else:\n            levels_seq = levels\n        c, _ = colorbar_index(\n            ncolors,\n            cmap,\n            minval=levels_seq[0],\n            maxval=levels_seq[-1],\n            dtype=self.dtype,\n            ax=self.ax,\n        )\n    else:\n        self.add_colorbar(mesh)\n\n    if self.date:\n        titstring = self.date.strftime(\"%B %d %Y %H\")\n        self.ax.set_title(titstring)\n    self.fig.tight_layout()\n    return self.ax\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial_bias_scatter.SpatialBiasScatterPlot","title":"<code>SpatialBiasScatterPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a spatial scatter plot showing bias between model and observations.</p> <p>The scatter points are colored by the difference (CMAQ - Obs) and sized by the absolute magnitude of this difference, making larger biases more visible.</p> Source code in <code>src/monet_plots/plots/spatial_bias_scatter.py</code> <pre><code>class SpatialBiasScatterPlot(SpatialPlot):\n    \"\"\"Create a spatial scatter plot showing bias between model and observations.\n\n    The scatter points are colored by the difference (CMAQ - Obs) and sized\n    by the absolute magnitude of this difference, making larger biases more visible.\n    \"\"\"\n\n    def __init__(\n        self,\n        df: Any,\n        col1: str,\n        col2: str,\n        vmin: float = None,\n        vmax: float = None,\n        ncolors: int = 15,\n        fact: float = 1.5,\n        cmap: str = \"RdBu_r\",\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with 'latitude', 'longitude', and data columns.\n            col1 (str): Name of the first column (e.g., observations).\n            col2 (str): Name of the second column (e.g., model). Bias is calculated as col2 - col1.\n            vmin (float, optional): Minimum for colorscale.\n            vmax (float, optional): Maximum for colorscale.\n            ncolors (int): Number of discrete colors.\n            fact (float): Scaling factor for point sizes.\n            cmap (str or Colormap): Colormap for bias values.\n            **kwargs: Additional keyword arguments for map creation, passed to\n                      :class:`monet_plots.plots.spatial.SpatialPlot`. These\n                      include `projection`, `figsize`, `ax`, and cartopy\n                      features like `states`, `coastlines`, etc.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.df = to_dataframe(df)\n        self.col1 = col1\n        self.col2 = col2\n        self.vmin = vmin\n        self.vmax = vmax\n        self.ncolors = ncolors\n        self.fact = fact\n        self.cmap = cmap\n\n    def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the spatial bias scatter plot.\"\"\"\n        from numpy import around\n\n        # Separate feature kwargs from scatter kwargs\n        scatter_kwargs = self.add_features(**kwargs)\n\n        # Ensure we are working with a clean copy with no NaNs in relevant columns\n        new = (\n            self.df[[\"latitude\", \"longitude\", self.col1, self.col2]]\n            .dropna()\n            .copy(deep=True)\n        )\n\n        diff = new[self.col2] - new[self.col1]\n        top = around(score(diff.abs(), per=95))\n\n        # Use new scaling tools\n        cmap, norm = get_discrete_scale(\n            diff, cmap=self.cmap, n_levels=self.ncolors, vmin=-top, vmax=top\n        )\n\n        # Create colorbar\n        mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n        cbar = self.add_colorbar(mappable, format=\"%1.2g\")\n        cbar.ax.tick_params(labelsize=10)\n\n        colors = diff\n        ss = diff.abs() / top * 100.0\n        ss[ss &gt; 300] = 300.0\n\n        # Prepare scatter kwargs\n        final_scatter_kwargs = get_plot_kwargs(\n            cmap=cmap,\n            norm=norm,\n            s=ss,\n            c=colors,\n            transform=ccrs.PlateCarree(),\n            edgecolors=\"k\",\n            linewidths=0.25,\n            alpha=0.7,\n            **scatter_kwargs,\n        )\n\n        self.ax.scatter(\n            new.longitude.values,\n            new.latitude.values,\n            **final_scatter_kwargs,\n        )\n        return self.ax\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial_bias_scatter.SpatialBiasScatterPlot.__init__","title":"<code>__init__(df, col1, col2, vmin=None, vmax=None, ncolors=15, fact=1.5, cmap='RdBu_r', **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>DataFrame with 'latitude', 'longitude', and data columns.</p> required <code>col1</code> <code>str</code> <p>Name of the first column (e.g., observations).</p> required <code>col2</code> <code>str</code> <p>Name of the second column (e.g., model). Bias is calculated as col2 - col1.</p> required <code>vmin</code> <code>float</code> <p>Minimum for colorscale.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum for colorscale.</p> <code>None</code> <code>ncolors</code> <code>int</code> <p>Number of discrete colors.</p> <code>15</code> <code>fact</code> <code>float</code> <p>Scaling factor for point sizes.</p> <code>1.5</code> <code>cmap</code> <code>str or Colormap</code> <p>Colormap for bias values.</p> <code>'RdBu_r'</code> <code>**kwargs</code> <p>Additional keyword arguments for map creation, passed to       :class:<code>monet_plots.plots.spatial.SpatialPlot</code>. These       include <code>projection</code>, <code>figsize</code>, <code>ax</code>, and cartopy       features like <code>states</code>, <code>coastlines</code>, etc.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/spatial_bias_scatter.py</code> <pre><code>def __init__(\n    self,\n    df: Any,\n    col1: str,\n    col2: str,\n    vmin: float = None,\n    vmax: float = None,\n    ncolors: int = 15,\n    fact: float = 1.5,\n    cmap: str = \"RdBu_r\",\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with 'latitude', 'longitude', and data columns.\n        col1 (str): Name of the first column (e.g., observations).\n        col2 (str): Name of the second column (e.g., model). Bias is calculated as col2 - col1.\n        vmin (float, optional): Minimum for colorscale.\n        vmax (float, optional): Maximum for colorscale.\n        ncolors (int): Number of discrete colors.\n        fact (float): Scaling factor for point sizes.\n        cmap (str or Colormap): Colormap for bias values.\n        **kwargs: Additional keyword arguments for map creation, passed to\n                  :class:`monet_plots.plots.spatial.SpatialPlot`. These\n                  include `projection`, `figsize`, `ax`, and cartopy\n                  features like `states`, `coastlines`, etc.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.df = to_dataframe(df)\n    self.col1 = col1\n    self.col2 = col2\n    self.vmin = vmin\n    self.vmax = vmax\n    self.ncolors = ncolors\n    self.fact = fact\n    self.cmap = cmap\n</code></pre>"},{"location":"plots/spatial/#monet_plots.plots.spatial_bias_scatter.SpatialBiasScatterPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spatial bias scatter plot.</p> Source code in <code>src/monet_plots/plots/spatial_bias_scatter.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the spatial bias scatter plot.\"\"\"\n    from numpy import around\n\n    # Separate feature kwargs from scatter kwargs\n    scatter_kwargs = self.add_features(**kwargs)\n\n    # Ensure we are working with a clean copy with no NaNs in relevant columns\n    new = (\n        self.df[[\"latitude\", \"longitude\", self.col1, self.col2]]\n        .dropna()\n        .copy(deep=True)\n    )\n\n    diff = new[self.col2] - new[self.col1]\n    top = around(score(diff.abs(), per=95))\n\n    # Use new scaling tools\n    cmap, norm = get_discrete_scale(\n        diff, cmap=self.cmap, n_levels=self.ncolors, vmin=-top, vmax=top\n    )\n\n    # Create colorbar\n    mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n    cbar = self.add_colorbar(mappable, format=\"%1.2g\")\n    cbar.ax.tick_params(labelsize=10)\n\n    colors = diff\n    ss = diff.abs() / top * 100.0\n    ss[ss &gt; 300] = 300.0\n\n    # Prepare scatter kwargs\n    final_scatter_kwargs = get_plot_kwargs(\n        cmap=cmap,\n        norm=norm,\n        s=ss,\n        c=colors,\n        transform=ccrs.PlateCarree(),\n        edgecolors=\"k\",\n        linewidths=0.25,\n        alpha=0.7,\n        **scatter_kwargs,\n    )\n\n    self.ax.scatter(\n        new.longitude.values,\n        new.latitude.values,\n        **final_scatter_kwargs,\n    )\n    return self.ax\n</code></pre>"},{"location":"plots/spatial_bias_scatter/","title":"Spatial Bias Scatter","text":""},{"location":"plots/spatial_bias_scatter/#monet_plots.plots.spatial_bias_scatter.SpatialBiasScatterPlot","title":"<code>SpatialBiasScatterPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a spatial scatter plot showing bias between model and observations.</p> <p>The scatter points are colored by the difference (CMAQ - Obs) and sized by the absolute magnitude of this difference, making larger biases more visible.</p> Source code in <code>src/monet_plots/plots/spatial_bias_scatter.py</code> <pre><code>class SpatialBiasScatterPlot(SpatialPlot):\n    \"\"\"Create a spatial scatter plot showing bias between model and observations.\n\n    The scatter points are colored by the difference (CMAQ - Obs) and sized\n    by the absolute magnitude of this difference, making larger biases more visible.\n    \"\"\"\n\n    def __init__(\n        self,\n        df: Any,\n        col1: str,\n        col2: str,\n        vmin: float = None,\n        vmax: float = None,\n        ncolors: int = 15,\n        fact: float = 1.5,\n        cmap: str = \"RdBu_r\",\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with 'latitude', 'longitude', and data columns.\n            col1 (str): Name of the first column (e.g., observations).\n            col2 (str): Name of the second column (e.g., model). Bias is calculated as col2 - col1.\n            vmin (float, optional): Minimum for colorscale.\n            vmax (float, optional): Maximum for colorscale.\n            ncolors (int): Number of discrete colors.\n            fact (float): Scaling factor for point sizes.\n            cmap (str or Colormap): Colormap for bias values.\n            **kwargs: Additional keyword arguments for map creation, passed to\n                      :class:`monet_plots.plots.spatial.SpatialPlot`. These\n                      include `projection`, `figsize`, `ax`, and cartopy\n                      features like `states`, `coastlines`, etc.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.df = to_dataframe(df)\n        self.col1 = col1\n        self.col2 = col2\n        self.vmin = vmin\n        self.vmax = vmax\n        self.ncolors = ncolors\n        self.fact = fact\n        self.cmap = cmap\n\n    def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the spatial bias scatter plot.\"\"\"\n        from numpy import around\n\n        # Separate feature kwargs from scatter kwargs\n        scatter_kwargs = self.add_features(**kwargs)\n\n        # Ensure we are working with a clean copy with no NaNs in relevant columns\n        new = (\n            self.df[[\"latitude\", \"longitude\", self.col1, self.col2]]\n            .dropna()\n            .copy(deep=True)\n        )\n\n        diff = new[self.col2] - new[self.col1]\n        top = around(score(diff.abs(), per=95))\n\n        # Use new scaling tools\n        cmap, norm = get_discrete_scale(\n            diff, cmap=self.cmap, n_levels=self.ncolors, vmin=-top, vmax=top\n        )\n\n        # Create colorbar\n        mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n        cbar = self.add_colorbar(mappable, format=\"%1.2g\")\n        cbar.ax.tick_params(labelsize=10)\n\n        colors = diff\n        ss = diff.abs() / top * 100.0\n        ss[ss &gt; 300] = 300.0\n\n        # Prepare scatter kwargs\n        final_scatter_kwargs = get_plot_kwargs(\n            cmap=cmap,\n            norm=norm,\n            s=ss,\n            c=colors,\n            transform=ccrs.PlateCarree(),\n            edgecolors=\"k\",\n            linewidths=0.25,\n            alpha=0.7,\n            **scatter_kwargs,\n        )\n\n        self.ax.scatter(\n            new.longitude.values,\n            new.latitude.values,\n            **final_scatter_kwargs,\n        )\n        return self.ax\n</code></pre>"},{"location":"plots/spatial_bias_scatter/#monet_plots.plots.spatial_bias_scatter.SpatialBiasScatterPlot.__init__","title":"<code>__init__(df, col1, col2, vmin=None, vmax=None, ncolors=15, fact=1.5, cmap='RdBu_r', **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>DataFrame with 'latitude', 'longitude', and data columns.</p> required <code>col1</code> <code>str</code> <p>Name of the first column (e.g., observations).</p> required <code>col2</code> <code>str</code> <p>Name of the second column (e.g., model). Bias is calculated as col2 - col1.</p> required <code>vmin</code> <code>float</code> <p>Minimum for colorscale.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum for colorscale.</p> <code>None</code> <code>ncolors</code> <code>int</code> <p>Number of discrete colors.</p> <code>15</code> <code>fact</code> <code>float</code> <p>Scaling factor for point sizes.</p> <code>1.5</code> <code>cmap</code> <code>str or Colormap</code> <p>Colormap for bias values.</p> <code>'RdBu_r'</code> <code>**kwargs</code> <p>Additional keyword arguments for map creation, passed to       :class:<code>monet_plots.plots.spatial.SpatialPlot</code>. These       include <code>projection</code>, <code>figsize</code>, <code>ax</code>, and cartopy       features like <code>states</code>, <code>coastlines</code>, etc.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/spatial_bias_scatter.py</code> <pre><code>def __init__(\n    self,\n    df: Any,\n    col1: str,\n    col2: str,\n    vmin: float = None,\n    vmax: float = None,\n    ncolors: int = 15,\n    fact: float = 1.5,\n    cmap: str = \"RdBu_r\",\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with 'latitude', 'longitude', and data columns.\n        col1 (str): Name of the first column (e.g., observations).\n        col2 (str): Name of the second column (e.g., model). Bias is calculated as col2 - col1.\n        vmin (float, optional): Minimum for colorscale.\n        vmax (float, optional): Maximum for colorscale.\n        ncolors (int): Number of discrete colors.\n        fact (float): Scaling factor for point sizes.\n        cmap (str or Colormap): Colormap for bias values.\n        **kwargs: Additional keyword arguments for map creation, passed to\n                  :class:`monet_plots.plots.spatial.SpatialPlot`. These\n                  include `projection`, `figsize`, `ax`, and cartopy\n                  features like `states`, `coastlines`, etc.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.df = to_dataframe(df)\n    self.col1 = col1\n    self.col2 = col2\n    self.vmin = vmin\n    self.vmax = vmax\n    self.ncolors = ncolors\n    self.fact = fact\n    self.cmap = cmap\n</code></pre>"},{"location":"plots/spatial_bias_scatter/#monet_plots.plots.spatial_bias_scatter.SpatialBiasScatterPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spatial bias scatter plot.</p> Source code in <code>src/monet_plots/plots/spatial_bias_scatter.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the spatial bias scatter plot.\"\"\"\n    from numpy import around\n\n    # Separate feature kwargs from scatter kwargs\n    scatter_kwargs = self.add_features(**kwargs)\n\n    # Ensure we are working with a clean copy with no NaNs in relevant columns\n    new = (\n        self.df[[\"latitude\", \"longitude\", self.col1, self.col2]]\n        .dropna()\n        .copy(deep=True)\n    )\n\n    diff = new[self.col2] - new[self.col1]\n    top = around(score(diff.abs(), per=95))\n\n    # Use new scaling tools\n    cmap, norm = get_discrete_scale(\n        diff, cmap=self.cmap, n_levels=self.ncolors, vmin=-top, vmax=top\n    )\n\n    # Create colorbar\n    mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap)\n    cbar = self.add_colorbar(mappable, format=\"%1.2g\")\n    cbar.ax.tick_params(labelsize=10)\n\n    colors = diff\n    ss = diff.abs() / top * 100.0\n    ss[ss &gt; 300] = 300.0\n\n    # Prepare scatter kwargs\n    final_scatter_kwargs = get_plot_kwargs(\n        cmap=cmap,\n        norm=norm,\n        s=ss,\n        c=colors,\n        transform=ccrs.PlateCarree(),\n        edgecolors=\"k\",\n        linewidths=0.25,\n        alpha=0.7,\n        **scatter_kwargs,\n    )\n\n    self.ax.scatter(\n        new.longitude.values,\n        new.latitude.values,\n        **final_scatter_kwargs,\n    )\n    return self.ax\n</code></pre>"},{"location":"plots/spatial_contour/","title":"Spatial Contour","text":""},{"location":"plots/spatial_contour/#monet_plots.plots.spatial_contour.SpatialContourPlot","title":"<code>SpatialContourPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a contour plot on a map with an optional discrete colorbar.</p> <p>This plot is useful for visualizing spatial data with continuous values.</p> Source code in <code>src/monet_plots/plots/spatial_contour.py</code> <pre><code>class SpatialContourPlot(SpatialPlot):\n    \"\"\"Create a contour plot on a map with an optional discrete colorbar.\n\n    This plot is useful for visualizing spatial data with continuous values.\n    \"\"\"\n\n    def __init__(\n        self,\n        modelvar: Any,\n        gridobj,\n        date=None,\n        discrete: bool = True,\n        ncolors: int = None,\n        dtype: str = \"int\",\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n                2D model variable array to contour.\n            modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n                2D model variable array to contour.\n            gridobj (object): Object with LAT and LON variables.\n            date (datetime.datetime): Date/time for the plot title.\n            discrete (bool): If True, use a discrete colorbar.\n            ncolors (int, optional): Number of discrete colors.\n            dtype (str): Data type for colorbar tick labels.\n            **kwargs: Keyword arguments passed to SpatialPlot for\n                projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.modelvar = np.asarray(modelvar)\n        self.gridobj = gridobj\n        self.date = date\n        self.discrete = discrete\n        self.ncolors = ncolors\n        self.dtype = dtype\n\n    def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the spatial contour plot.\"\"\"\n        # Draw map features and get remaining kwargs for contourf\n        plot_kwargs = self.add_features(**kwargs)\n\n        # Try to handle different gridobj structures\n        if hasattr(self.gridobj, \"variables\"):\n            lat_var = self.gridobj.variables[\"LAT\"]\n            lon_var = self.gridobj.variables[\"LON\"]\n\n            # Flexible indexing based on dimension count\n            if lat_var.ndim == 4:\n                lat = lat_var[0, 0, :, :].squeeze()\n                lon = lon_var[0, 0, :, :].squeeze()\n            elif lat_var.ndim == 3:\n                lat = lat_var[0, :, :].squeeze()\n                lon = lon_var[0, :, :].squeeze()\n            else:\n                lat = lat_var.squeeze()\n                lon = lon_var.squeeze()\n        else:\n            # Assume it's already an array or similar\n            lat = self.gridobj.LAT\n            lon = self.gridobj.LON\n\n        # Data is in lat/lon, so specify transform\n        plot_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        mesh = self.ax.contourf(lon, lat, self.modelvar, **plot_kwargs)\n\n        cmap = plot_kwargs.get(\"cmap\")\n        levels = plot_kwargs.get(\"levels\")\n\n        if self.discrete:\n            ncolors = self.ncolors\n            if ncolors is None and levels is not None:\n                # If levels is an int, convert to a sequence for len()\n                if isinstance(levels, int):\n                    ncolors = levels - 1\n                    levels_seq = np.linspace(\n                        np.nanmin(self.modelvar), np.nanmax(self.modelvar), levels\n                    )\n                else:\n                    ncolors = len(levels) - 1\n                    levels_seq = levels\n            else:\n                levels_seq = levels\n            c, _ = colorbar_index(\n                ncolors,\n                cmap,\n                minval=levels_seq[0],\n                maxval=levels_seq[-1],\n                dtype=self.dtype,\n                ax=self.ax,\n            )\n        else:\n            self.add_colorbar(mesh)\n\n        if self.date:\n            titstring = self.date.strftime(\"%B %d %Y %H\")\n            self.ax.set_title(titstring)\n        self.fig.tight_layout()\n        return self.ax\n</code></pre>"},{"location":"plots/spatial_contour/#monet_plots.plots.spatial_contour.SpatialContourPlot.__init__","title":"<code>__init__(modelvar, gridobj, date=None, discrete=True, ncolors=None, dtype='int', *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>modelvar</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D model variable array to contour.</p> required <code>modelvar</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D model variable array to contour.</p> required <code>gridobj</code> <code>object</code> <p>Object with LAT and LON variables.</p> required <code>date</code> <code>datetime</code> <p>Date/time for the plot title.</p> <code>None</code> <code>discrete</code> <code>bool</code> <p>If True, use a discrete colorbar.</p> <code>True</code> <code>ncolors</code> <code>int</code> <p>Number of discrete colors.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>Data type for colorbar tick labels.</p> <code>'int'</code> <code>**kwargs</code> <p>Keyword arguments passed to SpatialPlot for projection and features.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/spatial_contour.py</code> <pre><code>def __init__(\n    self,\n    modelvar: Any,\n    gridobj,\n    date=None,\n    discrete: bool = True,\n    ncolors: int = None,\n    dtype: str = \"int\",\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n            2D model variable array to contour.\n        modelvar (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray):\n            2D model variable array to contour.\n        gridobj (object): Object with LAT and LON variables.\n        date (datetime.datetime): Date/time for the plot title.\n        discrete (bool): If True, use a discrete colorbar.\n        ncolors (int, optional): Number of discrete colors.\n        dtype (str): Data type for colorbar tick labels.\n        **kwargs: Keyword arguments passed to SpatialPlot for\n            projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.modelvar = np.asarray(modelvar)\n    self.gridobj = gridobj\n    self.date = date\n    self.discrete = discrete\n    self.ncolors = ncolors\n    self.dtype = dtype\n</code></pre>"},{"location":"plots/spatial_contour/#monet_plots.plots.spatial_contour.SpatialContourPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spatial contour plot.</p> Source code in <code>src/monet_plots/plots/spatial_contour.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the spatial contour plot.\"\"\"\n    # Draw map features and get remaining kwargs for contourf\n    plot_kwargs = self.add_features(**kwargs)\n\n    # Try to handle different gridobj structures\n    if hasattr(self.gridobj, \"variables\"):\n        lat_var = self.gridobj.variables[\"LAT\"]\n        lon_var = self.gridobj.variables[\"LON\"]\n\n        # Flexible indexing based on dimension count\n        if lat_var.ndim == 4:\n            lat = lat_var[0, 0, :, :].squeeze()\n            lon = lon_var[0, 0, :, :].squeeze()\n        elif lat_var.ndim == 3:\n            lat = lat_var[0, :, :].squeeze()\n            lon = lon_var[0, :, :].squeeze()\n        else:\n            lat = lat_var.squeeze()\n            lon = lon_var.squeeze()\n    else:\n        # Assume it's already an array or similar\n        lat = self.gridobj.LAT\n        lon = self.gridobj.LON\n\n    # Data is in lat/lon, so specify transform\n    plot_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    mesh = self.ax.contourf(lon, lat, self.modelvar, **plot_kwargs)\n\n    cmap = plot_kwargs.get(\"cmap\")\n    levels = plot_kwargs.get(\"levels\")\n\n    if self.discrete:\n        ncolors = self.ncolors\n        if ncolors is None and levels is not None:\n            # If levels is an int, convert to a sequence for len()\n            if isinstance(levels, int):\n                ncolors = levels - 1\n                levels_seq = np.linspace(\n                    np.nanmin(self.modelvar), np.nanmax(self.modelvar), levels\n                )\n            else:\n                ncolors = len(levels) - 1\n                levels_seq = levels\n        else:\n            levels_seq = levels\n        c, _ = colorbar_index(\n            ncolors,\n            cmap,\n            minval=levels_seq[0],\n            maxval=levels_seq[-1],\n            dtype=self.dtype,\n            ax=self.ax,\n        )\n    else:\n        self.add_colorbar(mesh)\n\n    if self.date:\n        titstring = self.date.strftime(\"%B %d %Y %H\")\n        self.ax.set_title(titstring)\n    self.fig.tight_layout()\n    return self.ax\n</code></pre>"},{"location":"plots/spatial_imshow/","title":"Spatial Imshow","text":""},{"location":"plots/spatial_imshow/#monet_plots.plots.spatial_imshow.SpatialImshowPlot","title":"<code>SpatialImshowPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a basic spatial plot using imshow.</p> <p>This plot is useful for visualizing 2D model data on a map.</p> Source code in <code>src/monet_plots/plots/spatial_imshow.py</code> <pre><code>class SpatialImshowPlot(SpatialPlot):\n    \"\"\"Create a basic spatial plot using imshow.\n\n    This plot is useful for visualizing 2D model data on a map.\n    \"\"\"\n\n    def __init__(\n        self,\n        modelvar: Any,\n        gridobj: Any | None = None,\n        plotargs: dict[str, Any] | None = None,\n        ncolors: int = 15,\n        discrete: bool = False,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Parameters\n        ----------\n        modelvar : xarray.DataArray or array-like\n            2D model variable array to plot.\n        gridobj : Any, optional\n            Object with LAT and LON variables to determine extent.\n        plotargs : dict, optional\n            Arguments for imshow.\n        ncolors : int, optional\n            Number of discrete colors for discrete colorbar.\n        discrete : bool, optional\n            If True, use a discrete colorbar.\n        *args : Any\n            Positional arguments for SpatialPlot.\n        **kwargs : Any\n            Keyword arguments passed to SpatialPlot for projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.modelvar = modelvar\n        self.gridobj = gridobj\n        self.plotargs = plotargs\n        self.ncolors = ncolors\n        self.discrete = discrete\n\n    def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n        \"\"\"Generate the spatial imshow plot.\n\n        Returns\n        -------\n        matplotlib.axes.Axes\n            The axes object containing the plot.\n        \"\"\"\n        imshow_kwargs = self.add_features(**kwargs)\n        if self.plotargs:\n            imshow_kwargs.update(self.plotargs)\n\n        # Handle eager vs lazy data by delaying conversion until plotting\n        # we still eventually need a numpy array for imshow.\n        model_data = np.asarray(self.modelvar)\n\n        if self.gridobj is not None:\n            lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n            lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n            extent = [lon.min(), lon.max(), lat.min(), lat.max()]\n        elif hasattr(self.modelvar, \"lat\") and hasattr(self.modelvar, \"lon\"):\n            lat = self.modelvar.lat\n            lon = self.modelvar.lon\n            extent = [lon.min(), lon.max(), lat.min(), lat.max()]\n        else:\n            # Fallback to extent from plotargs or default\n            extent = imshow_kwargs.get(\"extent\", None)\n\n        # imshow requires the extent [lon_min, lon_max, lat_min, lat_max]\n\n        imshow_kwargs.setdefault(\"cmap\", \"viridis\")\n        imshow_kwargs.setdefault(\"origin\", \"lower\")\n        imshow_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        img = self.ax.imshow(model_data, extent=extent, **imshow_kwargs)\n\n        if self.discrete:\n            vmin, vmax = img.get_clim()\n            colorbar_index(\n                self.ncolors,\n                imshow_kwargs[\"cmap\"],\n                minval=vmin,\n                maxval=vmax,\n                ax=self.ax,\n            )\n        else:\n            self.add_colorbar(img)\n\n        return self.ax\n</code></pre>"},{"location":"plots/spatial_imshow/#monet_plots.plots.spatial_imshow.SpatialImshowPlot.__init__","title":"<code>__init__(modelvar, gridobj=None, plotargs=None, ncolors=15, discrete=False, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p>"},{"location":"plots/spatial_imshow/#monet_plots.plots.spatial_imshow.SpatialImshowPlot.__init__--parameters","title":"Parameters","text":"<p>modelvar : xarray.DataArray or array-like     2D model variable array to plot. gridobj : Any, optional     Object with LAT and LON variables to determine extent. plotargs : dict, optional     Arguments for imshow. ncolors : int, optional     Number of discrete colors for discrete colorbar. discrete : bool, optional     If True, use a discrete colorbar. args : Any     Positional arguments for SpatialPlot. *kwargs : Any     Keyword arguments passed to SpatialPlot for projection and features.</p> Source code in <code>src/monet_plots/plots/spatial_imshow.py</code> <pre><code>def __init__(\n    self,\n    modelvar: Any,\n    gridobj: Any | None = None,\n    plotargs: dict[str, Any] | None = None,\n    ncolors: int = 15,\n    discrete: bool = False,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Parameters\n    ----------\n    modelvar : xarray.DataArray or array-like\n        2D model variable array to plot.\n    gridobj : Any, optional\n        Object with LAT and LON variables to determine extent.\n    plotargs : dict, optional\n        Arguments for imshow.\n    ncolors : int, optional\n        Number of discrete colors for discrete colorbar.\n    discrete : bool, optional\n        If True, use a discrete colorbar.\n    *args : Any\n        Positional arguments for SpatialPlot.\n    **kwargs : Any\n        Keyword arguments passed to SpatialPlot for projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.modelvar = modelvar\n    self.gridobj = gridobj\n    self.plotargs = plotargs\n    self.ncolors = ncolors\n    self.discrete = discrete\n</code></pre>"},{"location":"plots/spatial_imshow/#monet_plots.plots.spatial_imshow.SpatialImshowPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the spatial imshow plot.</p>"},{"location":"plots/spatial_imshow/#monet_plots.plots.spatial_imshow.SpatialImshowPlot.plot--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The axes object containing the plot.</p> Source code in <code>src/monet_plots/plots/spatial_imshow.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; matplotlib.axes.Axes:\n    \"\"\"Generate the spatial imshow plot.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The axes object containing the plot.\n    \"\"\"\n    imshow_kwargs = self.add_features(**kwargs)\n    if self.plotargs:\n        imshow_kwargs.update(self.plotargs)\n\n    # Handle eager vs lazy data by delaying conversion until plotting\n    # we still eventually need a numpy array for imshow.\n    model_data = np.asarray(self.modelvar)\n\n    if self.gridobj is not None:\n        lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n        lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n        extent = [lon.min(), lon.max(), lat.min(), lat.max()]\n    elif hasattr(self.modelvar, \"lat\") and hasattr(self.modelvar, \"lon\"):\n        lat = self.modelvar.lat\n        lon = self.modelvar.lon\n        extent = [lon.min(), lon.max(), lat.min(), lat.max()]\n    else:\n        # Fallback to extent from plotargs or default\n        extent = imshow_kwargs.get(\"extent\", None)\n\n    # imshow requires the extent [lon_min, lon_max, lat_min, lat_max]\n\n    imshow_kwargs.setdefault(\"cmap\", \"viridis\")\n    imshow_kwargs.setdefault(\"origin\", \"lower\")\n    imshow_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    img = self.ax.imshow(model_data, extent=extent, **imshow_kwargs)\n\n    if self.discrete:\n        vmin, vmax = img.get_clim()\n        colorbar_index(\n            self.ncolors,\n            imshow_kwargs[\"cmap\"],\n            minval=vmin,\n            maxval=vmax,\n            ax=self.ax,\n        )\n    else:\n        self.add_colorbar(img)\n\n    return self.ax\n</code></pre>"},{"location":"plots/taylor_diagram/","title":"Taylor Diagram","text":""},{"location":"plots/taylor_diagram/#monet_plots.plots.taylor_diagram.TaylorDiagramPlot","title":"<code>TaylorDiagramPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a DataFrame-based Taylor diagram.</p> <p>A convenience wrapper for easily creating Taylor diagrams from DataFrames.</p> Source code in <code>src/monet_plots/plots/taylor_diagram.py</code> <pre><code>class TaylorDiagramPlot(BasePlot):\n    \"\"\"Create a DataFrame-based Taylor diagram.\n\n    A convenience wrapper for easily creating Taylor diagrams from DataFrames.\n    \"\"\"\n\n    def __init__(\n        self,\n        df: Any,\n        col1: str = \"obs\",\n        col2: Union[str, List[str]] = \"model\",\n        label1: str = \"OBS\",\n        scale: float = 1.5,\n        dia=None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and diagram settings.\n\n        Args:\n            df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with observation and model data.\n            col1 (str): Column name for observations.\n            col2 (str or list): Column name(s) for model predictions.\n            label1 (str): Label for observations.\n            scale (float): Scale factor for diagram.\n            dia (TaylorDiagram, optional): Existing diagram to add to.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.col1 = col1\n        if isinstance(col2, str):\n            self.col2 = [col2]\n        else:\n            self.col2 = col2\n\n        # Ensure all specified columns exist before proceeding\n        required_cols = [self.col1] + self.col2\n        self.df = to_dataframe(df).dropna(subset=required_cols)\n\n        self.label1 = label1\n        self.scale = scale\n        self.dia = dia\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the Taylor diagram.\"\"\"\n        # If no diagram is provided, create a new one\n        if self.dia is None:\n            obsstd = self.df[self.col1].std()\n\n            # Remove the default axes created by BasePlot to avoid an extra empty plot\n            if hasattr(self, \"ax\") and self.ax is not None:\n                self.fig.delaxes(self.ax)\n\n            # Use self.fig which is created in BasePlot.__init__\n            self.dia = td.TaylorDiagram(\n                obsstd, scale=self.scale, fig=self.fig, rect=111, label=self.label1\n            )\n            # Update self.ax to the one created by TaylorDiagram\n            self.ax = self.dia._ax\n\n            # Add contours for the new diagram\n            contours = self.dia.add_contours(colors=\"0.5\")\n            plt.clabel(contours, inline=1, fontsize=10)\n\n        # Loop through each model column and add it to the diagram\n        for model_col in self.col2:\n            model_std = self.df[model_col].std()\n            cc = corrcoef(self.df[self.col1].values, self.df[model_col].values)[0, 1]\n            self.dia.add_sample(model_std, cc, label=model_col, **kwargs)\n\n        self.fig.legend(\n            self.dia.samplePoints,\n            [p.get_label() for p in self.dia.samplePoints],\n            numpoints=1,\n            loc=\"upper right\",\n        )\n        self.fig.tight_layout()\n        return self.dia\n</code></pre>"},{"location":"plots/taylor_diagram/#monet_plots.plots.taylor_diagram.TaylorDiagramPlot.__init__","title":"<code>__init__(df, col1='obs', col2='model', label1='OBS', scale=1.5, dia=None, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and diagram settings.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>DataFrame with observation and model data.</p> required <code>col1</code> <code>str</code> <p>Column name for observations.</p> <code>'obs'</code> <code>col2</code> <code>str or list</code> <p>Column name(s) for model predictions.</p> <code>'model'</code> <code>label1</code> <code>str</code> <p>Label for observations.</p> <code>'OBS'</code> <code>scale</code> <code>float</code> <p>Scale factor for diagram.</p> <code>1.5</code> <code>dia</code> <code>TaylorDiagram</code> <p>Existing diagram to add to.</p> <code>None</code> Source code in <code>src/monet_plots/plots/taylor_diagram.py</code> <pre><code>def __init__(\n    self,\n    df: Any,\n    col1: str = \"obs\",\n    col2: Union[str, List[str]] = \"model\",\n    label1: str = \"OBS\",\n    scale: float = 1.5,\n    dia=None,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and diagram settings.\n\n    Args:\n        df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray): DataFrame with observation and model data.\n        col1 (str): Column name for observations.\n        col2 (str or list): Column name(s) for model predictions.\n        label1 (str): Label for observations.\n        scale (float): Scale factor for diagram.\n        dia (TaylorDiagram, optional): Existing diagram to add to.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.col1 = col1\n    if isinstance(col2, str):\n        self.col2 = [col2]\n    else:\n        self.col2 = col2\n\n    # Ensure all specified columns exist before proceeding\n    required_cols = [self.col1] + self.col2\n    self.df = to_dataframe(df).dropna(subset=required_cols)\n\n    self.label1 = label1\n    self.scale = scale\n    self.dia = dia\n</code></pre>"},{"location":"plots/taylor_diagram/#monet_plots.plots.taylor_diagram.TaylorDiagramPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the Taylor diagram.</p> Source code in <code>src/monet_plots/plots/taylor_diagram.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the Taylor diagram.\"\"\"\n    # If no diagram is provided, create a new one\n    if self.dia is None:\n        obsstd = self.df[self.col1].std()\n\n        # Remove the default axes created by BasePlot to avoid an extra empty plot\n        if hasattr(self, \"ax\") and self.ax is not None:\n            self.fig.delaxes(self.ax)\n\n        # Use self.fig which is created in BasePlot.__init__\n        self.dia = td.TaylorDiagram(\n            obsstd, scale=self.scale, fig=self.fig, rect=111, label=self.label1\n        )\n        # Update self.ax to the one created by TaylorDiagram\n        self.ax = self.dia._ax\n\n        # Add contours for the new diagram\n        contours = self.dia.add_contours(colors=\"0.5\")\n        plt.clabel(contours, inline=1, fontsize=10)\n\n    # Loop through each model column and add it to the diagram\n    for model_col in self.col2:\n        model_std = self.df[model_col].std()\n        cc = corrcoef(self.df[self.col1].values, self.df[model_col].values)[0, 1]\n        self.dia.add_sample(model_std, cc, label=model_col, **kwargs)\n\n    self.fig.legend(\n        self.dia.samplePoints,\n        [p.get_label() for p in self.dia.samplePoints],\n        numpoints=1,\n        loc=\"upper right\",\n    )\n    self.fig.tight_layout()\n    return self.dia\n</code></pre>"},{"location":"plots/timeseries/","title":"Time Series Plots","text":""},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesPlot","title":"<code>TimeSeriesPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a timeseries plot with shaded error bounds.</p> <p>This function groups the data by time, plots the mean values, and adds shading for \u00b11 standard deviation around the mean.</p> Source code in <code>src/monet_plots/plots/timeseries.py</code> <pre><code>class TimeSeriesPlot(BasePlot):\n    \"\"\"Create a timeseries plot with shaded error bounds.\n\n    This function groups the data by time, plots the mean values, and adds\n    shading for \u00b11 standard deviation around the mean.\n    \"\"\"\n\n    def __init__(\n        self,\n        df: Any,\n        x: str = \"time\",\n        y: str = \"obs\",\n        plotargs: dict = {},\n        fillargs: dict = None,\n        title: str = \"\",\n        ylabel: Optional[str] = None,\n        label: Optional[str] = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the plot with data and plot settings.\n\n        Args:\n            df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray):\n                DataFrame with the data to plot.\n            x (str): Column name for the x-axis (time).\n            y (str): Column name for the y-axis (values).\n            plotargs (dict): Arguments for the plot.\n            fillargs (dict): Arguments for fill_between.\n            title (str): Title for the plot.\n            ylabel (str, optional): Y-axis label.\n            label (str, optional): Label for the plotted line.\n            *args, **kwargs: Arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1)\n\n        self.df = normalize_data(df)\n        self.x = x\n        self.y = y\n        self.plotargs = plotargs\n        self.fillargs = fillargs if fillargs is not None else {\"alpha\": 0.2}\n        self.title = title\n        self.ylabel = ylabel\n        self.label = label\n\n    def plot(self, **kwargs: Any) -&gt; plt.Axes:\n        \"\"\"\n        Generate the timeseries plot.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Overrides for plot settings (x, y, title, ylabel, label, etc.).\n\n        Returns\n        -------\n        plt.Axes\n            The matplotlib axes object containing the plot.\n\n        Examples\n        --------\n        &gt;&gt;&gt; plot = TimeSeriesPlot(df, x='time', y='obs')\n        &gt;&gt;&gt; ax = plot.plot(title='Observation Over Time')\n        \"\"\"\n        # Update attributes from kwargs if provided\n        for attr in [\"x\", \"y\", \"title\", \"ylabel\", \"label\"]:\n            if attr in kwargs:\n                setattr(self, attr, kwargs.pop(attr))\n\n        import xarray as xr\n\n        # Handle xarray objects differently from pandas DataFrames\n        if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n            return self._plot_xarray(**kwargs)\n        else:\n            return self._plot_dataframe(**kwargs)\n\n    def _plot_dataframe(self, **kwargs: Any) -&gt; plt.Axes:\n        \"\"\"\n        Generate the timeseries plot from pandas DataFrame.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Additional plotting arguments.\n\n        Returns\n        -------\n        plt.Axes\n            The matplotlib axes object.\n\n        Examples\n        --------\n        &gt;&gt;&gt; plot._plot_dataframe()\n        \"\"\"\n        df = self.df.copy()\n        df.index = df[self.x]\n        # Keep only numeric columns for grouping, but make sure self.y is there\n        df = df.reset_index(drop=True)\n        # We need to preserve self.x for grouping if it's not the index\n        m = self.df.groupby(self.x).mean(numeric_only=True)\n        e = self.df.groupby(self.x).std(numeric_only=True)\n\n        variable = self.y\n        unit = \"None\"\n        if \"units\" in self.df.columns:\n            unit = str(self.df[\"units\"].iloc[0])\n\n        upper = m[self.y] + e[self.y]\n        lower = m[self.y] - e[self.y]\n        # lower.loc[lower &lt; 0] = 0 # Not always desired for all variables\n        lower_vals = lower.values\n        upper_vals = upper.values\n\n        if self.label is not None:\n            plot_label = self.label\n        else:\n            plot_label = self.y\n\n        m[self.y].plot(ax=self.ax, label=plot_label, **self.plotargs)\n        self.ax.fill_between(m.index, lower_vals, upper_vals, **self.fillargs)\n\n        if self.ylabel is None:\n            self.ax.set_ylabel(f\"{variable} ({unit})\")\n        else:\n            self.ax.set_ylabel(self.ylabel)\n\n        self.ax.set_xlabel(self.x)\n        self.ax.legend()\n        self.ax.set_title(self.title)\n        self.fig.tight_layout()\n        return self.ax\n\n    def _plot_xarray(self, **kwargs: Any) -&gt; plt.Axes:\n        \"\"\"\n        Generate the timeseries plot from xarray DataArray or Dataset.\n\n        Parameters\n        ----------\n        **kwargs : Any\n            Additional plotting arguments.\n\n        Returns\n        -------\n        plt.Axes\n            The matplotlib axes object.\n\n        Examples\n        --------\n        &gt;&gt;&gt; plot._plot_xarray()\n        \"\"\"\n        import xarray as xr\n\n        # Ensure we have the right data structure\n        if isinstance(self.df, xr.DataArray):\n            data = (\n                self.df.to_dataset(name=self.y)\n                if self.df.name is None\n                else self.df.to_dataset()\n            )\n            if self.df.name is not None:\n                self.y = self.df.name\n        else:\n            data = self.df\n\n        # Calculate mean and std along other dimensions if any\n        # If it's already a 1D time series, mean/std won't do much\n        dims_to_reduce = [d for d in data[self.y].dims if d != self.x]\n\n        if dims_to_reduce:\n            mean_data = data[self.y].mean(dim=dims_to_reduce)\n            std_data = data[self.y].std(dim=dims_to_reduce)\n        else:\n            mean_data = data[self.y]\n            std_data = xr.zeros_like(mean_data)\n\n        plot_label = self.label if self.label is not None else self.y\n        mean_data.plot(ax=self.ax, label=plot_label, **self.plotargs)\n\n        upper = mean_data + std_data\n        lower = mean_data - std_data\n\n        self.ax.fill_between(\n            mean_data[self.x].values, lower.values, upper.values, **self.fillargs\n        )\n\n        unit = data[self.y].attrs.get(\"units\", \"None\")\n\n        if self.ylabel is None:\n            self.ax.set_ylabel(f\"{self.y} ({unit})\")\n        else:\n            self.ax.set_ylabel(self.ylabel)\n\n        self.ax.set_xlabel(self.x)\n        self.ax.legend()\n        self.ax.set_title(self.title)\n        self.fig.tight_layout()\n        return self.ax\n</code></pre>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesPlot.__init__","title":"<code>__init__(df, x='time', y='obs', plotargs={}, fillargs=None, title='', ylabel=None, label=None, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and plot settings.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>(DataFrame, ndarray, Dataset, DataArray)</code> <p>DataFrame with the data to plot.</p> required <code>x</code> <code>str</code> <p>Column name for the x-axis (time).</p> <code>'time'</code> <code>y</code> <code>str</code> <p>Column name for the y-axis (values).</p> <code>'obs'</code> <code>plotargs</code> <code>dict</code> <p>Arguments for the plot.</p> <code>{}</code> <code>fillargs</code> <code>dict</code> <p>Arguments for fill_between.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>Y-axis label.</p> <code>None</code> <code>label</code> <code>str</code> <p>Label for the plotted line.</p> <code>None</code> <code>*args, **kwargs</code> <p>Arguments passed to BasePlot.</p> required Source code in <code>src/monet_plots/plots/timeseries.py</code> <pre><code>def __init__(\n    self,\n    df: Any,\n    x: str = \"time\",\n    y: str = \"obs\",\n    plotargs: dict = {},\n    fillargs: dict = None,\n    title: str = \"\",\n    ylabel: Optional[str] = None,\n    label: Optional[str] = None,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initialize the plot with data and plot settings.\n\n    Args:\n        df (pd.DataFrame, np.ndarray, xr.Dataset, xr.DataArray):\n            DataFrame with the data to plot.\n        x (str): Column name for the x-axis (time).\n        y (str): Column name for the y-axis (values).\n        plotargs (dict): Arguments for the plot.\n        fillargs (dict): Arguments for fill_between.\n        title (str): Title for the plot.\n        ylabel (str, optional): Y-axis label.\n        label (str, optional): Label for the plotted line.\n        *args, **kwargs: Arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1)\n\n    self.df = normalize_data(df)\n    self.x = x\n    self.y = y\n    self.plotargs = plotargs\n    self.fillargs = fillargs if fillargs is not None else {\"alpha\": 0.2}\n    self.title = title\n    self.ylabel = ylabel\n    self.label = label\n</code></pre>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the timeseries plot.</p>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesPlot.plot--parameters","title":"Parameters","text":"<p>**kwargs : Any     Overrides for plot settings (x, y, title, ylabel, label, etc.).</p>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesPlot.plot--returns","title":"Returns","text":"<p>plt.Axes     The matplotlib axes object containing the plot.</p>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesPlot.plot--examples","title":"Examples","text":"<p>plot = TimeSeriesPlot(df, x='time', y='obs') ax = plot.plot(title='Observation Over Time')</p> Source code in <code>src/monet_plots/plots/timeseries.py</code> <pre><code>def plot(self, **kwargs: Any) -&gt; plt.Axes:\n    \"\"\"\n    Generate the timeseries plot.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Overrides for plot settings (x, y, title, ylabel, label, etc.).\n\n    Returns\n    -------\n    plt.Axes\n        The matplotlib axes object containing the plot.\n\n    Examples\n    --------\n    &gt;&gt;&gt; plot = TimeSeriesPlot(df, x='time', y='obs')\n    &gt;&gt;&gt; ax = plot.plot(title='Observation Over Time')\n    \"\"\"\n    # Update attributes from kwargs if provided\n    for attr in [\"x\", \"y\", \"title\", \"ylabel\", \"label\"]:\n        if attr in kwargs:\n            setattr(self, attr, kwargs.pop(attr))\n\n    import xarray as xr\n\n    # Handle xarray objects differently from pandas DataFrames\n    if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n        return self._plot_xarray(**kwargs)\n    else:\n        return self._plot_dataframe(**kwargs)\n</code></pre>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesStatsPlot","title":"<code>TimeSeriesStatsPlot</code>","text":"<p>               Bases: <code>BasePlot</code></p> <p>Create a time series plot of a specified statistic calculated between observations and model data, resampled to a given frequency.</p> <p>Supports lazy evaluation via xarray and dask.</p> Source code in <code>src/monet_plots/plots/timeseries.py</code> <pre><code>class TimeSeriesStatsPlot(BasePlot):\n    \"\"\"\n    Create a time series plot of a specified statistic calculated between\n    observations and model data, resampled to a given frequency.\n\n    Supports lazy evaluation via xarray and dask.\n    \"\"\"\n\n    def __init__(\n        self,\n        df: Any,\n        col1: str,\n        col2: Union[str, list[str]],\n        x: Optional[str] = None,\n        fig: Optional[matplotlib.figure.Figure] = None,\n        ax: Optional[matplotlib.axes.Axes] = None,\n        **kwargs: Any,\n    ):\n        \"\"\"\n        Initialize the TimeSeriesStatsPlot.\n\n        Parameters\n        ----------\n        df : Any\n            Data containing a time coordinate and the columns to compare.\n            Can be pandas DataFrame, xarray Dataset, or xarray DataArray.\n        col1 : str\n            Name of the first column/variable (e.g., 'Obs').\n        col2 : str or list of str\n            Name of the second column(s)/variable(s) (e.g., 'Model').\n        x : str, optional\n            The time dimension/column name. If None, it attempts to find it\n            automatically (prefers 'time' or 'datetime'), by default None.\n        fig : matplotlib.figure.Figure, optional\n            An existing Figure object.\n        ax : matplotlib.axes.Axes, optional\n            An existing Axes object.\n        **kwargs : Any\n            Additional arguments passed to BasePlot.\n        \"\"\"\n        super().__init__(fig=fig, ax=ax, **kwargs)\n        if self.ax is None:\n            self.ax = self.fig.add_subplot(1, 1, 1)\n\n        self.df = normalize_data(df)\n        self.col1 = col1\n        self.col2 = [col2] if isinstance(col2, str) else col2\n\n        # Determine time coordinate/column\n        if x is not None:\n            self.x = x\n        else:\n            self.x = self._identify_time_coord()\n\n        # Update history for provenance if xarray\n        if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n            history = self.df.attrs.get(\"history\", \"\")\n            self.df.attrs[\"history\"] = f\"Initialized TimeSeriesStatsPlot; {history}\"\n\n    def _identify_time_coord(self) -&gt; str:\n        \"\"\"\n        Identify the time coordinate or column in the data.\n\n        Returns\n        -------\n        str\n            The identified time coordinate or column name.\n\n        Raises\n        ------\n        ValueError\n            If no suitable time coordinate or column is found.\n        \"\"\"\n        if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n            for candidate in [\"time\", \"datetime\", \"date\"]:\n                if candidate in self.df.coords or candidate in self.df.dims:\n                    return candidate\n            return self.df.dims[0]\n\n        # Pandas\n        if isinstance(self.df.index, pd.DatetimeIndex):\n            return self.df.index.name if self.df.index.name else \"index\"\n        for candidate in [\"time\", \"datetime\", \"date\"]:\n            if candidate in self.df.columns:\n                return candidate\n        raise ValueError(\n            \"Could not identify time coordinate. Please specify 'x' parameter.\"\n        )\n\n    def plot(self, stat: str = \"bias\", freq: str = \"D\", **kwargs: Any) -&gt; plt.Axes:\n        \"\"\"\n        Generate the time series plot for the chosen statistic.\n\n        Parameters\n        ----------\n        stat : str, optional\n            The statistic to calculate (e.g., 'bias', 'rmse', 'mae', 'corr').\n            Supports any 'compute_&lt;stat&gt;' function in verification_metrics,\n            by default \"bias\".\n        freq : str, optional\n            The resampling frequency (e.g., 'H', 'D', 'W', 'M'), by default \"D\".\n        **kwargs : Any\n            Keyword arguments passed to the plotting method.\n\n        Returns\n        -------\n        matplotlib.axes.Axes\n            The axes object with the plot.\n        \"\"\"\n        from .. import verification_metrics\n\n        stat_lower = stat.lower()\n        metric_func = getattr(verification_metrics, f\"compute_{stat_lower}\", None)\n        if metric_func is None:\n            raise ValueError(f\"Statistic '{stat}' is not supported.\")\n\n        plot_kwargs = {\"marker\": \"o\", \"linestyle\": \"-\"}\n        plot_kwargs.update(kwargs)\n\n        # Handle 'grid' separately as it's not a Line2D property\n        show_grid = plot_kwargs.pop(\"grid\", True)\n\n        if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n            self._plot_xarray(metric_func, freq, stat_lower, plot_kwargs)\n        else:\n            self._plot_dataframe(metric_func, freq, stat_lower, plot_kwargs)\n\n        if show_grid:\n            self.ax.grid(True)\n\n        self.ax.set_ylabel(stat.upper())\n        self.ax.set_xlabel(self.x.capitalize())\n        self.ax.legend()\n        self.fig.tight_layout()\n\n        # Update history for provenance\n        if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n            history = self.df.attrs.get(\"history\", \"\")\n            self.df.attrs[\"history\"] = (\n                f\"Generated TimeSeriesStatsPlot ({stat}, freq={freq}); {history}\"\n            )\n\n        return self.ax\n\n    def _plot_xarray(\n        self, metric_func: Any, freq: str, stat_name: str, plot_kwargs: dict\n    ) -&gt; None:\n        \"\"\"\n        Perform vectorized xarray/dask resampling and plotting.\n\n        Parameters\n        ----------\n        metric_func : Any\n            The metric function from verification_metrics to apply.\n        freq : str\n            The resampling frequency (e.g., 'D', 'H').\n        stat_name : str\n            The name of the statistic being calculated.\n        plot_kwargs : dict\n            Keyword arguments for the plot call.\n\n        Examples\n        --------\n        &gt;&gt;&gt; plot._plot_xarray(compute_bias, 'D', 'bias', {'color': 'red'})\n        \"\"\"\n        for model_col in self.col2:\n\n            def resample_func(ds):\n                # Dim is None means reduce over all dimensions in the group\n                # which is correct for a time series plot of a bulk statistic.\n                return metric_func(ds[self.col1], ds[model_col])\n\n            # Resample and calculate using .map() to maintain laziness\n            resampled = self.df.resample({self.x: freq})\n            stat_series = resampled.map(resample_func)\n\n            # Extract label if present or use col name\n            label = model_col\n            stat_series.plot(ax=self.ax, label=label, **plot_kwargs)\n\n    def _plot_dataframe(\n        self, metric_func: Any, freq: str, stat_name: str, plot_kwargs: dict\n    ) -&gt; None:\n        \"\"\"\n        Perform resampling and plotting for pandas DataFrames.\n\n        Parameters\n        ----------\n        metric_func : Any\n            The metric function from verification_metrics to apply.\n        freq : str\n            The resampling frequency (e.g., 'D', 'H').\n        stat_name : str\n            The name of the statistic being calculated.\n        plot_kwargs : dict\n            Keyword arguments for the plot call.\n\n        Examples\n        --------\n        &gt;&gt;&gt; plot._plot_dataframe(compute_bias, 'D', 'bias', {'marker': 'x'})\n        \"\"\"\n        df = self.df.copy()\n        if self.x != \"index\" and self.x in df.columns:\n            df = df.set_index(self.x)\n\n        if not isinstance(df.index, pd.DatetimeIndex):\n            df.index = pd.to_datetime(df.index)\n\n        for model_col in self.col2:\n            # Resample and apply metric\n            # Note: Pandas resample.apply is less efficient but necessary here\n            # for arbitrary metric functions on DataFrames.\n            def pandas_metric(group):\n                return metric_func(group[self.col1].values, group[model_col].values)\n\n            stat_series = df.resample(freq).apply(pandas_metric)\n            stat_series.plot(ax=self.ax, label=model_col, **plot_kwargs)\n</code></pre>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesStatsPlot.__init__","title":"<code>__init__(df, col1, col2, x=None, fig=None, ax=None, **kwargs)</code>","text":"<p>Initialize the TimeSeriesStatsPlot.</p>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesStatsPlot.__init__--parameters","title":"Parameters","text":"<p>df : Any     Data containing a time coordinate and the columns to compare.     Can be pandas DataFrame, xarray Dataset, or xarray DataArray. col1 : str     Name of the first column/variable (e.g., 'Obs'). col2 : str or list of str     Name of the second column(s)/variable(s) (e.g., 'Model'). x : str, optional     The time dimension/column name. If None, it attempts to find it     automatically (prefers 'time' or 'datetime'), by default None. fig : matplotlib.figure.Figure, optional     An existing Figure object. ax : matplotlib.axes.Axes, optional     An existing Axes object. **kwargs : Any     Additional arguments passed to BasePlot.</p> Source code in <code>src/monet_plots/plots/timeseries.py</code> <pre><code>def __init__(\n    self,\n    df: Any,\n    col1: str,\n    col2: Union[str, list[str]],\n    x: Optional[str] = None,\n    fig: Optional[matplotlib.figure.Figure] = None,\n    ax: Optional[matplotlib.axes.Axes] = None,\n    **kwargs: Any,\n):\n    \"\"\"\n    Initialize the TimeSeriesStatsPlot.\n\n    Parameters\n    ----------\n    df : Any\n        Data containing a time coordinate and the columns to compare.\n        Can be pandas DataFrame, xarray Dataset, or xarray DataArray.\n    col1 : str\n        Name of the first column/variable (e.g., 'Obs').\n    col2 : str or list of str\n        Name of the second column(s)/variable(s) (e.g., 'Model').\n    x : str, optional\n        The time dimension/column name. If None, it attempts to find it\n        automatically (prefers 'time' or 'datetime'), by default None.\n    fig : matplotlib.figure.Figure, optional\n        An existing Figure object.\n    ax : matplotlib.axes.Axes, optional\n        An existing Axes object.\n    **kwargs : Any\n        Additional arguments passed to BasePlot.\n    \"\"\"\n    super().__init__(fig=fig, ax=ax, **kwargs)\n    if self.ax is None:\n        self.ax = self.fig.add_subplot(1, 1, 1)\n\n    self.df = normalize_data(df)\n    self.col1 = col1\n    self.col2 = [col2] if isinstance(col2, str) else col2\n\n    # Determine time coordinate/column\n    if x is not None:\n        self.x = x\n    else:\n        self.x = self._identify_time_coord()\n\n    # Update history for provenance if xarray\n    if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n        history = self.df.attrs.get(\"history\", \"\")\n        self.df.attrs[\"history\"] = f\"Initialized TimeSeriesStatsPlot; {history}\"\n</code></pre>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesStatsPlot.plot","title":"<code>plot(stat='bias', freq='D', **kwargs)</code>","text":"<p>Generate the time series plot for the chosen statistic.</p>"},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesStatsPlot.plot--parameters","title":"Parameters","text":"<p>stat : str, optional     The statistic to calculate (e.g., 'bias', 'rmse', 'mae', 'corr').     Supports any 'compute_' function in verification_metrics,     by default \"bias\". freq : str, optional     The resampling frequency (e.g., 'H', 'D', 'W', 'M'), by default \"D\". **kwargs : Any     Keyword arguments passed to the plotting method."},{"location":"plots/timeseries/#monet_plots.plots.timeseries.TimeSeriesStatsPlot.plot--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The axes object with the plot.</p> Source code in <code>src/monet_plots/plots/timeseries.py</code> <pre><code>def plot(self, stat: str = \"bias\", freq: str = \"D\", **kwargs: Any) -&gt; plt.Axes:\n    \"\"\"\n    Generate the time series plot for the chosen statistic.\n\n    Parameters\n    ----------\n    stat : str, optional\n        The statistic to calculate (e.g., 'bias', 'rmse', 'mae', 'corr').\n        Supports any 'compute_&lt;stat&gt;' function in verification_metrics,\n        by default \"bias\".\n    freq : str, optional\n        The resampling frequency (e.g., 'H', 'D', 'W', 'M'), by default \"D\".\n    **kwargs : Any\n        Keyword arguments passed to the plotting method.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The axes object with the plot.\n    \"\"\"\n    from .. import verification_metrics\n\n    stat_lower = stat.lower()\n    metric_func = getattr(verification_metrics, f\"compute_{stat_lower}\", None)\n    if metric_func is None:\n        raise ValueError(f\"Statistic '{stat}' is not supported.\")\n\n    plot_kwargs = {\"marker\": \"o\", \"linestyle\": \"-\"}\n    plot_kwargs.update(kwargs)\n\n    # Handle 'grid' separately as it's not a Line2D property\n    show_grid = plot_kwargs.pop(\"grid\", True)\n\n    if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n        self._plot_xarray(metric_func, freq, stat_lower, plot_kwargs)\n    else:\n        self._plot_dataframe(metric_func, freq, stat_lower, plot_kwargs)\n\n    if show_grid:\n        self.ax.grid(True)\n\n    self.ax.set_ylabel(stat.upper())\n    self.ax.set_xlabel(self.x.capitalize())\n    self.ax.legend()\n    self.fig.tight_layout()\n\n    # Update history for provenance\n    if isinstance(self.df, (xr.DataArray, xr.Dataset)):\n        history = self.df.attrs.get(\"history\", \"\")\n        self.df.attrs[\"history\"] = (\n            f\"Generated TimeSeriesStatsPlot ({stat}, freq={freq}); {history}\"\n        )\n\n    return self.ax\n</code></pre>"},{"location":"plots/wind/","title":"Wind Plots","text":""},{"location":"plots/wind/#monet_plots.plots.wind_quiver.WindQuiverPlot","title":"<code>WindQuiverPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a quiver plot of wind vectors on a map.</p> <p>This plot shows wind speed and direction using arrows.</p> Source code in <code>src/monet_plots/plots/wind_quiver.py</code> <pre><code>class WindQuiverPlot(SpatialPlot):\n    \"\"\"Create a quiver plot of wind vectors on a map.\n\n    This plot shows wind speed and direction using arrows.\n    \"\"\"\n\n    def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n            wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n            gridobj (object): Object with LAT and LON variables.\n            **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.ws = np.asarray(ws)\n        self.wdir = np.asarray(wdir)\n        self.gridobj = gridobj\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the wind quiver plot.\"\"\"\n        quiver_kwargs = self.add_features(**kwargs)\n        quiver_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n        lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n        u, v = tools.wsdir2uv(self.ws, self.wdir)\n        # Subsample the data for clarity\n        quiv = self.ax.quiver(\n            lon[::15, ::15],\n            lat[::15, ::15],\n            u[::15, ::15],\n            v[::15, ::15],\n            **quiver_kwargs,\n        )\n        return quiv\n</code></pre>"},{"location":"plots/wind/#monet_plots.plots.wind_quiver.WindQuiverPlot.__init__","title":"<code>__init__(ws, wdir, gridobj, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>ws</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind speeds.</p> required <code>wdir</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind directions.</p> required <code>gridobj</code> <code>object</code> <p>Object with LAT and LON variables.</p> required <code>**kwargs</code> <p>Keyword arguments passed to SpatialPlot for projection and features.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/wind_quiver.py</code> <pre><code>def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n        wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n        gridobj (object): Object with LAT and LON variables.\n        **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.ws = np.asarray(ws)\n    self.wdir = np.asarray(wdir)\n    self.gridobj = gridobj\n</code></pre>"},{"location":"plots/wind/#monet_plots.plots.wind_quiver.WindQuiverPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the wind quiver plot.</p> Source code in <code>src/monet_plots/plots/wind_quiver.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the wind quiver plot.\"\"\"\n    quiver_kwargs = self.add_features(**kwargs)\n    quiver_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n    lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n    u, v = tools.wsdir2uv(self.ws, self.wdir)\n    # Subsample the data for clarity\n    quiv = self.ax.quiver(\n        lon[::15, ::15],\n        lat[::15, ::15],\n        u[::15, ::15],\n        v[::15, ::15],\n        **quiver_kwargs,\n    )\n    return quiv\n</code></pre>"},{"location":"plots/wind/#monet_plots.plots.wind_barbs.WindBarbsPlot","title":"<code>WindBarbsPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a barbs plot of wind on a map.</p> <p>This plot shows wind speed and direction using barbs.</p> Source code in <code>src/monet_plots/plots/wind_barbs.py</code> <pre><code>class WindBarbsPlot(SpatialPlot):\n    \"\"\"Create a barbs plot of wind on a map.\n\n    This plot shows wind speed and direction using barbs.\n    \"\"\"\n\n    def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n            wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n            gridobj (object): Object with LAT and LON variables.\n            **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.ws = np.asarray(ws)\n        self.wdir = np.asarray(wdir)\n        self.gridobj = gridobj\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the wind barbs plot.\"\"\"\n        barb_kwargs = self.add_features(**kwargs)\n        barb_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n        lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n        u, v = tools.wsdir2uv(self.ws, self.wdir)\n        # Subsample the data for clarity\n        skip = barb_kwargs.pop(\"skip\", 15)\n        self.ax.barbs(\n            lon[::skip, ::skip],\n            lat[::skip, ::skip],\n            u[::skip, ::skip],\n            v[::skip, ::skip],\n            **barb_kwargs,\n        )\n        return self.ax\n</code></pre>"},{"location":"plots/wind/#monet_plots.plots.wind_barbs.WindBarbsPlot.__init__","title":"<code>__init__(ws, wdir, gridobj, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>ws</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind speeds.</p> required <code>wdir</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind directions.</p> required <code>gridobj</code> <code>object</code> <p>Object with LAT and LON variables.</p> required <code>**kwargs</code> <p>Keyword arguments passed to SpatialPlot for projection and features.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/wind_barbs.py</code> <pre><code>def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n        wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n        gridobj (object): Object with LAT and LON variables.\n        **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.ws = np.asarray(ws)\n    self.wdir = np.asarray(wdir)\n    self.gridobj = gridobj\n</code></pre>"},{"location":"plots/wind/#monet_plots.plots.wind_barbs.WindBarbsPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the wind barbs plot.</p> Source code in <code>src/monet_plots/plots/wind_barbs.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the wind barbs plot.\"\"\"\n    barb_kwargs = self.add_features(**kwargs)\n    barb_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n    lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n    u, v = tools.wsdir2uv(self.ws, self.wdir)\n    # Subsample the data for clarity\n    skip = barb_kwargs.pop(\"skip\", 15)\n    self.ax.barbs(\n        lon[::skip, ::skip],\n        lat[::skip, ::skip],\n        u[::skip, ::skip],\n        v[::skip, ::skip],\n        **barb_kwargs,\n    )\n    return self.ax\n</code></pre>"},{"location":"plots/wind_barbs/","title":"Wind Barbs","text":""},{"location":"plots/wind_barbs/#monet_plots.plots.wind_barbs.WindBarbsPlot","title":"<code>WindBarbsPlot</code>","text":"<p>               Bases: <code>SpatialPlot</code></p> <p>Create a barbs plot of wind on a map.</p> <p>This plot shows wind speed and direction using barbs.</p> Source code in <code>src/monet_plots/plots/wind_barbs.py</code> <pre><code>class WindBarbsPlot(SpatialPlot):\n    \"\"\"Create a barbs plot of wind on a map.\n\n    This plot shows wind speed and direction using barbs.\n    \"\"\"\n\n    def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n        \"\"\"\n        Initialize the plot with data and map projection.\n\n        Args:\n            ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n            wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n            gridobj (object): Object with LAT and LON variables.\n            **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.ws = np.asarray(ws)\n        self.wdir = np.asarray(wdir)\n        self.gridobj = gridobj\n\n    def plot(self, **kwargs):\n        \"\"\"Generate the wind barbs plot.\"\"\"\n        barb_kwargs = self.add_features(**kwargs)\n        barb_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n        lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n        lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n        u, v = tools.wsdir2uv(self.ws, self.wdir)\n        # Subsample the data for clarity\n        skip = barb_kwargs.pop(\"skip\", 15)\n        self.ax.barbs(\n            lon[::skip, ::skip],\n            lat[::skip, ::skip],\n            u[::skip, ::skip],\n            v[::skip, ::skip],\n            **barb_kwargs,\n        )\n        return self.ax\n</code></pre>"},{"location":"plots/wind_barbs/#monet_plots.plots.wind_barbs.WindBarbsPlot.__init__","title":"<code>__init__(ws, wdir, gridobj, *args, **kwargs)</code>","text":"<p>Initialize the plot with data and map projection.</p> <p>Parameters:</p> Name Type Description Default <code>ws</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind speeds.</p> required <code>wdir</code> <code>(ndarray, DataFrame, Series, DataArray)</code> <p>2D array of wind directions.</p> required <code>gridobj</code> <code>object</code> <p>Object with LAT and LON variables.</p> required <code>**kwargs</code> <p>Keyword arguments passed to SpatialPlot for projection and features.</p> <code>{}</code> Source code in <code>src/monet_plots/plots/wind_barbs.py</code> <pre><code>def __init__(self, ws: Any, wdir: Any, gridobj, *args, **kwargs):\n    \"\"\"\n    Initialize the plot with data and map projection.\n\n    Args:\n        ws (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind speeds.\n        wdir (np.ndarray, pd.DataFrame, pd.Series, xr.DataArray): 2D array of wind directions.\n        gridobj (object): Object with LAT and LON variables.\n        **kwargs: Keyword arguments passed to SpatialPlot for projection and features.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.ws = np.asarray(ws)\n    self.wdir = np.asarray(wdir)\n    self.gridobj = gridobj\n</code></pre>"},{"location":"plots/wind_barbs/#monet_plots.plots.wind_barbs.WindBarbsPlot.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Generate the wind barbs plot.</p> Source code in <code>src/monet_plots/plots/wind_barbs.py</code> <pre><code>def plot(self, **kwargs):\n    \"\"\"Generate the wind barbs plot.\"\"\"\n    barb_kwargs = self.add_features(**kwargs)\n    barb_kwargs.setdefault(\"transform\", ccrs.PlateCarree())\n\n    lat = self.gridobj.variables[\"LAT\"][0, 0, :, :].squeeze()\n    lon = self.gridobj.variables[\"LON\"][0, 0, :, :].squeeze()\n    u, v = tools.wsdir2uv(self.ws, self.wdir)\n    # Subsample the data for clarity\n    skip = barb_kwargs.pop(\"skip\", 15)\n    self.ax.barbs(\n        lon[::skip, ::skip],\n        lat[::skip, ::skip],\n        u[::skip, ::skip],\n        v[::skip, ::skip],\n        **barb_kwargs,\n    )\n    return self.ax\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting and FAQ","text":"<p>This comprehensive troubleshooting guide addresses common issues you may encounter while using MONET Plots, with solutions and best practices to ensure smooth plotting experiences.</p>"},{"location":"troubleshooting/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"troubleshooting/#installation-and-setup-issues","title":"Installation and Setup Issues","text":""},{"location":"troubleshooting/#importerror-no-module-named-monet_plots","title":"ImportError: No module named 'monet_plots'","text":"<p>Problem: Cannot import MONET Plots after installation.</p> <p>Solutions:</p> <pre><code># 1. Check if package is installed\npip list | grep monet_plots\n\n# 2. If not installed, install it\npip install monet_plots\n\n# 3. If installed, try reinstalling\npip uninstall monet_plots\npip install monet_plots\n\n# 4. Check Python environment\nwhich python  # Should show your virtual environment if active\npython -c \"import sys; print(sys.executable)\"\n</code></pre> <p>Python Code Solution: <pre><code># Verify installation\ntry:\n    import monet_plots\n    print(f\"MONET Plots version: {monet_plots.__version__}\")\n    print(\"Installation successful!\")\nexcept ImportError as e:\n    print(f\"Import error: {e}\")\n    print(\"Please install monet_plots: pip install monet_plots\")\n</code></pre></p>"},{"location":"troubleshooting/#missing-optional-dependencies","title":"Missing Optional Dependencies","text":"<p>Problem: Error when trying to use cartopy or other optional features.</p> <p>Solutions:</p> <pre><code># Install specific optional dependencies\npip install cartopy  # For geospatial plotting\npip install xarray netcdf4  # For NetCDF support\npip install seaborn pandas  # For enhanced plotting\npip install scipy  # For statistical functions\n</code></pre> <p>Code Solution: <pre><code># Check for optional dependencies\noptional_deps = {\n    'cartopy': 'Geospatial plotting',\n    'xarray': 'NetCDF data handling',\n    'seaborn': 'Enhanced statistical plotting',\n    'scipy': 'Advanced statistical functions'\n}\n\nmissing_deps = []\nfor dep, description in optional_deps.items():\n    try:\n        __import__(dep)\n        print(f\"\u2713 {dep} - {description}\")\n    except ImportError:\n        print(f\"\u2717 {dep} - {description} (not installed)\")\n        missing_deps.append(dep)\n\nif missing_deps:\n    print(f\"\\nInstall missing dependencies: pip install {' '.join(missing_deps)}\")\n</code></pre></p>"},{"location":"troubleshooting/#version-compatibility-issues","title":"Version Compatibility Issues","text":"<p>Problem: MONET Plots conflicts with other packages due to version requirements.</p> <p>Solutions:</p> <pre><code># Check package versions\npip show matplotlib pandas numpy\n\n# Install compatible versions\npip install matplotlib&gt;=3.3.0 pandas&gt;=1.0.0 numpy&gt;=1.18.0\npip install monet_plots\n\n# Or use conda for better dependency management\nconda install -c conda-forge monet_plots matplotlib pandas numpy\n</code></pre>"},{"location":"troubleshooting/#plot-creation-issues","title":"Plot Creation Issues","text":""},{"location":"troubleshooting/#empty-plots-or-no-data-displayed","title":"Empty Plots or No Data Displayed","text":"<p>Problem: Plots are created but show no data or appear blank.</p> <p>Common Causes and Solutions:</p> <pre><code>import numpy as np\nimport pandas as pd\nfrom monet_plots import SpatialPlot\n\n# Cause 1: Data format issues\n# Solution: Check data shape and type\ndata = np.random.random((10, 10))  # Correct 2D array\nprint(f\"Data shape: {data.shape}, dtype: {data.dtype}\")\n\n# Cause 2: Missing or invalid data\n# Solution: Handle missing values\ndata_with_nan = np.random.random((10, 10))\ndata_with_nan[5:8, 3:6] = np.nan  # Add missing values\n\n# Use masked arrays for better visualization\nmasked_data = np.ma.masked_invalid(data_with_nan)\n\nplot = SpatialPlot()\nplot.plot(masked_data, title=\"Data with Missing Values\")\nplot.save(\"masked_data_plot.png\")\nplot.close()\n\n# Cause 3: Incorrect data dimensions\n# Solution: Ensure data matches plot requirements\ntry:\n    plot = SpatialPlot()\n    plot.plot(np.random.random(100))  # 1D array - will fail\n    plot.save(\"invalid_plot.png\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n    print(\"Spatial plots require 2D arrays\")\n\n# Correct usage\nplot = SpatialPlot()\nplot.plot(np.random.random((10, 10)))  # 2D array - works\nplot.save(\"valid_plot.png\")\nplot.close()\n</code></pre>"},{"location":"troubleshooting/#memory-errors-with-large-datasets","title":"Memory Errors with Large Datasets","text":"<p>Problem: Out of memory errors when plotting large datasets.</p> <p>Solutions:</p> <pre><code>import numpy as np\nfrom monet_plots import SpatialPlot\n\n# Strategy 1: Downsample data\nlarge_data = np.random.random((5000, 5000))  # 25M points\n\n# Simple downsampling\ndownsampled = large_data[::10, ::10]  # 250K points (100x reduction)\n\nplot = SpatialPlot()\nplot.plot(downsampled, title=\"Downsampled Data\")\nplot.save(\"downsampled_plot.png\")\nplot.close()\n\n# Strategy 2: Process in chunks\ndef process_large_data_in_chunks(data, chunk_size=1000):\n    \"\"\"Process large spatial data in chunks.\"\"\"\n    h, w = data.shape\n    for i in range(0, h, chunk_size):\n        for j in range(0, w, chunk_size):\n            chunk = data[i:i+chunk_size, j:j+chunk_size]\n            # Process and save chunk\n            plot = SpatialPlot()\n            plot.plot(chunk)\n            plot.save(f\"chunk_{i}_{j}.png\")\n            plot.close()\n\n# Process a section of the large data\nprocess_large_data_in_chunks(large_data[:2000, :2000])\n\n# Strategy 3: Use more efficient data types\nefficient_data = large_data.astype(np.float32)  # 50% memory reduction\nprint(f\"Original: {large_data.nbytes / 1024**2:.1f} MB\")\nprint(f\"Optimized: {efficient_data.nbytes / 1024**2:.1f} MB\")\n</code></pre>"},{"location":"troubleshooting/#slow-plot-rendering","title":"Slow Plot Rendering","text":"<p>Problem: Plots take a long time to render, especially with large datasets.</p> <p>Solutions:</p> <pre><code>import numpy as np\nimport time\nfrom monet_plots import SpatialPlot\n\n# Performance optimization techniques\ndata = np.random.random((2000, 2000))\n\n# Technique 1: Use discrete colorbars for large data\nstart_time = time.time()\nplot = SpatialPlot()\nplot.plot(data, discrete=True, ncolors=20)\nplot.save(\"discrete_colormap_plot.png\")\nplot.close()\ndiscrete_time = time.time() - start_time\nprint(f\"Discrete colormap: {discrete_time:.2f}s\")\n\n# Technique 2: Choose efficient colormaps\nfast_colormaps = ['viridis', 'plasma', 'inferno', 'magma', 'cividis']\n\nfor cmap in fast_colormaps:\n    start_time = time.time()\n    plot = SpatialPlot()\n    plot.plot(data, cmap=cmap)\n    plot.save(f\"fast_cmap_{cmap}.png\")\n    plot.close()\n    print(f\"{cmap}: {time.time() - start_time:.2f}s\")\n\n# Technique 3: Reduce resolution for previews\nlow_res_data = data[::4, ::4]  # 16x reduction\nstart_time = time.time()\nplot = SpatialPlot()\nplot.plot(low_res_data)\nplot.save(\"low_res_preview.png\")\nplot.close()\nprint(f\"Low res preview: {time.time() - start_time:.2f}s\")\n</code></pre>"},{"location":"troubleshooting/#colorbar-issues","title":"Colorbar Issues","text":"<p>Problem: Colorbars not displaying correctly or not aligning with plots.</p> <p>Solutions:</p> <pre><code>from monet_plots import SpatialPlot, colorbar_index\nimport numpy as np\n\n# Problem: Colorbar not matching data\ndata = np.random.random((50, 50)) * 100\n\n# Solution 1: Use discrete colorbars\nplot = SpatialPlot()\nplot.plot(data, discrete=True, ncolors=15)\nplot.save(\"discrete_colorbar.png\")\nplot.close()\n\n# Solution 2: Custom colorbar creation\nplot = SpatialPlot()\nplot.plot(data, cmap='viridis')\n\n# Add custom colorbar\ncbar, cmap = colorbar_index(15, 'viridis', minval=0, maxval=100, dtype=int)\nplot.save(\"custom_colorbar.png\")\nplot.close()\n\n# Solution 3: Handle data ranges properly\ndata_with_extreme_values = np.random.random((50, 50))\ndata_with_extreme_values[10:15, 20:25] = 1000  # Extreme values\n\nplot = SpatialPlot()\nplot.plot(\n    data_with_extreme_values,\n    vmin=0,\n    vmax=100,\n    title=\"Data with Extreme Values (Clamped)\"\n)\nplot.save(\"clamped_colorbar.png\")\nplot.close()\n</code></pre>"},{"location":"troubleshooting/#styling-and-formatting-issues","title":"Styling and Formatting Issues","text":"<p>Problem: Plots don't match expected styling or formatting.</p> <p>Solutions:</p> <pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import SpatialPlot, style\nimport numpy as np\n\n# Problem: Default styling not applied\n# Solution: Apply MONET Plots style\nplt.style.use(style.wiley_style)\n\ndata = np.random.random((50, 50))\nplot = SpatialPlot()\nplot.plot(data, title=\"Wiley Style Applied\")\nplot.save(\"styled_plot.png\")\nplot.close()\n\n# Problem: Font sizes too small or too large\n# Solution: Customize font settings\ncustom_style = {\n    'font.size': 12,\n    'axes.labelsize': 10,\n    'axes.titlesize': 14,\n    'xtick.labelsize': 9,\n    'ytick.labelsize': 9,\n    'legend.fontsize': 10\n}\n\nplt.style.use(custom_style)\n\nplot = SpatialPlot()\nplot.plot(data, title=\"Custom Font Sizes\")\nplot.save(\"custom_fonts.png\")\nplot.close()\n\n# Problem: Labels not showing\n# Solution: Ensure labels are properly set\nplot = SpatialPlot()\nplot.plot(data, title=\"Proper Labels\")\nplot.xlabel(\"Longitude (degrees)\")\nplot.ylabel(\"Latitude (degrees)\")\nplot.save(\"proper_labels.png\")\nplot.close()\n</code></pre>"},{"location":"troubleshooting/#data-handling-issues","title":"Data Handling Issues","text":""},{"location":"troubleshooting/#time-series-data-issues","title":"Time Series Data Issues","text":"<p>Problem: Time series plots not displaying correctly with datetime data.</p> <p>Solutions:</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom monet_plots import TimeSeriesPlot\n\n# Problem: Incorrect datetime format\n# Solution: Ensure proper datetime handling\n\n# Create proper datetime data\ndates = pd.date_range('2023-01-01', periods=100, freq='D')\nvalues = np.cumsum(np.random.normal(0, 1, 100))\n\ndf = pd.DataFrame({\n    'date': dates,\n    'value': values,\n    'category': np.random.choice(['A', 'B'], 100)\n})\n\n# Correct time series plotting\nplot = TimeSeriesPlot()\nplot.plot(df, x='date', y='value', title=\"Proper Time Series\")\nplot.save(\"correct_timeseries.png\")\nplot.close()\n\n# Problem: Missing datetime values\n# Solution: Handle missing data\ndf_with_missing = df.copy()\ndf_with_missing.loc[10:15, 'value'] = np.nan\n\nplot = TimeSeriesPlot()\nplot.plot(df_with_missing, x='date', y='value', title=\"Time Series with Missing Data\")\nplot.save(\"timeseries_missing_data.png\")\nplot.close()\n\n# Problem: Multiple time series not distinguished\n# Solution: Use proper coloring and legends\nplot = TimeSeriesPlot()\nfor category in ['A', 'B']:\n    subset = df[df['category'] == category]\n    plot.plot(subset, x='date', y='value', label=category)\n\nplot.title(\"Multiple Time Series\")\nplot.legend()\nplot.save(\"multiple_timeseries.png\")\nplot.close()\n</code></pre>"},{"location":"troubleshooting/#pandas-dataframe-issues","title":"Pandas DataFrame Issues","text":"<p>Problem: DataFrames not compatible with MONET Plots functions.</p> <p>Solutions:</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom monet_plots import ScatterPlot\n\n# Problem: Column names not matching\n# Solution: Check and rename columns\n\n# Create DataFrame with problematic column names\ndf = pd.DataFrame({\n    'x_values': np.random.normal(0, 1, 100),\n    'y_values': np.random.normal(0, 1, 100),\n    'group_col': np.random.choice(['Group 1', 'Group 2'], 100)\n})\n\n# Rename columns to match expected format\ndf_renamed = df.rename(columns={\n    'x_values': 'x',\n    'y_values': 'y',\n    'group_col': 'group'\n})\n\n# Check DataFrame structure\nprint(\"Original columns:\", list(df.columns))\nprint(\"Renamed columns:\", list(df_renamed.columns))\n\n# Plot with renamed columns\nplot = ScatterPlot()\nplot.plot(df_renamed, x='x', y='y', title=\"Correct Column Names\")\nplot.save(\"correct_columns.png\")\nplot.close()\n\n# Problem: Non-numeric data causing issues\n# Solution: Handle categorical data properly\ncategorical_df = pd.DataFrame({\n    'measurement': np.random.normal(0, 1, 100),\n    'category': np.random.choice(['Type A', 'Type B', 'Type C'], 100),\n    'quality': np.random.choice(['High', 'Low'], 100)\n})\n\n# Convert categorical to numeric if needed\ncategorical_df['category_numeric'] = pd.Categorical(categorical_df['category']).codes\n\nplot = ScatterPlot()\nplot.plot(categorical_df, x='measurement', y='category_numeric',\nplot.plot(categorical_df, x='measurement', y='category_numeric',\n         title=\"Categorical Data Handling\")\nplot.save(\"categorical_handling.png\")\nplot.close()\n</code></pre>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#memory-leaks","title":"Memory Leaks","text":"<p>Problem: Memory usage increases over time when creating multiple plots.</p> <p>Solutions:</p> <pre><code>import psutil\nimport os\nimport numpy as np\nfrom monet_plots import SpatialPlot\n\ndef get_memory_usage():\n    \"\"\"Get current memory usage in MB.\"\"\"\n    process = psutil.Process(os.getpid())\n    return process.memory_info().rss / (1024 * 1024)\n\n# Problem: Memory buildup from unclosed plots\ninitial_memory = get_memory_usage()\nprint(f\"Initial memory: {initial_memory:.2f} MB\")\n\n# Bad practice: Not closing plots\nfor i in range(10):\n    data = np.random.random((100, 100))\n    plot = SpatialPlot()\n    plot.plot(data)\n    plot.save(f\"memory_leak_plot_{i}.png\")\n    # plot.close()  # This causes memory buildup!\n\nmemory_after_leak = get_memory_usage()\nprint(f\"Memory after leak: {memory_after_leak:.2f} MB\")\nprint(f\"Memory wasted: {memory_after_leak - initial_memory:.2f} MB\")\n\n# Good practice: Always close plots\nfor i in range(10):\n    data = np.random.random((100, 100))\n    plot = SpatialPlot()\n    plot.plot(data)\n    plot.save(f\"proper_cleanup_plot_{i}.png\")\n    plot.close()  # Proper cleanup\n\nmemory_after_cleanup = get_memory_usage()\nprint(f\"Memory after cleanup: {memory_after_cleanup:.2f} MB\")\nprint(f\"Memory used per plot: {(memory_after_cleanup - initial_memory) / 10:.2f} MB\")\n\n# Best practice: Use context managers\nfor i in range(10):\n    data = np.random.random((100, 100))\n    with SpatialPlot() as plot:\n        plot.plot(data)\n        plot.save(f\"context_manager_plot_{i}.png\")\n</code></pre>"},{"location":"troubleshooting/#slow-interactive-plotting","title":"Slow Interactive Plotting","text":"<p>Problem: Interactive plots are unresponsive or slow to update.</p> <p>Solutions:</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nfrom monet_plots import TimeSeriesPlot\n\n# Enable interactive mode\nplt.ion()\n\n# Problem: Slow interactive updates\n# Solution: Downsample data for interactive use\n\n# Large dataset (slow for interactive)\ninteractive_data = np.cumsum(np.random.normal(0, 1, 10000))\ndates = pd.date_range('2023-01-01', periods=10000, freq='H')\nlarge_df = pd.DataFrame({'time': dates, 'value': interactive_data})\n\n# Downsample for interactive plotting\ndf_interactive = large_df.iloc[::10, :].copy()  # 10x reduction\n\nplot = TimeSeriesPlot()\nplot.plot(df_interactive, x='time', y='value', title=\"Interactive (Downsampled)\")\nplt.draw()  # Force update\n\n# Problem: Interactive updates too frequent\n# Solution: Control update frequency\nplt.ioff()  # Turn off interactive updates temporarily\n\n# Make multiple changes\nplot.title Updated Title\")\nplot.ylabel(\"Updated Y-axis\")\nplt.xlabel(\"Updated X-axis\")\n\nplt.ion()  # Turn interactive updates back on\nplt.draw()  # Single update\n\n# Problem: Interactive mode not working\n# Solution: Check and force interactive mode\nprint(f\"Interactive mode: {plt.isinteractive()}\")\n\nif not plt.isinteractive():\n    plt.ion()\n    print(\"Interactive mode enabled\")\n\n\n    # Test interactive update\n    plot.title(\"Interactive Test\")\n    plt.draw()\n</code></pre>"},{"location":"troubleshooting/#advanced-troubleshooting","title":"Advanced Troubleshooting","text":""},{"location":"troubleshooting/#debug-information-collection","title":"Debug Information Collection","text":"<p>Problem: Need detailed information about the current state for debugging.</p> <p>Solutions:</p> <pre><code>import sys\nimport platform\nimport matplotlib\nimport pandas as pd\nimport numpy as np\nfrom monet_plots import SpatialPlot\n\ndef collect_system_info():\n    \"\"\"Collect comprehensive system information.\"\"\"\n    info = {\n        'System': platform.system(),\n        'Python Version': sys.version,\n        'Matplotlib Version': matplotlib.__version__,\n        'Pandas Version': pd.__version__,\n        'NumPy Version': np.__version__,\n        'Platform': platform.platform(),\n        'Processor': platform.processor(),\n        'Memory': f\"{round(platform.meminfo().total / (1024**3), 2)} GB\"\n    }\n\n\n    print(\"System Information:\")\n    for key, value in info.items():\n        print(f\"{key}: {value}\")\n\n\n    return info\n\ndef collect_plot_debug_info():\n    \"\"\"Collect plot-specific debug information.\"\"\"\n    try:\n        # Test basic plot creation\n        test_data = np.random.random((10, 10))\n\n\n        plot = SpatialPlot()\n        plot.plot(test_data)\n\n\n        debug_info = {\n            'Plot Created': True,\n            'Data Shape': test_data.shape,\n            'Data Type': test_data.dtype,\n            'Memory Usage': f\"{test_data.nbytes / 1024} KB\",\n            'Matplotlib Backend': matplotlib.get_backend(),\n            'Figure Size': plot.fig.get_size_inches(),\n            'DPI': plot.fig.get_dpi()\n        }\n\n\n        print(\"\\nPlot Debug Information:\")\n        for key, value in debug_info.items():\n            print(f\"{key}: {value}\")\n\n\n        plot.close()\n        return debug_info\n\n\n    except Exception as e:\n        print(f\"\\nPlot Creation Failed: {e}\")\n        return {'Plot Created': False, 'Error': str(e)}\n\n# Collect and display debug information\nsystem_info = collect_system_info()\nplot_info = collect_plot_debug_info()\n</code></pre>"},{"location":"troubleshooting/#performance-profiling","title":"Performance Profiling","text":"<p>Problem: Need to identify performance bottlenecks in plotting code.</p> <p>Solutions:</p> <pre><code>import cProfile\nimport pstats\nimport io\nimport numpy as np\nfrom monet_plots import SpatialPlot, TimeSeriesPlot, ScatterPlot\n\ndef profile_plot_operations():\n    \"\"\"Profile different plot operations.\"\"\"\n\n\n    def profile_spatial_plot():\n        data = np.random.random((500, 500))\n        plot = SpatialPlot()\n        plot.plot(data)\n        plot.save(\"profiled_spatial.png\")\n        plot.close()\n\n\n    def profile_timeseries_plot():\n        import pandas as pd\n        dates = pd.date_range('2023-01-01', periods=1000, freq='D')\n        values = np.cumsum(np.random.normal(0, 1, 1000))\n        df = pd.DataFrame({'time': dates, 'value': values})\n\n\n        plot = TimeSeriesPlot()\n        plot.plot(df, x='time', y='value')\n        plot.save(\"profiled_timeseries.png\")\n        plot.close()\n\n\n    def profile_scatter_plot():\n        import pandas as pd\n        x = np.random.normal(0, 1, 5000)\n        y = x * 2 + np.random.normal(0, 1, 5000)\n        df = pd.DataFrame({'x': x, 'y': y})\n\n\n        plot = ScatterPlot()\n        plot.plot(df, x='x', y='y')\n        plot.save(\"profiled_scatter.png\")\n        plot.close()\n\n\n    # Profile each operation\n    operations = [\n        (\"Spatial Plot\", profile_spatial_plot),\n        (\"Time Series Plot\", profile_timeseries_plot),\n        (\"Scatter Plot\", profile_scatter_plot)\n    ]\n\n\n    for name, operation in operations:\n        print(f\"\\nProfiling {name}:\")\n\n\n        profiler = cProfile.Profile()\n        profiler.enable()\n        operation()\n        profiler.disable()\n\n\n        # Get statistics\n        stats_stream = io.StringIO()\n        stats = pstats.Stats(profiler, stream=stats_stream)\n        stats.sort_stats('cumulative')\n        stats.print_stats(5)  # Top 5 functions\n\n\n        print(stats_stream.getvalue())\n</code></pre>"},{"location":"troubleshooting/#error-logging-and-recovery","title":"Error Logging and Recovery","text":"<p>Problem: Need robust error handling and logging for production plotting.</p> <p>Solutions:</p> <pre><code>import logging\nimport traceback\nfrom datetime import datetime\nfrom monet_plots import SpatialPlot\nimport numpy as np\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('plotting_errors.log'),\n        logging.StreamHandler()\n    ]\n)\n\ndef safe_plot_creation(data, config, output_path):\n    \"\"\"Safely create plots with error handling and logging.\"\"\"\n    try:\n        logging.info(f\"Starting plot creation for {output_path}\")\n        logging.info(f\"Data shape: {data.shape}, config: {config}\")\n\n\n        # Validate input data\n        if data is None:\n            raise ValueError(\"Data cannot be None\")\n        if not hasattr(data, 'shape'):\n            raise ValueError(\"Data must be a numpy array or similar\")\n\n\n        # Create plot\n        plot = SpatialPlot(**config.get('plot_kwargs', {}))\n\n\n        # Plot data\n        plot_kwargs = config.get('plot_kwargs', {})\n        plot.plot(data, **plot_kwargs)\n\n\n        # Save plot\n        plot.save(output_path, **config.get('save_kwargs', {}))\n        plot.close()\n\n\n        logging.info(f\"Successfully created plot: {output_path}\")\n        return True\n\n\n    except MemoryError as e:\n        logging.error(f\"Memory error creating {output_path}: {e}\")\n        # Try with downsampled data\n        try:\n            downsampled_data = data[::2, ::2]\n            logging.info(f\"Attempting with downsampled data: {downsampled_data.shape}\")\n            return safe_plot_creation(downsampled_data, config, f\"downsampled_{output_path}\")\n        except Exception as retry_error:\n            logging.error(f\"Retry failed for {output_path}: {retry_error}\")\n            return False\n\n\n    except Exception as e:\n        logging.error(f\"Error creating {output_path}: {e}\")\n        logging.error(f\"Traceback: {traceback.format_exc()}\")\n        return False\n\n# Usage example\nplot_config = {\n    'plot_kwargs': {\n        'title': 'Safe Plot Creation Example',\n        'cmap': 'viridis'\n    },\n    'save_kwargs': {\n        'dpi': 300\n    }\n}\n\ntest_data = np.random.random((1000, 1000))\nsuccess = safe_plot_creation(test_data, plot_config, \"safe_plot.png\")\n\nif success:\n    print(\"Plot created successfully!\")\nelse:\n    print(\"Plot creation failed. Check logs for details.\")\n</code></pre>"},{"location":"troubleshooting/#faq-frequently-asked-questions","title":"FAQ (Frequently Asked Questions)","text":""},{"location":"troubleshooting/#general-questions","title":"General Questions","text":"<p>Q1: What is the best way to learn MONET Plots?</p> <p>A: Start with the Getting Started Guide, then explore the Examples section. Begin with basic plots and gradually work up to more complex visualizations.</p> <p>Q2: Can I use MONET Plots with Jupyter notebooks?</p> <p>A: Yes! MONET Plots works seamlessly with Jupyter. Use <code>%matplotlib inline</code> for static plots or <code>%matplotlib widget</code> for interactive plots.</p> <pre><code>%matplotlib inline\nfrom monet_plots import SpatialPlot\nplot = SpatialPlot()\nplot.plot(data)\nplot.save(\"notebook_plot.png\")\n</code></pre> <p>Q3: How do I contribute to MONET Plots?</p> <p>A: We welcome contributions! Please see our contributing guidelines for details on reporting issues, suggesting features, or submitting code.</p>"},{"location":"troubleshooting/#technical-questions","title":"Technical Questions","text":"<p>Q4: What are the system requirements for MONET Plots?</p> <p>A: A: - Python 3.7+ - 512MB RAM minimum (1GB+ recommended) - 50MB disk space - Optional: cartopy for geospatial features, xarray for NetCDF support</p> <p>Q5: Can I use MONET Plots with data from NetCDF files?</p> <p>A: Yes, if you have xarray installed:</p> <pre><code>import xarray as xr\nfrom monet_plots import SpatialPlot\n\nds = xr.open_dataset('data.nc')\nplot = SpatialPlot()\nplot.plot(ds.temperature)\nplot.save(\"netcdf_plot.png\")\nplot.close()\n</code></pre> <p>Q6: How do I handle missing data in plots?</p> <p>A: MONET Plots automatically handles NaN values, but you can also use masked arrays for better control:</p> <pre><code>import numpy as np\nfrom monet_plots import SpatialPlot\n\ndata = np.random.random((50, 50))\ndata[10:20, 10:20] = np.nan  # Add missing values\n\nmasked_data = np.ma.masked_invalid(data)\nplot = SpatialPlot()\nplot.plot(masked_data)\nplot.save(\"missing_data_plot.png\")\nplot.close()\n</code></pre>"},{"location":"troubleshooting/#performance-questions","title":"Performance Questions","text":"<p>Q7: My plots are very slow, how can I improve performance?</p> <p>A: Try these optimizations: 1. Downsample data: <code>data[::4, ::4]</code> (16x reduction) 2. Use discrete colorbars: <code>discrete=True, ncolors=20</code> 3. Close plots properly: <code>plot.close()</code> 4. Use efficient data types: <code>data.astype(np.float32)</code></p> <p>Q8: How much memory do large plots use?</p> <p>A: Memory usage depends on data size and type: - Float64: 8 bytes per element - Float32: 4 bytes per element (50% reduction) - Int32: 4 bytes per element</p> <p>Example: 1000x1000 float64 array = ~7.6MB</p> <p>Q9: Can I create batch plots efficiently?</p> <p>A: Yes! Use batch processing to create multiple plots efficiently:</p> <pre><code>from monet_plots import SpatialPlot\nimport numpy as np\n\n# Generate all data first\ndatasets = [np.random.random((100, 100)) for _ in range(10)]\n\n# Create plots in batch\nplots = []\nfor i, data in enumerate(datasets):\n    plot = SpatialPlot()\n    plot.plot(data, title=f\"Plot {i+1}\")\n    plots.append(plot)\n\n# Save all plots\nfor i, plot in enumerate(plots):\n    plot.save(f\"batch_plot_{i+1}.png\")\n    plot.close()\n</code></pre>"},{"location":"troubleshooting/#styling-questions","title":"Styling Questions","text":"<p>Q10: How do I create publication-quality plots?</p> <p>A: Use the built-in Wiley-compliant style:</p> <pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import style, TimeSeriesPlot\n\nplt.style.use(style.wiley_style)\n\nplot = TimeSeriesPlot()\nplot.plot(data, title=\"Publication-Quality Plot\")\nplot.xlabel(\"X Axis Label\")\nplot.ylabel(\"Y Axis Label\")\nplot.save(\"publication_plot.png\", dpi=300)\nplot.close()\n</code></pre> <p>Q11: Can I customize the appearance of plots?</p> <p>A: Yes, you can customize almost every aspect:</p> <pre><code>from monet_plots import SpatialPlot\n\nplot = SpatialPlot(\n    figsize=(12, 8),\n    dpi=150\n)\n\nplot.plot(\n    data,\n    cmap='viridis',\n    title=\"Custom Styled Plot\",\n    fontsize=12,\n    linewidth=2\n)\n\nplot.xlabel(\"Custom X Label\", fontsize=10)\nplot.ylabel(\"Custom Y Label\", fontsize=10)\nplot.save(\"custom_styled_plot.png\")\nplot.close()\n</code></pre> <p>Q12: How do I create consistent styling across multiple plots?</p> <p>A: Define a custom style and reuse it:</p> <pre><code>import matplotlib.pyplot as plt\nfrom monet_plots import style\n\n# Create custom style\ncustom_style = {\n    'font.size': 12,\n    'axes.labelsize': 10,\n    'axes.titlesize': 14,\n    'figure.figsize': (10, 6),\n    'savefig.dpi': 300\n}\n\n# Save style\nplt.style.use(custom_style)\n\n# Apply to all plots\nfrom monet_plots import SpatialPlot, TimeSeriesPlot\n\nplot1 = SpatialPlot()\nplot1.plot(data1, title=\"Consistent Style 1\")\nplot1.save(\"consistent_plot1.png\")\n\nplot2 = TimeSeriesPlot()\nplot2.plot(data2, title=\"Consistent Style 2\")\nplot2.save(\"consistent_plot2.png\")\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"troubleshooting/#community-support","title":"Community Support","text":"<ul> <li>GitHub Issues: Report bugs and request features</li> <li>GitHub Discussions: Ask questions and share knowledge</li> <li>Documentation: Check the full documentation</li> </ul>"},{"location":"troubleshooting/#professional-support","title":"Professional Support","text":"<p>For professional support and consulting: - Contact the development team - Check for commercial support options - Consider training and workshops</p>"},{"location":"troubleshooting/#contributing-to-documentation","title":"Contributing to Documentation","text":"<p>Help improve this troubleshooting guide by: - Adding new issues and solutions - Improving existing explanations - Providing code examples - Reporting unclear sections</p> <p>Related Resources:</p> <ul> <li>Getting Started Guide - Installation and basic usage</li> <li>API Reference - Complete API documentation</li> <li>Examples - Practical examples and tutorials</li> <li>Performance Guide - Optimization techniques</li> <li>Configuration Guide - Customization options</li> </ul>"}]}